## 《数据结构与算法分析》C++语言描述4th

+ https://github.com/juejian/Data-Structures-and-Algorithm-Analysis-in-Cpp-4th

+ 我自己有一本纸质的，C语言描述2nd，*2者结合着看*
+ Part1、预备知识（1-3）
+ Part2、基本数据结构（4-6）

### chap1、程序设计：综述

#### 1.1、本书讨论的内容

+ 一、选择问题，topK（N个数确定其中第k个最大者）
  + 方法1：先排序
  + 方法2：先读前k个，然后再逐个对比，大于k的话，就把最后一个元素挤出去
+ 二、字谜（二维数组和单词表）
  + 方法1：
  + 方法2：

#### 1.2、数学知识复习

1.2.1、指数（exponent）

1.2.2、对数（logarithm）

1.2.3、级数（series）

1.2.4、模运算（modular arithmetic）

##### 1.2.5、证明方法

#### 1.3、递归简论

+ 递归的4条基本法则：
  + 1、基准情形
  + 2、要有进展  递归时，**每一次递归调用都必须要使状况朝向一种基准情形推进**
  + 3、设计法则
  + 4、合成效益法则（compound interest rule） **在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作**

#### 1.5、C++细节

##### 1.5.1、指针（pointer）

##### 1.5.2、左值、右值和引用

1.5.3、参数传递

1.5.4、返回值传递

1.5.5、std::swap和std::move

1.5.6、五大函数：析构、拷贝构造、移动构造、拷贝赋值operator=、移动赋值operator=

#### 1.6、模板

1.6.1、函数模板

1.6.4、函数对象

1.6.5、类模板的分离式编译

#### 1.7、使用矩阵

1.7.1、数据成员、构造函数和基本访问函数

1.7.2、operator[]

1.7.3、五大函数

#### 小结

### chap2、

#### 2.3、要分析的问题

+ **最大子序列和问题**（leetcode42、可以用动态规划实现）
  + `Q(list,i)=max(0,Q(list,i-1)+list[i])`

#### chap4、线性表、栈和队列

#### 4.1、线性表

#### 4.2、字典ADT

#### 4.4、队列

#### 4.6、习题

### chap5、二叉树

#### 5.1、定义及主要特性

##### 5.1.1、满二叉树定理

##### 5.1.2、二叉树的抽象数据类型

#### 5.2、遍历二叉树

+ 例5.4、编写一个函数，计算一棵二叉树的结点数。【*感觉要用递归啊，直到子节点时+1*】

#### 5.3、二叉树的实现

5.4、二叉查找树

5.5、堆与优先队列

5.6、Huffman编码树

5.7、深入学习导读

5.8、习题

5.9、项目设计

#### 0、

+ 二叉树->满二叉树->二叉排序树（搜索树）【左边小于根，右边大于根】->平衡二叉树（AVL树）【左右子树的高度差1】->红黑树【根是黑的，子节点是黑的，红色结点有2个黑的，不能有连续2个红的】
+ leetcode上的题（114，116，226）

### chap7、排序

#### 7.2、插入排序

##### 7.2.1、算法

+ *个人思考，其实是两层*
  + 外层 是数组大小（for到a.size()）
  + 内层 是把第i轮前面的都要保证有序
+ 以34，8，64，51，32，21取例，看外层的话，需要移动位置数是多少，*代码实现上与C差不多*

```c++
template<typename Compareble>
void insertionSort(vector<Comparable> &a){
    for(int p=1;p<a.size();++p){
        Compareable tmp = std::move(a[p]);
        int j;
        for(j=p;j>0&&tmp<a[j-1];--j){
            a[j]=std::move(a[j-1]);
        }
        a[j]=std::move(tmp);
    }
}
```



##### 7.2.2、插入排序的STL实现



### chap10、算法设计技巧

#### 10.1、贪婪算法（greedy algorithm）

+ 3个应用：Dijkstra、Prim、Kruskal
+ 贪婪算法**分阶段地工作**，在每个阶段，可以认为所作决定是好的，而不考虑将来的后果，**局部的最优**
+ 一些例子
  + 货币找零钱
  + 交通问题
+ 本节的应用例子
  + 简单的调度问题
  + 处理文件压缩
  + 贪婪近似算法

##### 10.1.1、一个简单的调度问题

##### 10.1.2、哈夫曼编码

##### 10.1.3、近似装箱问题

#### 10.2、分治算法

+ 分治算法（divide and conquer）两部分组成：
  + 分（divide）：递归解决较小的问题
  + 治（conquer）：然后，从子问题的解构建原问题的解

10.2.1、分治算法的运行时间

10.2.2、最近点问题

##### 10.2.3、选择问题

##### 10.2.4、一些算术问题的理论改进

#### 10.3、动态规划

+ 把子问题的答案系统地记录在一个表内

##### 10.3.1、用表代表递归

10.3.2、矩阵乘法的顺序安排

10.3.3、最优二叉查找树

10.3.4、所有点对最短路径

#### 10.4、随机化算法

10.4.1、随机数发生器

10.4.2、跳跃表

10.4.3、素性测试

#### 10.5、回溯算法

+ 本质是个穷举，但可以删除明显不合适的。
+ **在一步内删除一大组可能性的做法**叫裁剪（pruning）
+ 举了2个例子
  + 计算几何中的问题
  + 国际象棋和西洋跳棋的对弈，如何选取行棋的步骤

##### 10.5.1、收费公路重建问题（turnpike reconstruction problem）

##### 10.5.2、博弈