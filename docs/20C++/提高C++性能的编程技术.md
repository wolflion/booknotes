## 《提高C++性能的编程技术》

### chap1、跟踪实例

+ 定义一个简单的Trace类将诊断信息打印到日志文件中

```cpp
#ifdef TRACE
Trace t("myFunction");
t.debug("some information message");
#endif
```

+ **使用ifdef的不足之处在于，必须重新编译程序来打开或关闭跟踪**。
+ `t.debug("x="+itoa(x));`，存在性能问题，**即使关闭了跟踪，仍然要创建string参数来传递给debug()函数**
  + 为"x="创建一个临时string对象
  + 调用itoa()
  + 从itoa()返回的字符指针创建一个临时的string对象
  + debug()调用返回后销毁全部三个string临时对象

#### 1.1、初步跟踪的实现

##### 1.1.1、到底怎么了？

+ 有几个公认的基本原则：
  + I/O的开销是高昂的
  + 函数调用的开销是要考虑的一个因素，应将短小的、频繁调用的函数内联
  + 复制对象的开销是高昂的。**最好选择传递引用，而不是传递值**。

##### 1.1.2、恢复计划

#### 1.2、要点

+ 不要把精力浪费在计算结果根本不会被使用的地方。

### chap2、构造函数和析构函数

+ 继承和复合与**代码重用**有关，可重用代码会在某种特定场合下计算某些不需要的数据。

#### 2.1、继承

#### 2.2、符合

2.3、缓式构造

2.4、冗余构造

2.5、要点

chap3、虚函数

3.1、虚函数的构造

3.2、模板和继承

3.3、要点

chap4、返回值优化

4.1、按值返回机制

4.2、返回值优化

4.3、计算性构造函数

4.4、要点

### chap5、临时对象

+ 编译器总是悄无声息地生成临时对象

#### 5.1、对象定义

5.2、类型不匹配

5.3、按值传递

5.4、按值返回

#### 5.5、使用op=()消除临时对象

+ `s5 = s1+s2+s3+s4;//产生3个临时对象`，改成`s5 = s1;  s5+=s2; s5+=s3; s5+=s4;`

5.6、要点

chap6、单线程内存池

### chap15、可扩展性

#### 15.1、对称多处理器架构

+ 解决总线竞争的办法是每个处理器使用大型缓存。

#### 15.2、Amdahl定律

+ 矩阵乘法由三个步骤组成
  + 初始化
  + 乘法
  + 显示

#### 15.3、多线程和同步

+ 不合适的交叉执行线程被称为**竞争条件**
+ 为了解决竞争条件，要保证这些汇编代码是原子执行的，称这些代码块为**临界区**
+ 一旦A线程进入临界区，B进程只能等待A退出后再进入，称**AB两个线程是同步的（串行化的）**，同时**该临界区是互斥的**
+ 变量x可以被多个线程访问，称它为**共享数据**，为了共享数据的安全，**使用锁（一个标记、比特位或整型）**与共享数据相关联
+ 临界区由锁来保护时，称它的执行是顺序执行的

#### 15.4、将任务分解为多个子任务

#### 15.5、缓存共享数据

#### 15.10、惊群现象

+ 当锁最后变得可用时，将会发生什么呢？
  + 只有一个线程被唤醒，它一般是等待队列上优先级最高的线程
  + 所有的线程都被唤醒，这会导致**惊群现象**（Thundering Herd）
+ 我们描述服务器有**接收-服务-记录**三个阶段时，**在接收阶段使用单线程**就是为试图避免“惊群现象”
+ **当服务器线程接受新的TCP/IP连接时，必须执行accept()调用**。告诉TCP/IP调用线程会在一个特定的TCP/IP端口接受下一个可用连接

#### 15.11、读/写锁

+ 线程对共享数据进行读访问必须满足以下条件之一：
  + 没有其他线程访问数据
  + 所有访问数据的线程都是读者线程

#### 15.12、要点

+ 减少或者消除顺序化的代码，**步骤**
  + 任务分解
  + 代码移出
  + 利用缓存
  + 无共享

### 最后

#### 履历

+ 2023-12-13看到人家的推荐，觉得是本好书，于是赶紧读起来。