<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>《Linux内核设计与实现》 - lionel的技术笔记</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u300aLinux\u5185\u6838\u8bbe\u8ba1\u4e0e\u5b9e\u73b0\u300b";
        var mkdocs_page_input_path = "13kernel\\Linux\u5185\u6838\u8bbe\u8ba1\u4e0e\u5b9e\u73b0.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> lionel的技术笔记
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../01daily/">daily</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">C++</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/effectiveC%2B%2B/">《Effective C++》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/EffectiveSTL/">《Effective STL》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网络编程</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">《TCP/IP网络编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">《Linux高性能服务器编程》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">文件系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/Linux%E5%86%85%E6%A0%B8%E6%8E%A2%E7%A7%98/">《Linux内核探秘》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《文件系统技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">《存储技术原理分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">存储</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../12storage/ceph%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《ceph设计原理与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">内核</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">《Linux内核设计与实现》</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#chap5">chap5、系统调用</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#51">5.1、与内核通信</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#52apiposixc">5.2、API、POSIX和C库</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#53">5.3、系统调用</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#531">5.3.1、系统调用号</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#532">5.3.2、系统调用的性能</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#54">5.4、系统调用处理程序</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_1">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#541">5.4.1、指定恰当的系统调用</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#542">5.4.2、参数传递</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#55">5.5、系统调用的实现</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#551">5.5.1、实现系统调用</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#552">5.5.2、参数验证</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#56">5.6、系统调用上下文</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_2">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#561">5.6.1、绑定一个系统调用的最后步骤</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#562">5.6.2、从用户空间访问系统调用</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#563">5.6.3、为什么不通过系统调用的方式实现</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#57">5.7、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap6">chap6、内核数据结构</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#61">6.1、链表</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_3">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#611">6.1.1、单向链表和双向链表</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#612">6.1.2、环形链表</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#613">6.1.3、沿链表移动</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#614linux">6.1.4、Linux内核中的实现</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#615">6.1.5、操作链表</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#616">6.1.6、遍历链表</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#62">6.2、队列</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_4">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#621kfifo">6.2.1、kfifo</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#622">6.2.2、创建队列</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#623">6.2.3、推入队列数据</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#624">6.2.4、摘取队列数据</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#625">6.2.5、获取队列数据</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#626">6.2.6、重置和撤销队列</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#627">6.2.7、队列使用举例</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#63">6.3、映射</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_5">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#631idr">6.3.1、初始化一个idr</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#632uid">6.3.2、分配一个新的UID</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#633uid">6.3.3、查找UID</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#634uid">6.3.4、删除UID</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#635idr">6.3.5、撤销idr</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#64">6.4、二叉树</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#641bst">6.4.1、二叉搜索树（BST）</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#642">6.4.2、自平衡二叉搜索树</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#65">6.5、数据结构以及选择</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#66">6.6、算法复杂度</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#661">6.6.1、算法</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#662o">6.6.2、大O符号</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#663xita">6.6.3、大xita符号</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#664">6.6.4、时间复杂度</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#67">6.7、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap9">chap9、内核同步介绍</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#91">9.1、临界区和竞争条件</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_6">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#911">9.1.1、为什么我们需要保护</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#912">9.1.2、单个变量</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#92">9.2、加锁</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_7">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#921">9.2.1、造成并发执行的原因</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#922">9.2.2、了解要保护些什么</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#93">9.3、死锁</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#94">9.4、争用和扩展性</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#95">9.5、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap12">chap12、内存管理</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#121">12.1、页</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#122">12.2、区</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#123">12.3、获得页</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_8">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#12310">12.3.1、获得填充为0的页</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1232">12.3.2、释放页</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#124kmalloc">12.4、kmalloc</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_9">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1241gfp_mask">12.4.1、gfp_mask标志</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1242kfree">12.4.2、kfree</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#125vmalloc">12.5、vmalloc</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#126slab">12.6、slab层</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_10">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1261slab">12.6.1、slab层的设计</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1262slab">12.6.2、slab分配器的接口</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#127">12.7、在栈上的静态分配</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_11">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1271">12.7.1、单页内核栈</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1272">12.7.2、在栈上光明正大地工作</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#128">12.8、高端内存的映射</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_12">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1281">12.8.1、永久映射</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1282">12.8.2、临时映射</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#129cpu">12.9、每个CPU的分配</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1210cpu">12.10、新的每个CPU接口</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_13">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#12101cpu">12.10.1、编译时的每个CPU数据</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#12102cpu">12.10.2、运行时的每个CPU数据</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1211cpu">12.11、使用每个CPU数据的原因</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1212">12.12、分配函数的选择</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1213">12.13、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap13">chap13、</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#131">13.1、通用文件系统接口</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#132">13.2、文件系统抽象层</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#133unix">13.3、Unix文件系统</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#134vfs">13.4、VFS对象及其数据结构</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#135">13.5、超级块对象</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#136">13.6、超级块操作</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#137">13.7、索引节点对象</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#138">13.8、索引节点操作</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#139">13.9、目录项对象</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1391">13.9.1、目录项状态</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1392">13.9.2、目录项缓存</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1310">13.10、目录项操作</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1311">13.11、文件对象</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1312">13.12、文件操作</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1313">13.13、和文件系统相关的数据结构</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1314">13.14、和进程相关的数据结构</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1315">13.15、小结</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/">《深入Linux设备驱动程序内核机制》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网课</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/01Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/">《Linux高并发网络编程开发》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/%E4%BE%AF%E6%8D%B7/%E4%BE%AF%E6%8D%B7C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8660%E8%AE%B2/">《侯捷C++内存管理60讲》</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">lionel的技术笔记</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>内核 &raquo;</li>
      <li>《Linux内核设计与实现》</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h2 id="linux">《Linux内核设计与实现》<a class="headerlink" href="#linux" title="Permanent link">&para;</a></h2>
<h3 id="chap5">chap5、系统调用<a class="headerlink" href="#chap5" title="Permanent link">&para;</a></h3>
<h4 id="51">5.1、与内核通信<a class="headerlink" href="#51" title="Permanent link">&para;</a></h4>
<ul>
<li>系统调用在用户空间进程和硬件设备之间添加了一个中间层。<strong>中间层</strong>的3个作用：</li>
</ul>
<h4 id="52apiposixc">5.2、API、POSIX和C库<a class="headerlink" href="#52apiposixc" title="Permanent link">&para;</a></h4>
<ul>
<li>POSIX是个标准</li>
<li>C库：实现了Unix系统的主要API，包括标准C库函数和系统调用接口</li>
<li>接口设计格言：<strong>提供机制而不是策略</strong>，<em>这个没懂，lionel</em></li>
</ul>
<h4 id="53">5.3、系统调用<a class="headerlink" href="#53" title="Permanent link">&para;</a></h4>
<h5 id="0">0、<a class="headerlink" href="#0" title="Permanent link">&para;</a></h5>
<ul>
<li>系统调用在出现错误的时候C库会把错误码写入errno全局变量。通过调用<code>perror</code>库函数，把该变量翻译成用户可以理解的错误字符串。</li>
<li><code>SYSCALL_DEFINE0</code>-这个在2.6.18里没找到啊，直接在<code>/include/linux/syscalls.h</code>中定义了<code>asmlinkage long sys_getpid(void);</code>，实现怎么在time.c了呢？
    + asmlinkage是个<strong>编译指令</strong>，通知编译器仅从栈中提取该函数的参数
    + 返回值是long的原因，兼容32位和64位
    + 系统调用的命名规则是<code>sys_</code>开头</li>
</ul>
<h5 id="531">5.3.1、系统调用号<a class="headerlink" href="#531" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>进程不会提及系统调用的名称</strong>，通过系统调用号来关联，<strong>一旦分配就不会再有任何变更</strong></li>
<li>所有已经注册过的系统调用的列表，存储在sys_call_table中。<em>2.6里搜了一下在arch/x86_64/kernel/syscall.c</em></li>
<li><em>问题1：何时删除系统调用号呢？ 问题2：系统调用号存在哪？</em></li>
<li>其它
    + <code>sys_ni_syscall()</code></li>
</ul>
<h5 id="532">5.3.2、系统调用的性能<a class="headerlink" href="#532" title="Permanent link">&para;</a></h5>
<h4 id="54">5.4、系统调用处理程序<a class="headerlink" href="#54" title="Permanent link">&para;</a></h4>
<h5 id="0_1">0、<a class="headerlink" href="#0_1" title="Permanent link">&para;</a></h5>
<ul>
<li>通知内核的机制是靠<strong>软中断</strong>实现的：通过引发一个异常</li>
<li>x86系统上预定义的软中断是<strong>中断号128，<code>int $0x80</code>指令</strong>，名称叫<code>system_call()</code></li>
<li>entry_64.S中用汇编编写</li>
<li>sysenter的指令</li>
</ul>
<h5 id="541">5.4.1、指定恰当的系统调用<a class="headerlink" href="#541" title="Permanent link">&para;</a></h5>
<ul>
<li>在x86上，<strong>系统调用号是通过eax寄存器传递给内核的</strong>。<em>eax寄存器是啥？lionel，问题1，什么时候传给eax寄存器的，用什么方式传的？</em></li>
<li><em>表项是64位存放的，所以要乘4，不太懂啥意思，lionel</em></li>
</ul>
<h5 id="542">5.4.2、参数传递<a class="headerlink" href="#542" title="Permanent link">&para;</a></h5>
<ul>
<li>x86-32系统上，<strong>ebx，ecx，edx，esi和edi按照顺序存放前5个参数</strong>。</li>
</ul>
<h4 id="55">5.5、系统调用的实现<a class="headerlink" href="#55" title="Permanent link">&para;</a></h4>
<h5 id="551">5.5.1、实现系统调用<a class="headerlink" href="#551" title="Permanent link">&para;</a></h5>
<ul>
<li><em>通过思考这个过程，去想一下，日常的接口怎么设计？lionel</em></li>
</ul>
<h5 id="552">5.5.2、参数验证<a class="headerlink" href="#552" title="Permanent link">&para;</a></h5>
<ul>
<li><code>copy_from_user()</code>和<code>copy_to_user()</code></li>
<li>书上以<code>kernel/sys.c</code>中的<code>sys_reboot()</code>为例，说了些要注意的权限问题</li>
<li><code>CAP_SYS_BOOT</code>，权限的定义在<code>/include/linux/capability.h</code>中，<em>以CAP开头，是因为capability.h的命名</em></li>
</ul>
<h4 id="56">5.6、系统调用上下文<a class="headerlink" href="#56" title="Permanent link">&para;</a></h4>
<h5 id="0_2">0、<a class="headerlink" href="#0_2" title="Permanent link">&para;</a></h5>
<ul>
<li><em>问题，为何可以休眠，是比较重要的呢</em></li>
</ul>
<h5 id="561">5.6.1、绑定一个系统调用的最后步骤<a class="headerlink" href="#561" title="Permanent link">&para;</a></h5>
<ul>
<li>注册
    + 1、在系统调用表的最后加入一个表项，<code>entry.S</code>
    + 2、支持各种体系结构，系统调用号都必须定义于<code>&lt;asm/unistd.h&gt;</code>
    + 3、<strong>系统调用必须被编译进内核映像（不能被编译成模块）</strong>，放在<code>kernel/</code>下的一个相关文件就可以了，比如sys.c</li>
</ul>
<h5 id="562">5.6.2、从用户空间访问系统调用<a class="headerlink" href="#562" title="Permanent link">&para;</a></h5>
<ul>
<li><code>_syscalln</code>，n的范围是0-6，表示<strong>需要传递给系统调用的参数个数</strong>。</li>
<li><em>lionel，这个没具体看，想实践一下，怎么编进内核，怎么写了跟内核交互，系统调用</em></li>
</ul>
<h5 id="563">5.6.3、为什么不通过系统调用的方式实现<a class="headerlink" href="#563" title="Permanent link">&para;</a></h5>
<ul>
<li>系统调用有好处（创建容易且使用方便，性能高），但有问题：</li>
<li>替代方法：（<em>不太懂</em>）
    + 实现一个设备节点，并对此实现<code>read()</code>和<code>write()</code>
        + 像信号量这样的某些接口
        + 把增加的信息作为一个文件放在sysfs的合适位置</li>
</ul>
<h4 id="57">5.7、小结<a class="headerlink" href="#57" title="Permanent link">&para;</a></h4>
<h3 id="chap6">chap6、内核数据结构<a class="headerlink" href="#chap6" title="Permanent link">&para;</a></h3>
<h4 id="61">6.1、链表<a class="headerlink" href="#61" title="Permanent link">&para;</a></h4>
<h5 id="0_3">0、<a class="headerlink" href="#0_3" title="Permanent link">&para;</a></h5>
<h5 id="611">6.1.1、单向链表和双向链表<a class="headerlink" href="#611" title="Permanent link">&para;</a></h5>
<h5 id="612">6.1.2、环形链表<a class="headerlink" href="#612" title="Permanent link">&para;</a></h5>
<h5 id="613">6.1.3、沿链表移动<a class="headerlink" href="#613" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>只能是线性移动</strong></li>
</ul>
<h5 id="614linux">6.1.4、Linux内核中的实现<a class="headerlink" href="#614linux" title="Permanent link">&para;</a></h5>
<ul>
<li>0、
    + <strong>linux内核，将链表节点塞入数据结构，不是将数据结构塞入链表</strong>。</li>
<li>1、链表数据结构
    + linux/list.h</li>
<li>2、定义一个链表</li>
<li>3、链表头</li>
</ul>
<h5 id="615">6.1.5、操作链表<a class="headerlink" href="#615" title="Permanent link">&para;</a></h5>
<ul>
<li>0、</li>
<li>1、向链表中增加一个节点
    + <code>list_add()</code></li>
<li>2、从链表中删除一个节点
    + <code>list_del()</code></li>
<li>3、移动和合并链表节点
    + <code>list_move()</code>
    + <code>list_move_tail()</code>
    + <code>list_empty()</code></li>
</ul>
<h5 id="616">6.1.6、遍历链表<a class="headerlink" href="#616" title="Permanent link">&para;</a></h5>
<ul>
<li>0、</li>
<li>1、</li>
<li>2、</li>
<li>3、反向遍历链表
    + <code>list_for_each_entry_reverse()</code> </li>
<li>4、遍历的同时删除
    + <code>list_for_each_entry_safe()</code></li>
<li>5、其它链表方法</li>
</ul>
<h4 id="62">6.2、队列<a class="headerlink" href="#62" title="Permanent link">&para;</a></h4>
<h5 id="0_4">0、<a class="headerlink" href="#0_4" title="Permanent link">&para;</a></h5>
<ul>
<li><code>linux/kfifo.h</code></li>
</ul>
<h5 id="621kfifo">6.2.1、kfifo<a class="headerlink" href="#621kfifo" title="Permanent link">&para;</a></h5>
<ul>
<li>kfifo对象维护了两个偏移量：入口偏移和出口偏移（<strong>下一次出队列时的位置</strong>）</li>
<li>enqueue</li>
<li>dequeue</li>
</ul>
<h5 id="622">6.2.2、创建队列<a class="headerlink" href="#622" title="Permanent link">&para;</a></h5>
<ul>
<li>动态创建<code>kfifo_alloc()</code></li>
<li>静态创建</li>
</ul>
<h5 id="623">6.2.3、推入队列数据<a class="headerlink" href="#623" title="Permanent link">&para;</a></h5>
<ul>
<li><code>kfifo_in()</code></li>
</ul>
<h5 id="624">6.2.4、摘取队列数据<a class="headerlink" href="#624" title="Permanent link">&para;</a></h5>
<ul>
<li><code>kfifo_out()</code></li>
</ul>
<h5 id="625">6.2.5、获取队列数据<a class="headerlink" href="#625" title="Permanent link">&para;</a></h5>
<ul>
<li><code>kfifo_size()</code></li>
</ul>
<h5 id="626">6.2.6、重置和撤销队列<a class="headerlink" href="#626" title="Permanent link">&para;</a></h5>
<ul>
<li><code>kfifo_reset()</code></li>
</ul>
<h5 id="627">6.2.7、队列使用举例<a class="headerlink" href="#627" title="Permanent link">&para;</a></h5>
<ul>
<li><em>未看，lionel</em></li>
</ul>
<h4 id="63">6.3、映射<a class="headerlink" href="#63" title="Permanent link">&para;</a></h4>
<h5 id="0_5">0、<a class="headerlink" href="#0_5" title="Permanent link">&para;</a></h5>
<h5 id="631idr">6.3.1、初始化一个idr<a class="headerlink" href="#631idr" title="Permanent link">&para;</a></h5>
<h5 id="632uid">6.3.2、分配一个新的UID<a class="headerlink" href="#632uid" title="Permanent link">&para;</a></h5>
<ul>
<li>第一步，告诉idr你需要分配新的UID，允许其在必要时调整后备树的大小</li>
<li>第二步，才是真正请求新的UID</li>
</ul>
<h5 id="633uid">6.3.3、查找UID<a class="headerlink" href="#633uid" title="Permanent link">&para;</a></h5>
<ul>
<li><code>idr_find</code></li>
</ul>
<h5 id="634uid">6.3.4、删除UID<a class="headerlink" href="#634uid" title="Permanent link">&para;</a></h5>
<ul>
<li><code>idr_move</code></li>
</ul>
<h5 id="635idr">6.3.5、撤销idr<a class="headerlink" href="#635idr" title="Permanent link">&para;</a></h5>
<ul>
<li><code>idr_destroy</code></li>
</ul>
<h4 id="64">6.4、二叉树<a class="headerlink" href="#64" title="Permanent link">&para;</a></h4>
<h5 id="641bst">6.4.1、二叉搜索树（BST）<a class="headerlink" href="#641bst" title="Permanent link">&para;</a></h5>
<h5 id="642">6.4.2、自平衡二叉搜索树<a class="headerlink" href="#642" title="Permanent link">&para;</a></h5>
<ul>
<li>1、红黑树</li>
<li>2、rbtree
    + linux/rbtree.h
    + lib/rbtree.c</li>
</ul>
<h4 id="65">6.5、数据结构以及选择<a class="headerlink" href="#65" title="Permanent link">&para;</a></h4>
<ul>
<li>遍历数据，就使用链表</li>
<li>如果需要存储大量数据，并且检索迅速，那么红黑树最好</li>
</ul>
<h4 id="66">6.6、算法复杂度<a class="headerlink" href="#66" title="Permanent link">&para;</a></h4>
<h5 id="661">6.6.1、算法<a class="headerlink" href="#661" title="Permanent link">&para;</a></h5>
<h5 id="662o">6.6.2、大O符号<a class="headerlink" href="#662o" title="Permanent link">&para;</a></h5>
<h5 id="663xita">6.6.3、大xita符号<a class="headerlink" href="#663xita" title="Permanent link">&para;</a></h5>
<h5 id="664">6.6.4、时间复杂度<a class="headerlink" href="#664" title="Permanent link">&para;</a></h5>
<h4 id="67">6.7、小结<a class="headerlink" href="#67" title="Permanent link">&para;</a></h4>
<h3 id="chap9">chap9、内核同步介绍<a class="headerlink" href="#chap9" title="Permanent link">&para;</a></h3>
<h4 id="91">9.1、临界区和竞争条件<a class="headerlink" href="#91" title="Permanent link">&para;</a></h4>
<h5 id="0_6">0、<a class="headerlink" href="#0_6" title="Permanent link">&para;</a></h5>
<ul>
<li>临界区</li>
<li>竞争条件race coditions</li>
</ul>
<h5 id="911">9.1.1、为什么我们需要保护<a class="headerlink" href="#911" title="Permanent link">&para;</a></h5>
<h5 id="912">9.1.2、单个变量<a class="headerlink" href="#912" title="Permanent link">&para;</a></h5>
<h4 id="92">9.2、加锁<a class="headerlink" href="#92" title="Permanent link">&para;</a></h4>
<h5 id="0_7">0、<a class="headerlink" href="#0_7" title="Permanent link">&para;</a></h5>
<ul>
<li><em>lionel，没太看懂啊</em></li>
</ul>
<h5 id="921">9.2.1、造成并发执行的原因<a class="headerlink" href="#921" title="Permanent link">&para;</a></h5>
<ul>
<li>内核中有类似可能造成并发执行的原因。它们是
    + 中断
    + 软中断和tasklet
    + 内核抢占
    + 睡眠及与用户空间的同步
    + 对称多处理</li>
</ul>
<h5 id="922">9.2.2、了解要保护些什么<a class="headerlink" href="#922" title="Permanent link">&para;</a></h5>
<h4 id="93">9.3、死锁<a class="headerlink" href="#93" title="Permanent link">&para;</a></h4>
<h4 id="94">9.4、争用和扩展性<a class="headerlink" href="#94" title="Permanent link">&para;</a></h4>
<h4 id="95">9.5、小结<a class="headerlink" href="#95" title="Permanent link">&para;</a></h4>
<h3 id="chap12">chap12、内存管理<a class="headerlink" href="#chap12" title="Permanent link">&para;</a></h3>
<h4 id="121">12.1、页<a class="headerlink" href="#121" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>MMU</strong>（是硬件），以页为单位进行处理。</li>
<li>大多数32位体系结构支持4KB的页，而64位体系结构一般会支持8KB的页。</li>
<li><code>struct page{};</code>，include/linux/mm.h</li>
<li><strong>page结构与物理页相关，而并非与虚拟页相关</strong>。</li>
</ul>
<h4 id="122">12.2、区<a class="headerlink" href="#122" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>内核把页划分为不同的区（zone）</strong>,Linux主要使用了四种区
    + ZONE_DMA
    + ZONE_DMA32
    + ZONE_NORMAL
    + ZONE_HGHEM</li>
<li><code>struct zone {};</code></li>
</ul>
<h4 id="123">12.3、获得页<a class="headerlink" href="#123" title="Permanent link">&para;</a></h4>
<h5 id="0_8">0、<a class="headerlink" href="#0_8" title="Permanent link">&para;</a></h5>
<ul>
<li><code>alloc_pages()</code></li>
<li><code>page_address()</code></li>
</ul>
<h5 id="12310">12.3.1、获得填充为0的页<a class="headerlink" href="#12310" title="Permanent link">&para;</a></h5>
<ul>
<li><code>get_zeroed_page()</code></li>
</ul>
<h5 id="1232">12.3.2、释放页<a class="headerlink" href="#1232" title="Permanent link">&para;</a></h5>
<ul>
<li><code>free_page()</code></li>
<li><strong>内核是完全相信自己的</strong></li>
</ul>
<h4 id="124kmalloc">12.4、kmalloc<a class="headerlink" href="#124kmalloc" title="Permanent link">&para;</a></h4>
<h5 id="0_9">0、<a class="headerlink" href="#0_9" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>以字节为单位，确保页在物理地址上是连续的</strong>，实现在include/linux/slab.h中</li>
</ul>
<h5 id="1241gfp_mask">12.4.1、gfp_mask标志<a class="headerlink" href="#1241gfp_mask" title="Permanent link">&para;</a></h5>
<ul>
<li>标志分为<strong>3种</strong></li>
<li>1、行为修饰符</li>
<li>2、区修饰符</li>
<li>3、类型标志</li>
</ul>
<h5 id="1242kfree">12.4.2、kfree<a class="headerlink" href="#1242kfree" title="Permanent link">&para;</a></h5>
<h4 id="125vmalloc">12.5、vmalloc<a class="headerlink" href="#125vmalloc" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>分配的内存虚拟地址是连续的，而物理地址无须连续</strong></li>
</ul>
<h4 id="126slab">12.6、slab层<a class="headerlink" href="#126slab" title="Permanent link">&para;</a></h4>
<h5 id="0_10">0、<a class="headerlink" href="#0_10" title="Permanent link">&para;</a></h5>
<h5 id="1261slab">12.6.1、slab层的设计<a class="headerlink" href="#1261slab" title="Permanent link">&para;</a></h5>
<h5 id="1262slab">12.6.2、slab分配器的接口<a class="headerlink" href="#1262slab" title="Permanent link">&para;</a></h5>
<ul>
<li><code>kmem_cache_create()</code></li>
</ul>
<h4 id="127">12.7、在栈上的静态分配<a class="headerlink" href="#127" title="Permanent link">&para;</a></h4>
<h5 id="0_11">0、<a class="headerlink" href="#0_11" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>32位和64位体系结构的页面大小分别是4KB和8KB，所以通常它们的内核栈的大小分别是8KB和16KB</strong>。</li>
</ul>
<h5 id="1271">12.7.1、单页内核栈<a class="headerlink" href="#1271" title="Permanent link">&para;</a></h5>
<h5 id="1272">12.7.2、在栈上光明正大地工作<a class="headerlink" href="#1272" title="Permanent link">&para;</a></h5>
<h4 id="128">12.8、高端内存的映射<a class="headerlink" href="#128" title="Permanent link">&para;</a></h4>
<h5 id="0_12">0、<a class="headerlink" href="#0_12" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>在高端内存中的页不能永久地映射到内核地址空间上</strong>。</li>
</ul>
<h5 id="1281">12.8.1、永久映射<a class="headerlink" href="#1281" title="Permanent link">&para;</a></h5>
<ul>
<li><code>kmap()</code></li>
</ul>
<h5 id="1282">12.8.2、临时映射<a class="headerlink" href="#1282" title="Permanent link">&para;</a></h5>
<ul>
<li><code>kmap_atomic()</code></li>
</ul>
<h4 id="129cpu">12.9、每个CPU的分配<a class="headerlink" href="#129cpu" title="Permanent link">&para;</a></h4>
<ul>
<li>每个CPU的数据存放在一个数组中。</li>
<li>内核抢占会引起下面提及的两个问题：
    + 如果你的代码被其他
    + 如果另一个</li>
</ul>
<h4 id="1210cpu">12.10、新的每个CPU接口<a class="headerlink" href="#1210cpu" title="Permanent link">&para;</a></h4>
<h5 id="0_13">0、<a class="headerlink" href="#0_13" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>percpu</strong>，简化了创建和操作每个CPU的数据。</li>
</ul>
<h5 id="12101cpu">12.10.1、编译时的每个CPU数据<a class="headerlink" href="#12101cpu" title="Permanent link">&para;</a></h5>
<h5 id="12102cpu">12.10.2、运行时的每个CPU数据<a class="headerlink" href="#12102cpu" title="Permanent link">&para;</a></h5>
<h4 id="1211cpu">12.11、使用每个CPU数据的原因<a class="headerlink" href="#1211cpu" title="Permanent link">&para;</a></h4>
<ul>
<li>首先，<strong>减少了数据锁定</strong></li>
<li>第二个好处，<strong>使用每个CPU数据可以大大减少缓存失效</strong></li>
</ul>
<h4 id="1212">12.12、分配函数的选择<a class="headerlink" href="#1212" title="Permanent link">&para;</a></h4>
<ul>
<li>连续的物理页：<strong>使用某个低级页分配器或kmalloc()</strong>
    + GFP_ATOMIC：进行不睡眠的高优先级分配
    + GFP_KERNEL：如果有必要，进程可以睡眠</li>
<li>不需要物理上连续的页，<strong>仅仅需要虚拟地址上连续的页</strong>，就使用vmalloc 【<strong>vmalloc相对kmalloc，有一定的性能损失</strong>】，把物理内存块映射到连续的逻辑地址空间上。</li>
<li>如果你想从高端内存进行分配，使用alloc_pages()。<strong>为了获得真正的指针，应该调用kmap()，把高端内存映射到内核的逻辑地址空间</strong>。</li>
<li>创建和撤销很多大的数据结构，考虑建立<strong>slab高速缓存</strong>。slab层会给每个处理器维持一个对象高速缓存（空闲链表），这种高速缓存会极大地提高对象分配和回收的性能。<strong>为你把事先分配好的对象存放到高速缓存中</strong></li>
</ul>
<h4 id="1213">12.13、小结<a class="headerlink" href="#1213" title="Permanent link">&para;</a></h4>
<ul>
<li>在内核中分配内存并非总是轻而易举，因为你必须小心地<strong>确保分配过程遵从内核特定的状态约束</strong>。</li>
<li><strong>分配内存相对复杂</strong>是内核开发和用户开发的最大区别之一。</li>
</ul>
<h3 id="chap13">chap13、<a class="headerlink" href="#chap13" title="Permanent link">&para;</a></h3>
<h4 id="131">13.1、通用文件系统接口<a class="headerlink" href="#131" title="Permanent link">&para;</a></h4>
<h4 id="132">13.2、文件系统抽象层<a class="headerlink" href="#132" title="Permanent link">&para;</a></h4>
<h4 id="133unix">13.3、Unix文件系统<a class="headerlink" href="#133unix" title="Permanent link">&para;</a></h4>
<ul>
<li>4种与文件系统相关的传统抽象概念<ul>
<li>文件：可以看作有序的字节串（unix把目录也看作文件）</li>
<li>目录项：路径中的每一部分称作<strong>目录条目</strong>，也叫<strong>目录项</strong></li>
<li>索引节点：文件信息按照索引形式存储在单独的块中，<strong>控制信息存储在超级块中</strong>。</li>
<li>安装点（mount point）</li>
</ul>
</li>
</ul>
<h4 id="134vfs">13.4、VFS对象及其数据结构<a class="headerlink" href="#134vfs" title="Permanent link">&para;</a></h4>
<ul>
<li>VFS采用<strong>面向对象</strong>的设计原理，不过是用C语言实现的</li>
<li>VFS中有四个主要的对象类型：（这里对象是指<strong>结构体</strong>）<ul>
<li>超级块对象：代表一个具体的已安装文件系统<ul>
<li>super_operations</li>
</ul>
</li>
<li>索引节点对象：代表一个具体文件<ul>
<li>inode_operations</li>
</ul>
</li>
<li>目录项对象：代表一个目录项，是路径的一个组成部分<ul>
<li>dentry_operations</li>
</ul>
</li>
<li>文件对象：代表由进程打开的文件<ul>
<li>file_operations</li>
</ul>
</li>
</ul>
</li>
<li>每个主要对象都包含一个<strong>操作对象</strong>，操作对象作为一个结构体指针来实现的</li>
</ul>
<h4 id="135">13.5、超级块对象<a class="headerlink" href="#135" title="Permanent link">&para;</a></h4>
<ul>
<li><code>struct super_block{};</code>这个定义在linux/fs.h</li>
<li><strong>创建、管理和撤销超级块对象</strong>代码位于fs/super.c</li>
</ul>
<h4 id="136">13.6、超级块操作<a class="headerlink" href="#136" title="Permanent link">&para;</a></h4>
<ul>
<li>最重要的一个域<code>s_op</code></li>
</ul>
<h4 id="137">13.7、索引节点对象<a class="headerlink" href="#137" title="Permanent link">&para;</a></h4>
<h4 id="138">13.8、索引节点操作<a class="headerlink" href="#138" title="Permanent link">&para;</a></h4>
<h4 id="139">13.9、目录项对象<a class="headerlink" href="#139" title="Permanent link">&para;</a></h4>
<h5 id="1391">13.9.1、目录项状态<a class="headerlink" href="#1391" title="Permanent link">&para;</a></h5>
<h5 id="1392">13.9.2、目录项缓存<a class="headerlink" href="#1392" title="Permanent link">&para;</a></h5>
<h4 id="1310">13.10、目录项操作<a class="headerlink" href="#1310" title="Permanent link">&para;</a></h4>
<h4 id="1311">13.11、文件对象<a class="headerlink" href="#1311" title="Permanent link">&para;</a></h4>
<h4 id="1312">13.12、文件操作<a class="headerlink" href="#1312" title="Permanent link">&para;</a></h4>
<h4 id="1313">13.13、和文件系统相关的数据结构<a class="headerlink" href="#1313" title="Permanent link">&para;</a></h4>
<h4 id="1314">13.14、和进程相关的数据结构<a class="headerlink" href="#1314" title="Permanent link">&para;</a></h4>
<h4 id="1315">13.15、小结<a class="headerlink" href="#1315" title="Permanent link">&para;</a></h4>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../12storage/ceph%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="btn btn-neutral float-left" title="《ceph设计原理与实现》"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/" class="btn btn-neutral float-right" title="《深入Linux设备驱动程序内核机制》">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../../12storage/ceph%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
