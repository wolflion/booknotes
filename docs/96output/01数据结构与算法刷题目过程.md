## 数据结构与算法刷题目过程

### 1、数据结构1：二维数组、线性表、栈、队列、哈希表

+ *对应的是一些基础题，没有啥明显算法的*
+ 具体数据结构就不在这展示了，**主要是使用STL的库**

#### 1.1、二维数组

#### 1.2、线性表

#### 1.3、栈

#### 1.4、队列

#### 1.5、哈希表

### 2、数据结构2：树

### 3、数据结构3：图

### 4、数据结构4：堆、优先级队列、并查集

+ 堆、优先级队列

#### 4.3、并查集

##### 4.3.1、思想&模板

+ 概念
+ 模板

##### 4.3.2、题目

+ OD
+ LC

##### 4.3.3、进阶（元素不是int型，怎么初始化father数组）

### 5、六大算法1：贪心

#### 5.1、思想

#### 5.2、组合问题中贪心

##### 5.2.1、题目

+ OD
  + 最少面试官数
+ LC

##### 5.2.2、坑&心得

+ 1、**读懂题意**（有时候题，出得不好，难get到）**找到贪心策略**，然后**自定义排序**即可

#### 5.3、图问题中的贪心（不会）

+ OD中出现过中dijkstra（我只是懂了dijkstra做选择或填空，写代码还不行）

### 6、六大算法2：动态规划

+ *还得再复习下*

#### 6.1、思想&入门题

##### 6.1.2、入门题：Fibonacci sequence

#### 6.2、一维dp

##### 6.2.1、题目

+ OD
  + 高效会议安排

+ LC
  + 

#### 6.3、二维dp

##### 6.3.1、题目

+ OD
  + 代表团坐车
    + *我还没完全懂呢*

### 7、六大算法3：回溯（DFS）

+ 回溯与DFS区别？
+ 除了背模板外，**真正的点，还在于如何去理解业务**，要在不同题目中去体会

#### 7.1、思想&入门题

##### 7.1.2、全排列

#### 7.2、图问题中的回溯：DFS

##### 7.2.1、邻接矩阵存储时的回溯，用的是递归（题目）

+ OD
  + 寻找最大价值矿堆
+ LC
  + 695
+ 模板
  + 1、初始化没有问题，**啥情况调用dfs，参数怎么组织** 
    + **用(x,y)一些是矩阵里的坐标**，层数就一个即可，*也是根据题目意思来*
    + *问题在于，这个调用层里，有没有业务逻辑要处理*
  + 2、dfs实现
    + 2.1、把矩阵的行、列大小取到，也可以是传值过来的
    + 2.2、用完后，用`vistited`标记一下
    + 2.3、在4个方向（根据题目意思）判断**不越界&&业务条件**，再调用dfs
      + 因为是递归，肯定要有变化的地方，**这时候，一般是x,y有变化**

```cpp
int dirs21[4][2] = { {1,0},{-1,0},{0,-1},{0,1} };

void dfs(vector<vector<int>>& input, int x, int y, int& island) {
	int row = input.size();
	int col = input[0].size();
	island += input[x][y];

	input[x][y] = 0; //修改一下，相当于visited[][]
	
	for (auto dir : dirs21) {
		int mx = x + dir[0];
		int my = y + dir[1];
		if (mx >= 0 && mx < row && my >= 0 && my < col && input[mx][my]) {
			dfs(input, mx, my, island);
		}
	}
}


void od_a21_impl(vector<vector<int>> &input) {
	int row = input.size();
	int col = input[0].size();

	int res = 0, island = 0;
	for (int i = 0; i < row; i++) {
		for (int j = 0; j < col; j++) {
			if (input[i][j]) {
				dfs(input, i, j, island);
				res = max(res, island);   //这一步，才是点睛之笔
				island = 0;
			}
		}
	}
	cout << res << endl;
}
```



### 8、六大算法4：分治

### 9、六大算法5：分支限界（BFS）

### 10、六大算法6：蛮力

### 11、杂散：KMP

#### 11.1、KMP

+ 除了**`getNext()`求next数组**是模板外，其它还是**业务**（看题目场景）

##### 11.1.1、思想

+ 靠B站[帮你把KMP算法学个通透！（理论篇）](https://www.bilibili.com/video/BV1PD4y1o7nd/?spm_id_from=333.337.search-card.all.click)，**代码随想录**入的门

##### 11.1.2、模板

+ 第1步，初始化：
  + i表示啥，**初始化为1**
  + j表示啥，
  + `next[0]`，怎么初始化
+ 第2步，不相等时，**用`while()`，因为不是一次回退**
+ 第3步，相等时，j++
+ 第4步，更新`next[i]`

```cpp
void getNext(int *next, string s) {
	next[0] = 0;
	int j = 0;
	for (int i = 1; i < s.size(); i++) {
		while (j > 0 && s[i] != s[j]) {  //这一步，要用while
			j = next[j - 1];
		}
		if (s[i] == s[j]) {  //lionel，next数组这个差不多了，这个地方写错了，把==写成了=
			j++;
		}
		next[i] = j;
	}
}
```



### 附录

#### 1、字符串操作

+ https://en.cppreference.com/w/c/string/byte
  + *现在cppreference里这个有点多*，主要是针对这个

+ 因为我在`strstr()`的参数上没写对，所以**想把这个当作基础内容**

##### 1.1、字符数组与字符串

##### 1.2、常用字符串操作

+ 1、初始化
+ 2、获取长度，*两者区别*
  + strlen()
  + sizeof()
+ 3、

+ strstr()