## 《Linux内核源码剖析-TCP/IP实现》（下）

+ 2.6.20代码
+ https://lxr.missinglinkelectronics.com/
+ 下册（20-33章）

### chap20、路由缓存  1（10/529）

+ 缓存的主要工作是存储使路由子系统能够找到报文目的地的信息，并通过一组函数向更高层提供该信息。

+ 路由缓存涉及到的文件
  + include/net/route.h，定义目的路由缓存项
  + include/net/flow.h，定义查询路由缓存的条件组合结构、宏和函数原型等
  + include/net/dst.h，定义目的路由缓存项的部分结构、宏、函数等
  + net/ipv4/route.c，实现路由缓存项的操作函数

#### 20.1、系统参数

+ 系统参数（有11个）
  + flush，控制路由缓存的刷新

#### 20.2、路由缓存的组织结构

+ 路由缓存是用一张**散列表**来实现的，路由缓存散列表的类型是**rt_hash_bucket结构**，该结构只包含**指向缓存元素链表的一个指针**。缓存项的类型为rtable结构

##### 20.2.1、rtable结构

+ 查看`/proc/net/rt_cache`文件，或者通过`ip route list cache`和`route -C`来列出路由缓存的内容

##### 20.2.2、flowi结构

+ 根据诸如输入网络设备和输出网络设备、三层和四层协议报头中的参数等字段的组合对流量进行分类。

##### 20.2.3、dst_entry结构

+ dst_entry结构被用于存储缓存路由项中独立于协议的信息。

##### 20.2.4、dst_ops结构

+ dst_ops结构是使用路由缓存的三层协议与独立于协议的缓存之间的接口

#### 20.3、初始化

+ 由`ip_rt_init()`进行初始化的   11（20/529）

#### 20.4、创建路由缓存项

20.5、添加路由表项到缓存中

20.6、输入路由缓存查询

20.7、输出路由缓存查询

20.7.1、ip_route_output_key()

#### 20.8、垃圾回收

#### 20.9、刷新缓存

##### 1.3.1、TSO/GSO

##### 1.3.2、I/O AT

##### 1.4.1、slab分配器

##### 20.9.7、通过写/proc的flush文件

#### 20.10、ICMP重定向消息的处理

#### 20.11、ICMP目的不可达，需要分片

### chap21、路由策略

+ *感觉目录，是从上层往下层的，lionel*

2.1、引言

2.2、协议简介

2.3、网络架构

2.4、系统调用接口

2.5、协议无关接口

#### 21.6、路由策略的查找

### chap22、套接口层  56（65/529）

+ 套接口是啥
  + 1983年，4.2BSD引入
  + **通用的网络应用程序编程接口**
+ 套接口包含啥？
  + *本书好像没讲？*

+ 套接口层的作用
  + **为应用程序提供了一个访问网络和进程间通信的**通用接口
  + 位于**应用程序和协议栈**之间
  + 对应用程序屏蔽了与协议相关实现的具体细节，将应用程序发送的与协议无关的请求映射到与协议相关的实现
+ 套接口层怎么与其上下层衔接
  + 应用程序中调用库函数，而库函数通过系统调用进入套接口层
  + Linux套接口层实现提供了一组**专门的套接口系统调用**
  + **图22-1**（套接口层将一般的请求转换为指定的协议操作）
+ 套接口的I/O操作以及套接口选项（23，24两章介绍的）
+ 涉及文件
  + include/linux/net.h，定义套接口层相关的结构、宏和函数原型
  + include/net/sock.h，定义基本的传输控制块结构、宏和函数原型
  + net/socket.c，实现套接口层的调用
  + net/ipv4/af_inet.c，网络层和传输层接口

#### 22.1、socket结构

+ `struct socket{};`

#### 22.2、proto_ops结构

+ 是一组与套接口系统调用相对应的传输层函数指针，可以看作是**一张套接口系统调用到传输层函数的跳转表**
+ 完成的是**从与协议无关的套接口层到协议相关的传输层**的转接，proto结构又将**传输层映射到网络层**，那么可想而知**每个传输层的协议都需要定义一个特定的proto_ops结构实例和proto结构实例**。

#### 22.3、套接口文件系统

##### 22.3.1、套接口文件系统类型

+ sockfs文件系统类型`sock_fs_type`，通过`get_sb()`和`alloc_inode()`和`destroy_inode()`分配和释放与套接口文件相关的i结点
+ 通过`/proc/filesystem`文件查看操作系统支持的文件系统

##### 22.3.2、套接口文件系统超级块操作接口

##### 22.3.3、套接口文件的inode

+ `struct socket_alloc{};`由socket结构和inode结构两部分组成

##### 22.3.4、sock_alloc_inode()

##### 3.2.5、sock_destroy_inode()

#### 22.4、套接口文件

+ 创建套接口文件时，使file结构中的f_op指向了`socket_file_ops`，**通过socket_file_ops可以看到套接口文件支持哪些系统调用**

##### 22.4.1、套接口文件与套接口的绑定

+ 1、sock_map_fd()
+ 2、sock_attach_fd()

##### 22.4.2、根据文件描述符获取套接口

+ 1、sockfd_lookup_light()
+ 2、sock_from_file()

#### 22.5、进程、文件描述符和套接口

+ 在task_struct结构中，files指向file_struct结构，该结构的主要功能是管理fd_array指针数组指向的描述符，每个file结构描述一个打开的文件

#### 22.6、套接口层的系统初始化

+ `sock_init()`

#### 22.7、套接口系统调用

+ 理解proto_ops结构和proto结构的差异和调用层次

##### 22.7.1、套接口系统调用入口

+ **表22-5**，套接口系统调用

##### 22.7.2、socket系统调用

+ 1、sys_socket()
+ 2、

##### 22.7.3、bind系统调用

+ 1、sys_bind()

##### 22.7.4、listen系统调用

##### 22.7.5、accept系统调用

##### 22.7.6、connect系统调用

##### 22.7.7、shutdown系统调用

+ 1、sys_shutdown
+ 2、套接口层的实现

##### 22.7.8、close系统调用

+ 1、关闭套接口
+ 2、套接口层的实现

##### 22.7.9、select系统调用的实现

### chap23、套接口I/O

+ 套接口I/O涉及的文件
  + include/linux/socket.h，定义套接口的结构、宏和函数原型
  + net/core/iovec.c，实现对I/O向量块的复制操作
  + net/socket.c，实现套接口层的调用

#### 23.1、输出/输入数据的组织

##### 23.1.1、msghdr结构

+ `struct msghdr{};`

##### 23.1.2、verify_iovec()

+ 发送和接收的数据的msghdr结构需要在用户态组织，**而在内核中是不信任用户态的数据的**，因此需要对用户态提供的msghdr结构进行校难。

##### 23.1.3、

23.1.4、

23.1.5、

##### 23.1.6、csum_partial_copy_fromiovecend()

#### 23.2、输出系统调用

##### 23.2.1、sock_sendmsg()

##### 23.2.2、sendto系统调用

##### 23.2.3、send系统调用

##### 23.2.4、sendmsg系统调用

#### 23.3、输入系统调用

+ 图23-3，recvmsg系统调用过程

#### 23.4、网络设备处理层初始化

### chap24、套接口选项  99（108/529）

+ 套接口选项的实现涉及的文件
  + net/socket.c，实现套接口层的调用
  + net/ipv4/af_inet.c，网络层和传输层接口

#### 24.1、setsockopt系统调用

#### 24.2、ioctl系统调用

##### 24.2.1、ioctl在文件系统内的调用过程

##### 24.2.2、套接口文件ioctl调用接口的实现

##### 24.2.3、套接口层的实现

#### 24.3、getsockname系统调用

#### 24.4、getpeername系统调用

### chap25、传输控制块  111（120/529）

#### 5.4、网络设备的注销

##### 5.4.1、设备注销的时机

+ 两种情形
  + 1、卸载网络设备驱动程序
  + 2、移除热插拔网络设备

##### 5.4.2、网络设备注销过程

+ 1、unregister_netdevice()
+ 2、衔接操作：netdev_run_todo()

#### 5.5、网络设备的启用

+ `dev_open()`，发送一个**NETDEV_UP消息**到网络设备状态改变通知链上

#### 5.6、网络设备的禁用

+ `dev_close()`

#### 5.7、与电池管理交互

##### 5.7.1、挂起设备

+ `e100_suspend()`

##### 5.7.2、唤醒设

### chap6、IP编址

+ [rfc790](https://datatracker.ietf.org/doc/html/rfc790)，提到了a,b,c类地址

#### 6.1、接口和IP地址

##### 6.1.1、主IP地址，从属IP地址和IP别名

##### 6.1.2、IP地址的组织

##### 6.1.3、in_device结构

+ **IP配置块**（网络适配层和IPv4相关的配置），通过ifconfig修改

##### 6.1.4、in_ifaddr结构

+ **IP地址块**（存储主机的IP地址，子网掩码，广播地址），**这些配置属于主机，但又是配置到网络设备上**

#### 6.2、函数

##### 6.2.1、

##### 6.2.7、inet_ifa_byprefix()

##### 6.2.8、inet_abc_len()

#### 6.3、IP地址的设置

+ *我的疑问是，netlink和ioctl的区别是啥？*

##### 6.3.1、netlink接口

+ 0、
  + iproute2包，需要单独装，*至少有些版本上是*
+ 1、netlink消息结构
  + 对应[rfc3549](https://datatracker.ietf.org/doc/html/rfc3549)
+ 2、
+ 3、

##### 6.3.3、

#### 6.4、ioctl

#### 6.5、inetaddr_chain通知链

### chap7、接口层的输入

+ *我的问题是，怎么理解 接口层*（我大概想了一下，可能是那种5层结构的那种接口层，用于承上启下的）

#### 7.1、系统参数

#### 7.2、接口层的ioctl

7.2.1、SIOCxIFxxx类命令

### chap8、接口层的输出

#### 8.1、输出接口

8.1.1、dev_queue_xmit()

8.1.2、dev_hard_start_xmit()

##### 8.1.3、e100的输出接口：e100_xmit_frame()

8.2、网络输出软中断

8.2.1、netif_schedule()

8.2.2、net_tx_action()

### chap9、流量控制

#### 9.1、通过流量控制后输出

9.1.1、dev_queue_xmit()

9.1.2、qdisc_restart()

9.2、构成流量控制的三种元素

9.2.1、排队规则

9.2.2、类

9.2.3、过滤器

9.3、默认的FIFO排队规则

9.3.1、pfifo_fast_init()

9.3.2、pfifo_fast_reset()

9.3.1、pfifo_fast_enqueue()

9.3.1、pfifo_fast_dequeue()

9.3.1、pfifo_fast_requeue()

9.4、netlink的tc接口

9.5、排队规则的创建接口

9.5.1、类的创建接口

9.5.2、过滤器的创建接口

### chap10、Internet协议族

+ 支持32种协议族，`net_families[NPROTO];`
+ include/linux/net.h，套接口层的结构、宏和函数原型
+ include/linux/protocol.h，注册传输层协议的结构、宏和函数原型
+ net/ipv4/af_inet.c，网络层和传输层接口
+ net/ipv4/ip_input.c，IP数据报的输入

#### 10.1、net_proto_family结构

+ net_proto_family屏蔽了（不同的协议族，传输层结构和实现的差异，各自套接口创建函数也有差异）差异，统一用`sock_register()`注册到net_families数组中，**提供了协议族到套接口创建**之前的接口

#### 10.2、inet_protosw结构

+ **只在套接口层起作用**
+ inetsw_array数组包含了三个inet_protosw结构的实例：**TCP，UDP和原始套接口**

#### 10.3、net_protocol结构

+ 定义了协议族中支持的传输层协议以及传输层的报文接收例程。是**网络层和传输层之间的桥梁**。

#### 10.4、Internet协议族的初始化

+ 初始化函数是`inet_init()`，通过fs_initcall(inet_init)，将inet_init加到内核的初始化列表中，保证了此函数会在系统启动时被调用

### chap11、IP：网际协议

#### 11.1、引言

##### 11.1.1、IP首部

+ 计算一份数据报IP检验和的方法
  + 首先把检验和字段置为0
  + 然后将整个首部看成由一串16位字组成，对其中的每个16位进行二进制反码求和，结果存在检验和字段中

##### 11.1.2、IP数据报的输入与输出

+ 图11-3，**IP层主要函数调用关系**

#### 11.2、IP的私有信息控制块

11.3、系统参数

11.4、初始化

11.5、IP层套接口选项

11.6、ipv4_devconf结构

11.7、套接口的错误队列

11.8、报文控制信息

11.9、对端信息块

11.10、IP数据报的输入处理

11.11、IP数据报的输出处理

11.12、IP层对GSO的支持

### chap12、IP选项处理

+ 0、
  + 自己看了RFC791，里面的**IP选项**的介绍能对得上12.1，但是**实现**不确定从哪来的
  + [rfc1122](https://datatracker.ietf.org/doc/html/rfc1122#page-35)，跟rfc791差不多，只不过人家实现了多种场景，（link layer，ip层、传输层）
+ 提到了2个rfc，rfc791，rfc1122

#### 12.1、IP选项

##### 12.1.1、选项列表的结束符，End of Option List

##### 12.1.9、

+ 我没在rfc791上看到，**作者让看rfc2113**

#### 12.2、ip_options结构

#### 12.3、在IP数据报中构建IP选项

+ `ip_options_build()`

#### 12.4、复制IP数据报中选项到指定的ip_options结构

#### 12.5、处理待发送IP分片中的选项

+ **复制标志**为0的给清理掉，*但我没找到相关字段？*

#### 12.6、解析IP选项

#### 12.7、还原在检验IP选项时修改的IP选项

#### 12.8、处理转发IP数据报中的IP选项

#### 12.9、处理IP数据报的源路由选项

#### 12.10、解析并处理IP首部中的IP选项

#### 12.11、路由警告选项的处理

#### 12.12、由控制信息生成IP选项信息块

### chap13、IP的分片与组装

+ **UDP很容易导致分片**

+ **分片**是**IP层和二层之间**的传输单元，分片对传输层是透明的

#### 13.1、系统参数

#### 13.2、分片

+ *两种分片在rfc791里没有提到，只是给了个分片过程，具体的实现，还是内核侧提供的，函数的话，还是看他们*

##### 13.2.1、快速分片

##### 13.2.2、慢速分片

13.3、组装

13.3.1、ipq结构

13.3.2、ipq散列表和链表的维护

13.3.3、ipq散列表的重组

13.3.4、

13.3.5、

13.3.6、

13.3.7、

### chap14、ICMP：Internet控制报文协议

#### 14.1、ICMP报文结构

14.2、注册ICMP报文类型

14.3、系统参数

14.4、ICMP的初始化

14.5、输入处理

14.5.1、

14.5.2、

14.5.3、

14.5.4、

14.5.5、

14.6、输出处理

14.6.1、发送ICMP报文

14.6.2、发送回显应答和时间戳应答报文

### chap15、IP组播

15.1、初始化

15.2、虚拟接口

15.3、组播转发缓存

15.4、临时组播转发缓存

15.5、外部事件

15.6、组播套接口选项

15.7、组播选路套接口选项

15.8、组播的ioctl

15.9、组播报文的输入

15.10、组播报文的转发

15.11、组播报文的输出