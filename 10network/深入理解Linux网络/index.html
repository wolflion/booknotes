<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>《深入理解Linux网络》 - lionel的技术笔记</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u300a\u6df1\u5165\u7406\u89e3Linux\u7f51\u7edc\u300b";
        var mkdocs_page_input_path = "10network\\\u6df1\u5165\u7406\u89e3Linux\u7f51\u7edc.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> lionel的技术笔记
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../01daily/">daily</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../02ds/">ds</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../03cpp/">cpp</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../21tool/">tool</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">C++</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/effectiveC%2B%2B/">《Effective C++》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">《深度探索C++对象模型》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/EffectiveSTL/">《Effective STL》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/C%2B%2B%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/">《C++泛型STL原理和应用》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">《STL源码剖析》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../22C%2B%2Bmodern/%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8C%2B%2B11/">《深入应用C++11》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">基础知识</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">《操作系统导论》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">《大话设计模式》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90_C%2B%2B4th/">《数据结构与算法分析_C++4th》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E7%AE%97%E6%B3%95%284th%29/">《算法4th》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%BC%A0%E5%86%9B/">《算法设计与分析-张军》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E5%A4%A9%E8%A1%8C-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《天行-算法设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B-%E6%9D%8E%E6%98%A5%E8%91%86/">《数据结构教程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%96%B0%E7%BC%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E4%B8%8E%E8%A7%A3%E6%9E%90/">《新编数据结构习题与解析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网络编程</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../TCPIP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">《TCP/IP网络编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">《Linux高性能服务器编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71/">《TCPIP详解卷1》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90/">《Linux内核网络栈源代码情景分析》</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">《深入理解Linux网络》</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#chap1">chap1、绪论</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#11">1.1、我在工作中的困惑</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#115127001">1.1.5、访问127.0.0.1过网卡吗？</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#116">1.1.6、软中断和硬中断</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#117">1.1.7、零拷贝到底是怎么回事</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#118dpdk">1.1.8、DPDK</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#12">1.2、本书内容结构</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#13">1.3、一些约定</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#14">1.4、一些术语</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap2">chap2、内核是如何接收网络包的</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#21">2.1、相关实际问题</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#22">2.2、数据是如何从网卡到协议栈的</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#221linux">2.2.1、Linux网络收包总览</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#222linux">2.2.2、Linux启动</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#223">2.2.3、迎接数据的到来</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#224">2.2.4、收包小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#23">2.3、本章小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap3">chap3、内核是如何与用户进程协作的</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#31">3.1、相关实际问题</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#32socket">3.2、socket的直接创建</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#33">3.3、内核和用户进程协作之阻塞方式</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#331">3.3.1、等待接收消息</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#332">3.3.2、软中断模块</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#333">3.3.3、同步阻塞总结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#34epoll">3.4、内核和用户进程协作之epoll</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#341epoll">3.4.1、epoll内核对象的创建</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#342epollsocket">3.4.2、为epoll添加socket</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#343epoll_wait">3.4.3、epoll_wait之等待接收</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#344">3.4.4、数据来了</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#345">3.4.5、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#35">3.5、本章总结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap4">chap4、内核是如何发送网络包的</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#42">4.2、网络包发送过程总览</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#43">4.3、网卡启动准备</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#44">4.4、数据从用户进程到网卡的详细过程</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#441send">4.4.1、send系统调用实现</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#442">4.4.2、传输层处理</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#443">4.4.3、网络层发送处理</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#444">4.4.4、邻居子系统</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#445">4.4.5、网络设备子系统</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#446">4.4.6、软中断调度</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#447igb">4.4.7、igb网卡驱动发送</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#45ringbuffer">4.5、RingBuffer内存回收</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#46">4.6、本章总结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap5io">chap5、深度理解本机网络IO</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#51">5.1、相关实际问题</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#52">5.2、跨机网络通信过程</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#521chap4">5.2.1、跨机数据发送（chap4介绍了）</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#522">5.2.2、跨机数据接收</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#523">5.2.3、跨机网络通信汇总</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#53">5.3、本机发送过程</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#531">5.3.1、网络层路由</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#532ip">5.3.2、本机IP路由</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#533">5.3.3、网络设备子系统</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#534">5.3.4、“驱动”程序</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#54">5.4、本机接收过程</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#55">5.5、本章总结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap6tcp">chap6、深度理解TCP连接建立过程</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#62listen">6.2、深入理解listen</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#621listen">6.2.1、listen系统调用</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#622listen">6.2.2、协议栈listen</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#623">6.2.3、接收队列定义</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#624">6.2.4、接收队列申请和初始化</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#625">6.2.5、半连接队列长度计算</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#626listen">6.2.6、listen过程小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#63connect">6.3、深入理解connect</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#631connect">6.3.1、connect调用链展开</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#632">6.3.2、选择可用端口</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#633">6.3.3、端口被使用过怎么办</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#634syn">6.3.4、发起syn请求</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#635connect">6.3.5、connect小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#64tcp">6.4、完整TCP连接建立过程</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#641connect">6.4.1、客户端connect</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#642syn">6.4.2、服务端响应SYN</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#643synack">6.4.3、客户端响应SYNACK</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#644ack">6.4.4、服务端响应ACK</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#645accept">6.4.5、服务端accept</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#646">6.4.6、连接建立过程总结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#65tcp">6.5、异常TCP连接建立情况</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#651connect">6.5.1、connect系统调用耗时失控</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#652">6.5.2、第一次握手丢包</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#653">6.5.3、第三次握手丢包</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#654">6.5.4、握手异常总结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#66">6.6、如何查看是否有连接队列溢出发生</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#661">6.6.1、全连接队列溢出判断</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#662">6.6.2、半连接队列溢出判断</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#67">6.7、本章总结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap7tcp">chap7、一条TCP连接消耗多大内存</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#71">7.1、相关实际问题</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#74tcp">7.4、实测TCP内核对象开销</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#75">7.5、本章小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap8tcp">chap8、一台机器最多能支持多少条TCP连接</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#82linux">8.2、理解Linux最大文件描述符</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#83tcp">8.3、一台服务端机器最多可以支撑多少条TCP连接</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#8465535">8.4、一台客户端机器最多只能发起65535条连接吗</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#85">8.5、单机百万并发连接的动手实验</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap9">chap9、网络性能优化建议</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap10">chap10、容器网络虚拟化</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#102veth">10.2、veth设备对</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">机器&深度学习</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../30machineLearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/">《机器学习线性代数基础》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../31deepLearning/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%9A%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《深度学习入门：基于Python的理论与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">文件系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/Linux%E5%86%85%E6%A0%B8%E6%8E%A2%E7%A7%98/">《Linux内核探秘》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《文件系统技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">《存储技术原理分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">存储</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../12storage/ceph%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《ceph设计原理与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">视频</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/FFmpeg%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">《FFmpeg入门到精通》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">《WebRTC权威指南》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AE%9E%E6%97%B6%E4%BA%92%E5%8A%A8%E6%8A%80%E6%9C%AF/">《WebRTC音视频实时互动技术》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/%E6%96%B0%E4%B8%80%E4%BB%A3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%A0%81%E6%A0%87%E5%87%86-H.264_AVC/">《新一代视频压缩码标准-H.264_AVC》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">内核</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《Linux内核设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/">《深入Linux设备驱动程序内核机制》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">《深入理解Linux虚拟内存管理》</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../13kernel/深入理解Linux网络技术内幕.md">《深入理解Linux网络技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../13kernel/Linux内核源代码剖析-tcpip实现.md">《Linux内核源代码剖析-TCP/IP实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/">《深入理解Linux内核》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">工具</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/">《Wireshark网络分析实战》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%283rd%29/">《Linux命令行与shell脚本编程大全(3rd)》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%883rd%EF%BC%89/">《python程序设计（3rd）》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/python/Python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/">《Python编程从入门到实践》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">刷题</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../91leetcode/%E5%89%91%E6%8C%87offer2nd/">《剑指offer2nd》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../91leetcode/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/">《剑指offer专项突破》</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../96output/OD基础题.md">OD基础题</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../96output/OD进阶题.md">OD进阶题</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网课</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/01Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/">《Linux高并发网络编程开发》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/%E4%BE%AF%E6%8D%B7/%E4%BE%AF%E6%8D%B7C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8660%E8%AE%B2/">《侯捷C++内存管理60讲》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/11NJU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">《NJU算法设计与分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">英语专</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../60English/00794%E7%BB%BC%E5%90%88%E8%8B%B1%E8%AF%AD%E4%B8%80%E4%B8%8A/">《综合英语(一)上》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../95selfStudy/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/">《概率率与数理统计》</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">lionel的技术笔记</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>网络编程 &raquo;</li>
      <li>《深入理解Linux网络》</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h2 id="linux">《深入理解Linux网络》<a class="headerlink" href="#linux" title="Permanent link">&para;</a></h2>
<ul>
<li>核心4.4，<strong>从用户进程到网卡的详细过程</strong></li>
</ul>
<h3 id="chap1">chap1、绪论<a class="headerlink" href="#chap1" title="Permanent link">&para;</a></h3>
<h4 id="11">1.1、我在工作中的困惑<a class="headerlink" href="#11" title="Permanent link">&para;</a></h4>
<h5 id="115127001">1.1.5、访问127.0.0.1过网卡吗？<a class="headerlink" href="#115127001" title="Permanent link">&para;</a></h5>
<h5 id="116">1.1.6、软中断和硬中断<a class="headerlink" href="#116" title="Permanent link">&para;</a></h5>
<h5 id="117">1.1.7、零拷贝到底是怎么回事<a class="headerlink" href="#117" title="Permanent link">&para;</a></h5>
<h5 id="118dpdk">1.1.8、DPDK<a class="headerlink" href="#118dpdk" title="Permanent link">&para;</a></h5>
<h4 id="12">1.2、本书内容结构<a class="headerlink" href="#12" title="Permanent link">&para;</a></h4>
<h4 id="13">1.3、一些约定<a class="headerlink" href="#13" title="Permanent link">&para;</a></h4>
<ul>
<li>内核3.10版本</li>
</ul>
<h4 id="14">1.4、一些术语<a class="headerlink" href="#14" title="Permanent link">&para;</a></h4>
<ul>
<li>hi：CPU开销中<strong>硬中断消耗的部分</strong></li>
<li>si：CPU开销中<strong>软中断消耗的部分</strong></li>
<li>NAPI：2.5内核引入的一种高效网卡数据处理的技术</li>
</ul>
<h3 id="chap2">chap2、内核是如何接收网络包的<a class="headerlink" href="#chap2" title="Permanent link">&para;</a></h3>
<h4 id="21">2.1、相关实际问题<a class="headerlink" href="#21" title="Permanent link">&para;</a></h4>
<ul>
<li>1、RingBuffer是什么，RingBuffer为什么会丢包？</li>
<li>2、网络相关的硬中断、软中断都是什么？</li>
<li>5、tcpdump是如何工作的？</li>
<li>6、iptable/netfilter是在哪一层实现的？</li>
<li>8、网络接收过程中的CPU开销如何查看？</li>
</ul>
<h4 id="22">2.2、数据是如何从网卡到协议栈的<a class="headerlink" href="#22" title="Permanent link">&para;</a></h4>
<ul>
<li><code>read()</code>的系统调用</li>
</ul>
<h5 id="221linux">2.2.1、Linux网络收包总览<a class="headerlink" href="#221linux" title="Permanent link">&para;</a></h5>
<ul>
<li>网络分层</li>
<li>linux内核中，网络设备驱动在<code>driver/net/ethernet</code>，目前下有个intel，表明<strong>intel系列网卡</strong>，协议栈模块位于<strong>kernel和net目录下</strong></li>
<li>内核和网络设备驱动是<strong>通过中断的方式</strong>来处理的，给CPU的相关引脚触发一个电压变化，中断函数分为<strong>上半部分，下半部分</strong>（上半部分，只进行最简单的工作，<strong>快速处理然后释放CPU</strong>，下半部，慢慢处理），<strong>2.4以后，下半部实现方式是软中断ksoftirqd内核线程</strong>（软中断是通过<strong>给内存中的一个变量赋予二进制值以标记有软中断发生</strong>）</li>
</ul>
<ul>
<li>图2.2<strong>内核收包路径</strong><ul>
<li>1、</li>
<li>2、网卡把帧DMA到内存</li>
<li>3、硬中断通知CPU</li>
<li>4、</li>
<li>5、</li>
<li>6、</li>
<li>7、协议层开始处理网络帧，处理完后的数据data被放到socket的接收队列中</li>
<li>8、内核唤醒用户进程</li>
</ul>
</li>
</ul>
<h5 id="222linux">2.2.2、Linux启动<a class="headerlink" href="#222linux" title="Permanent link">&para;</a></h5>
<h6 id="ksoftirqd">创建ksoftirqd内核线程<a class="headerlink" href="#ksoftirqd" title="Permanent link">&para;</a></h6>
<ul>
<li><strong>线程数量，取决于你机器的核数</strong></li>
<li>系统初始化的时候在kernel/smpboot.c中调用了<strong>smpboot_register_percpu_thread</strong>，该函数进一步执行<strong>spawn_ksoftirqd</strong>（kernel/softirq.c）来创建出softirqd线程</li>
<li>ksoftirqd被创建出来后，它就会进入自己的线程循环函数<strong>ksoftirqd_should_run</strong>和<strong>run_ksoftirqd</strong>了</li>
<li>include/linux/interrupt.h中<strong>定义了软中断</strong>（不仅仅只有网络）</li>
</ul>
<h6 id="_1">网络子系统初始化<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h6>
<ul>
<li><code>subsys_initcall()</code>来初始化各个子系统</li>
<li>为每个CPU都申请一个softnet_data数据结构，这个数据结构里的poll_list用于等待驱动程序将其poll函数注册进来</li>
<li><strong>open_softirq为每一种软中断都注册一个处理函数</strong>。<ul>
<li>kernel/softirq.c</li>
</ul>
</li>
</ul>
<h6 id="_2">协议栈注册<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h6>
<ul>
<li>对应的实现函数分别是ip_rcv()，tcp_v4_rcv()和udp_rcv()。</li>
<li><strong>内核是通过注册的方式来实现的</strong>。</li>
<li>fs_initcall调用inet_init后开始网络协议栈注册，通过inet_init，将这些函数注册到inet_protos和ptype_base数据结构中。</li>
<li><strong>inet_protos记录着UDP、TCP的处理函数地址，ptype_base存储着ip_rcv()函数的处理地址</strong></li>
</ul>
<h6 id="_3">网卡驱动初始化<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h6>
<ul>
<li>每一个驱动程序，会使用<code>module_init()</code>向内核注册一个初始化函数，<strong>当驱动程序被加载时，内核会调用这个函数</strong>。<ul>
<li>igb网卡的驱动程序代码位于drivers/net/ethernet/intel/igb/igb_main.c中</li>
</ul>
</li>
<li>驱动的pci_register_driver调用完成后，Linux内核就知道了该驱动的相关信息，<strong>比如igb网卡驱动的igb_driver_name和igb_rpobe函数地址，等等</strong></li>
<li>驱动的probe方法执行的目的<strong>就是让设备处于ready状态</strong></li>
</ul>
<h6 id="_4">启动网卡<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h6>
<ul>
<li><code>struct net_device_ops</code>变量</li>
<li>当启用一个网卡时（ifconfig eth0 up），<strong>net_device_ops变量中定义的ndo_open方法会被调用</strong>。</li>
<li>创建队列</li>
</ul>
<h5 id="223">2.2.3、迎接数据的到来<a class="headerlink" href="#223" title="Permanent link">&para;</a></h5>
<h6 id="_5">硬中断处理<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h6>
<h6 id="ksoftirqd_1">ksoftirqd内核线程处理中断<a class="headerlink" href="#ksoftirqd_1" title="Permanent link">&para;</a></h6>
<h6 id="_6">网络协议栈处理<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h6>
<h6 id="ip">IP层处理<a class="headerlink" href="#ip" title="Permanent link">&para;</a></h6>
<ul>
<li>主入口是<strong>ip_rcv</strong>，net/ipv4/ip_input.c，里面的<strong>NF_HOOK()</strong>，其<strong>最后一个参数是ip_rcv_finish()</strong><ul>
<li><em>想深入研究netfilter可以从搜索NF_HOOK的这些引用处入手，lionel，作者的建议</em></li>
</ul>
</li>
</ul>
<h5 id="224">2.2.4、收包小结<a class="headerlink" href="#224" title="Permanent link">&para;</a></h5>
<ul>
<li>收包之前的工作<ul>
<li>1、创建ksoftirqd线程</li>
<li>2、协议栈注册，每个协议都会将自己的处理函数注册一下</li>
<li>3、网卡驱动初始化，把自己的DMA准备好，把NAPI的poll函数地址告诉内核</li>
<li>4、启动网卡，分配RX，TX队列，注册中断对应的处理函数</li>
</ul>
</li>
<li>数据到来的工作<ul>
<li>1、网卡将数据帧DMA到内存的RingBuffer中，然后向CPU发起中断通知</li>
</ul>
</li>
</ul>
<h4 id="23">2.3、本章小结<a class="headerlink" href="#23" title="Permanent link">&para;</a></h4>
<h3 id="chap3">chap3、内核是如何与用户进程协作的<a class="headerlink" href="#chap3" title="Permanent link">&para;</a></h3>
<h4 id="31">3.1、相关实际问题<a class="headerlink" href="#31" title="Permanent link">&para;</a></h4>
<ul>
<li>1、阻塞到底是怎么一回事？</li>
<li>2、同步阻塞IO都需要哪些开销？</li>
<li>3、多路复用epoll为什么就能提高网络性能？</li>
<li>4、epoll也是阻塞的？</li>
<li>5、为什么Redis的网络性能很突出？</li>
</ul>
<h4 id="32socket">3.2、socket的直接创建<a class="headerlink" href="#32socket" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>socket是如何在内核中表示的。</p>
<ul>
<li><strong>内核在内部创建了一系列socket相关的内核对象</strong></li>
<li>net/socket.c中的<code>sock_create()</code>，又调用af_inet.c中的<code>inet_create()</code><ul>
<li>中间先是调用<code>__sock_create()</code>，然后先分配<code>sock_alloc()</code>，调用创建<code>create()</code>，<strong>对于AF_INET协议族来说，调用的是<code>inet_create</code></strong>，其它协议族来说，不一定就这个了</li>
</ul>
</li>
<li>inet_create中，<strong>根据类型SOCK_STREAM</strong>查找到对于TCP定义的操作方法实现集合inet_stream_ops和tcp_prot，并把它们分别<strong>设置到socket-&gt;ops和sock-&gt;sk_prot上</strong></li>
</ul>
<ul>
<li>net/core/sock.c，<code>sock_init_data()</code>，<strong>将sock中的sk_data_ready函数指针进行了初始化，设置为默认sock_def_readable</strong></li>
</ul>
</li>
</ul>
<ul>
<li><strong>当软中断上收到数据包时会通过调用sk_data_ready函数指针（实际被设置成了sock_def_readable()）来唤醒在sock上等待的进程</strong>。</li>
</ul>
<h4 id="33">3.3、内核和用户进程协作之阻塞方式<a class="headerlink" href="#33" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>图3.4，同步阻塞工作流程</strong><ul>
<li>1、创建socket（用户进程）</li>
<li>2、等待接收（等待队列）</li>
<li>3、数据包抵达网卡</li>
<li>4、网卡把帧DMA到内存</li>
<li>5、硬中断通知CPU</li>
<li>6、处理完发出软中断</li>
<li>7、从RingBuffer上摘下数据包</li>
<li>8、收到socket的接收队列中</li>
<li>9、唤醒等待队列上的进程（ksoftirqd内核线程）</li>
</ul>
</li>
</ul>
<h5 id="331">3.3.1、等待接收消息<a class="headerlink" href="#331" title="Permanent link">&para;</a></h5>
<ul>
<li>recv依赖的底层实现</li>
</ul>
<ul>
<li><strong>strace命令跟踪</strong>，clib库函数recv会执行recvfrom系统调用</li>
<li><strong>图3-5，recvfrom系统调用</strong><ul>
<li>1、系统调用recvfrom</li>
<li>2、inet_stream_ops</li>
<li>3、tcp_prot</li>
<li>4、接收队列里数据为空</li>
<li>5、修改当前进程状态</li>
<li>6、主动让出CPU（Linux将调度下一个进程）</li>
</ul>
</li>
<li><strong>recvfrom最后是怎么把自己的进程阻塞掉的</strong><ul>
<li>net/socket.c中的<code>sock_recvmsg()-&gt;__sock_recvmsg()-&gt;__sock_recvmsg_nosec()</code></li>
<li>net/ipv4/af_inet.c</li>
<li>net/ipv4/tcp.c</li>
<li>net/core/sock.c</li>
</ul>
</li>
<li><strong>sk_wait_data是怎样把当前进程给阻塞掉的</strong><ul>
<li>1、定义等待队列并关联current，include/linux/wait.h</li>
<li>2、获取socket等待队列头</li>
<li>3、插入</li>
<li>4、修改当前进程状态</li>
<li>首先在宏</li>
<li>紧接着，</li>
<li>接着调用prepare_to_wait来把新定义的等待队列wait插入sock对象的等待队列，kernel/wait.c</li>
<li>后面当内核收完数据产生就绪事件的时候，就可以查找socket等待队列上的等待项，进而可以找到回调函数和在等待该socket就绪事件的进程了</li>
<li>最后调用sk_wait_event让出CPU，进程将进入睡眠状态，<strong>这会导致一次进程上下文的开销</strong>，而这个开销是昂贵的，大约需要消耗几个微秒的CPU时间</li>
</ul>
</li>
</ul>
<h5 id="332">3.3.2、软中断模块<a class="headerlink" href="#332" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>负责接收和处理数据包</strong>的软中断<ul>
<li>网络包到网卡后怎么被网卡接收，最后再交由<strong>软中断处理的</strong></li>
<li><strong>tcp协议的接收函数<code>tcp_v4_rcv()</code></strong></li>
</ul>
</li>
</ul>
<ul>
<li><strong>图3.9</strong>软中断接收数据过程<ul>
<li>1、</li>
<li>2、</li>
<li>3、唤醒等待队列上的进程</li>
</ul>
</li>
<li>kernel/sched/core.c</li>
<li>软中断（<strong>也就是linux中的ksoftirqd线程</strong>）里收到数据包以后，发现是TCP包就会执行tcp_v4_rcv函数。接着往下，如果是ESTABLISH状态下的数据包，则最终会把数据拆出来放到对应socket的接收队列中，然后调用sk_data_ready来唤醒用户进程。<ul>
<li>net/ipv4/tcp_ipv4.c中的<code>tcp_v4_rcv()</code>，根据收到的网络包的header里的source和dest信息在本机上查询对应的socket。找到了后，直接进入接收的主体函数<code>tcp_v4_do_rcv()</code>，<strong>假设是处理ESTABLISH状态下的包</strong>，就又进入<code>tcp_rcv_established()</code>，再通过调用<code>tcp_queue_rcv()</code>，完成了将接收到的数据放到socket的接收队列上</li>
<li>net/ipv4/tcp_input.c，里的了<code>tcp_queue_rcv()</code></li>
<li><strong>调用tcp_queue_rcv接收完成之后，接着调用sk_data_ready来唤醒在socket上等待的用户进程</strong>。</li>
<li>lionel，没写呢</li>
<li><strong>在socket上等待而被阻塞的进程就被推入可运行队列里了，这又将产生一次进程上下文切换的开销</strong></li>
</ul>
</li>
</ul>
<h5 id="333">3.3.3、同步阻塞总结<a class="headerlink" href="#333" title="Permanent link">&para;</a></h5>
<ul>
<li>同步阻塞方式接收网络包的整个过程分两步：<ul>
<li>1、我们自己代码的代码所在的进程，调用<code>socket()</code>会进入内核态创建必要的内核对象</li>
<li>2、硬中断、软中断上下文（系统线程ksoftirqd）</li>
</ul>
</li>
<li><strong>进程3.12</strong>，同步阻塞流程汇总</li>
</ul>
<h4 id="34epoll">3.4、内核和用户进程协作之epoll<a class="headerlink" href="#34epoll" title="Permanent link">&para;</a></h4>
<h5 id="341epoll">3.4.1、epoll内核对象的创建<a class="headerlink" href="#341epoll" title="Permanent link">&para;</a></h5>
<ul>
<li>fs/eventpoll.c中的<code>epoll_create</code>，里面有<code>struct eventpoll{}</code>的定义，<code>ep_alloc()</code>会进行初始化</li>
</ul>
<h5 id="342epollsocket">3.4.2、为epoll添加socket<a class="headerlink" href="#342epollsocket" title="Permanent link">&para;</a></h5>
<ul>
<li>fs/eventpoll.c中的<code>epoll_ctl</code>，</li>
</ul>
<h5 id="343epoll_wait">3.4.3、epoll_wait之等待接收<a class="headerlink" href="#343epoll_wait" title="Permanent link">&para;</a></h5>
<ul>
<li>fs/eventpoll.c中的<code>epoll_wait</code>，</li>
</ul>
<h5 id="344">3.4.4、数据来了<a class="headerlink" href="#344" title="Permanent link">&para;</a></h5>
<ul>
<li>net/ipv4/tcp_ipv4.c中的<code>tcp_v4_rcv()</code></li>
<li>net/ipv4/tcp_input.c中的<code>tcp_rcv_established()</code></li>
<li>net/core/sock.c中的<code>sock_def_readable()</code></li>
</ul>
<h5 id="345">3.4.5、小结<a class="headerlink" href="#345" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>图3.26，epoll原理汇总</strong></li>
</ul>
<h4 id="35">3.5、本章总结<a class="headerlink" href="#35" title="Permanent link">&para;</a></h4>
<h3 id="chap4">chap4、内核是如何发送网络包的<a class="headerlink" href="#chap4" title="Permanent link">&para;</a></h3>
<ul>
<li><em>自己想复习的是</em><ul>
<li>用户进程到网卡的过程，<em>差不多在chap5，又复习了一下了</em></li>
</ul>
</li>
</ul>
<p>4.1、相关实际问题</p>
<h4 id="42">4.2、网络包发送过程总览<a class="headerlink" href="#42" title="Permanent link">&para;</a></h4>
<ul>
<li>server端口的（read,  send）调用，<strong>调用send之后内核是怎样把数据包发送出去的</strong></li>
<li>Linux源码最重要是要有整体上的把握，<strong>而不是一开始就陷入各种细节</strong></li>
</ul>
<ul>
<li>图4-1，<strong>网络发送过程概览</strong><ul>
<li>1、调用系统调用发送，send</li>
<li>2、内存拷贝</li>
<li>3、协议处理</li>
<li>4、进入驱动RingBuffer</li>
<li>5、实际发送</li>
<li>6、中断通知发送完成</li>
<li>7、清理RingBuffer</li>
</ul>
</li>
<li>图4-2，<strong>网络发送过程</strong></li>
<li>图4-3，<strong>发送完毕清理</strong></li>
<li><strong>硬中断最终触发的软中断却是NET_RX_SOFTIRQ，而不是NET_TX_SOFTIRQ</strong></li>
</ul>
<h4 id="43">4.3、网卡启动准备<a class="headerlink" href="#43" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>网卡支持多队列，第一个队列都是由一个RingBuffer表示的</strong></li>
<li>网卡在启动时最重要的任务之一就是<strong>分配和初始化RingBuffer</strong></li>
</ul>
<ul>
<li>drivers/net/ethernet/intel/igb/igb_main.c中的<code>__igb_open()</code><ul>
<li><strong>真正的RingBuffer构造过程是在<code>igb_setup_tx_resources()</code>中完成的</strong></li>
</ul>
</li>
<li>一个传输RingBuffer的内部也不仅仅是一个环形队列数组：<ul>
<li>igb_tx_buffer数组，这个数组是内核使用的，通过vzalloc申请</li>
<li>e1000_adv_tx_desc数组，这个数组是网卡硬件使用的，通过dma_alloc_coherent分配</li>
</ul>
</li>
</ul>
<h4 id="44">4.4、数据从用户进程到网卡的详细过程<a class="headerlink" href="#44" title="Permanent link">&para;</a></h4>
<h5 id="441send">4.4.1、send系统调用实现<a class="headerlink" href="#441send" title="Permanent link">&para;</a></h5>
<ul>
<li>sendto系统调用，net/socket.c中，<strong>内部真正使用的是sendto系统调用</strong></li>
<li>主要干了2件事情<ul>
<li>1、在内核中把真正的socket找出来，这个里面记录了各种协议栈的函数地址</li>
<li>2、构造一个struct msghdr对象，把用户传入的数据，都装进去</li>
</ul>
</li>
<li>到了，协议栈的<code>inet_sendmsg()</code></li>
</ul>
<h5 id="442">4.4.2、传输层处理<a class="headerlink" href="#442" title="Permanent link">&para;</a></h5>
<h6 id="_7">传输层拷贝<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h6>
<ul>
<li>对于tcp协议来说，那就是net/ipv4/af_inet.c中的<code>tcp_sendmsg()</code></li>
<li><strong>只有满足forced_push(tp)或者skb==tcp_send_head(sk)成立时</strong>，内核才会真正启动发送数据包<ul>
<li><strong>如果条件不满足，这次用户要发送的数据只是拷贝到内核就算完事了</strong></li>
</ul>
</li>
</ul>
<h6 id="_8">传输层发送<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h6>
<ul>
<li>net/ipv4/tcp_output.c中的<code>tcp_write_xmit()</code></li>
<li>图4-10，<strong>传输层发送流程</strong><ul>
<li>1、循环获取待发送skb</li>
<li>2、滑动窗口管理</li>
<li>3、克隆skb</li>
<li>4、设置TCP头</li>
</ul>
</li>
</ul>
<h5 id="443">4.4.3、网络层发送处理<a class="headerlink" href="#443" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>内核层的发送的实现们于net/ipv4/ip_output.c</strong></li>
</ul>
<ul>
<li>net/ipv4/ip_output.c中的<code>ip_queue_xmit()</code></li>
<li><strong>在网络层主要处理路由项查找、IP头设置、netfilter过滤、skb切分（大于MTU的话）</strong></li>
</ul>
<h5 id="444">4.4.4、邻居子系统<a class="headerlink" href="#444" title="Permanent link">&para;</a></h5>
<ul>
<li>位于<strong>网络层和数据链路层中间</strong>，作用是<strong>为网络层提供一个下层的封装，让网络层不必关心下层的地址信息，让下层来决定发送到哪个MAC地址</strong>。</li>
<li>代码位于<strong>net/core/neighbour.c</strong></li>
<li>主要是<strong>查找或者创建邻居项</strong><ul>
<li><strong>创建邻居项</strong>的时候，有可能会发出实际的arp请求</li>
</ul>
</li>
<li>图4-16，<strong>邻居子系统</strong></li>
</ul>
<h5 id="445">4.4.5、网络设备子系统<a class="headerlink" href="#445" title="Permanent link">&para;</a></h5>
<ul>
<li>图4.17，<strong>网络设备子系统</strong><ul>
<li>1、选择发送队列（根据XPS或自动选择）</li>
<li>2、获取排队规则</li>
</ul>
</li>
</ul>
<h5 id="446">4.4.6、软中断调度<a class="headerlink" href="#446" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>软中断</strong>是由内核进程来运行的，该进程会进入net_tx_action函数，在该函数中能获取发送队列，并也最终调用到驱动程序里的入口函数<code>dev_hard_start_xmit()</code></li>
<li>net/core/dev.c</li>
</ul>
<h5 id="447igb">4.4.7、igb网卡驱动发送<a class="headerlink" href="#447igb" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>网络设备子系统中的dev_hard_start_xmit()</strong>，会调用到驱动里的发送函数<code>igb_xmit_frame()</code></li>
</ul>
<h4 id="45ringbuffer">4.5、RingBuffer内存回收<a class="headerlink" href="#45ringbuffer" title="Permanent link">&para;</a></h4>
<ul>
<li><code>igb_poll()</code>，调用<code>igb_clean_tx_irq()</code><ul>
<li>主要干了啥呢，<strong>清理了skb，解除DMA映射</strong>，只有等对方收到ACK后<strong>才会删除skb</strong></li>
</ul>
</li>
</ul>
<h4 id="46">4.6、本章总结<a class="headerlink" href="#46" title="Permanent link">&para;</a></h4>
<ul>
<li>Q5、为什么Kafka的网络性能很突出？<ul>
<li><strong>采用的是sendfile系统调用来发送网络数据包</strong>（所谓的零拷贝），减少了内核态和用户态之间的频繁数据拷贝</li>
</ul>
</li>
</ul>
<h3 id="chap5io">chap5、深度理解本机网络IO<a class="headerlink" href="#chap5io" title="Permanent link">&para;</a></h3>
<ul>
<li><em>换成更通俗的问法</em>：【本机网络IO，<strong>无非就是的收发都在本机的情况</strong>】<ul>
<li>1、复习一下跨机网络通信</li>
<li>2、本机发送</li>
<li>3、本机接收</li>
</ul>
</li>
<li><em>RingBuffer不是很熟</em></li>
</ul>
<h4 id="51">5.1、相关实际问题<a class="headerlink" href="#51" title="Permanent link">&para;</a></h4>
<ul>
<li>LNMP中的nginx和php-fpm进程，就是通过本机来通信的</li>
<li>微服务中的sidecar模式，也是本机网络IO</li>
<li>问题<ul>
<li>1、127.0.0.1本机网络IO需要经过网卡吗？ <strong>不需要网卡</strong>【但为啥呢？走的是<strong>虚拟的环回设备lo</strong>】</li>
<li>2、数据包在内核中是什么走向，和外网发送相比流程上有什么差别？  <strong>节约了驱动上的一些开销</strong></li>
<li>3、访问本机服务时，使用127.0.0.1能比使用本机IP（如192.168.1.1）更快吗？<strong>一样的</strong>【但为啥呢？走的是<strong>虚拟的环回设备lo</strong>】</li>
</ul>
</li>
</ul>
<h4 id="52">5.2、跨机网络通信过程<a class="headerlink" href="#52" title="Permanent link">&para;</a></h4>
<h5 id="521chap4">5.2.1、跨机数据发送（chap4介绍了）<a class="headerlink" href="#521chap4" title="Permanent link">&para;</a></h5>
<ul>
<li>数据发送流程<ul>
<li>一、用户态（send，1、调用系统调用发送）</li>
<li>二、内核态（send系统调用，2、内存拷贝）<ul>
<li>skb，3、协议处理  4、进入驱动RingBuffer</li>
<li><strong>传输队列</strong></li>
<li>7、收到中断后，清理RingBuffer</li>
</ul>
</li>
<li>三、PCI总线，5、实际发送，<strong>6、中断通知CPU，发送完成</strong> </li>
</ul>
</li>
<li><strong>5-2数据发送源码</strong><ul>
<li>一、应用层，main中的send()</li>
<li>二、系统调用，net/socket.c中的<code>SYSCALL_DEFINE6(sendto)</code>，<code>__sock_sendmsg_nosec(){}</code>中的<code>sock_sendmsg{sock-&gt;ops-&gt;sendmsg()}</code></li>
<li>三、协议栈，net/ipv4/af_inet.c中的<code>inet_sendmsg(){sk-&gt;sk_port-&gt;sendmsg()}</code><ul>
<li>协议栈，传输层，net/ipv4/tcp.c中的<code>tcp_sendmsg()</code></li>
<li>协议栈，传输层，net/ipv4/tcp_output.c中的<code>tcp_transmit_skb()</code>中的<code>icsk-&gt;icsk_af_ops-&gt;queue_xmit()</code></li>
<li>协议栈，网络层，net/ipv4/ip_output.c中的<code>ip_queue_xmit()</code></li>
<li>协议栈，网络层，net/ipv4/ip_output.c中的<code>ip_finish_output2()</code></li>
</ul>
</li>
<li>三、邻居子系统，include/net/dst.h中的<code>dst_neigh_outpu()</code><ul>
<li>邻居子系统，include/net/neighbour.h中的<code>neigh_hh_output()</code></li>
</ul>
</li>
<li>四、网络设备子系统，net/core/dev.c中的<code>dev_queue_xmit()</code><ul>
<li>网络设备子系统，net/core/dev.c中的<code>dev_hard_start_xmit()</code></li>
</ul>
</li>
<li>五、驱动程序，drivers/net/ethernet/intel/igb/igb_main.c中的<code>igb_xmit_frame()</code>，以及<code>igb_xmit_frame_ring()</code></li>
<li>六、硬件</li>
</ul>
</li>
<li><strong>图5.3，RingBuffer清理</strong><ul>
<li>一、硬件</li>
<li>二、硬中断，drivers/net/ethernet/intel/igb/igb_main.c中的<code>igb_msix_ring()</code><ul>
<li><code>__napi_schedule()</code>再调用</li>
</ul>
</li>
<li>三、软中断，net/core/dev.c中的<code>net_rx_action(){work = n-&gt;poll()}</code></li>
<li>四、驱动，drivers/net/ethernet/intel/igb/igb_main.c中的<code>igb_poll()</code><ul>
<li>驱动，<code>igb_clean_tx_irq()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="522">5.2.2、跨机数据接收<a class="headerlink" href="#522" title="Permanent link">&para;</a></h5>
<ul>
<li>接收过程<ul>
<li>一、网卡，1、数据帧从外部网络到达网卡<ul>
<li>3、<strong>给CPU一个中断</strong>，硬中断通知给CPU</li>
<li>4、CPU响应中断，简单处理后，发出软中断</li>
<li>5、<strong>ksoftirqd线程处理软中断</strong>，调用网卡驱动注册的poll函数开始收包，<strong>进入内核态</strong></li>
</ul>
</li>
<li>二、PCIe总线，2、网卡把帧DMA到内存</li>
<li>三、内核态，6、帧被从RingBuffer上摘下来保存为一个skb</li>
<li>四、用户态，7、协议层开始处理网络帧，处理后的数据放到socket的接收队列中</li>
<li>8、<strong>内核唤醒用户进程</strong>（<em>这个流程上，在图上没看懂啊</em>，跟CPU有啥关系？）</li>
</ul>
</li>
<li>数据接收源码<ul>
<li>一、硬件</li>
<li>二、软中断，drivers/net/ethernet/intel/igb/igb_main.c中的<ul>
<li>net/core/dev.c中的<code>__napi_schedule()</code></li>
</ul>
</li>
<li>三、软中断，net/core/dev.c中的<code>net_rx_action()</code><ul>
<li>软中断，驱动，drivers/net/ethernet/intel/igb/igb_main.c中的<code>igb_poll()</code></li>
<li>软中断，驱动，net/core/dev.c中的<code>deliver_skb()</code></li>
</ul>
</li>
<li>四、协议栈，IP层，ipv4/ip_input.c中的<code>ip_rcv</code><ul>
<li>协议栈，传输层，net/ipv4/tcp_ipv4.c中的<code>tcp_v4_rcv()</code></li>
<li>协议栈，传输层，net/ipv4/tcp_ipv4.c中的<code>tcp_rcv_established(){tcp_queue_rcv(); sk-&gt;sk_data_ready()}</code></li>
</ul>
</li>
<li>五、用户进程，main中的<code>recvfrom(fd,buff,BUFFSIZE)</code></li>
</ul>
</li>
</ul>
<h5 id="523">5.2.3、跨机网络通信汇总<a class="headerlink" href="#523" title="Permanent link">&para;</a></h5>
<ul>
<li>send<ul>
<li>系统调用</li>
<li>协议栈（传输层、网络层）</li>
<li>邻居子系统</li>
<li>网络设备子系统</li>
<li>驱动程序</li>
<li>网卡</li>
</ul>
</li>
<li>recvfrom<ul>
<li>进程调度</li>
<li>协议栈（传输层、网络层）</li>
<li>网络设备子系统</li>
<li>驱动程序</li>
<li>软中断</li>
<li>硬中断</li>
<li>网卡</li>
</ul>
</li>
</ul>
<h4 id="53">5.3、本机发送过程<a class="headerlink" href="#53" title="Permanent link">&para;</a></h4>
<h5 id="531">5.3.1、网络层路由<a class="headerlink" href="#531" title="Permanent link">&para;</a></h5>
<ul>
<li>网络层入口函数是<code>ip_queue_xmit()</code>，net/ipv4/ip_output.c</li>
<li><strong>对于本机网络IO来说，在local路由表中就能找到路由项，对应的设备都将使用loopback网卡，也就是lo设备</strong></li>
<li>一、网络层工作流程<ul>
<li>1、ip_queue_xmit<ul>
<li>ip_route_output_ports，查找并设置路由项</li>
<li>设置IP头</li>
</ul>
</li>
<li>2、ip_local_out<ul>
<li>netfilter过滤统计工作</li>
</ul>
</li>
<li>3、ip_finish_output<ul>
<li>大于MTU的话要分片</li>
</ul>
</li>
</ul>
</li>
<li>二、邻居子系统，<code>dst_neigh_output()</code></li>
</ul>
<h5 id="532ip">5.3.2、本机IP路由<a class="headerlink" href="#532ip" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>选用哪个设备是路由相关函数<code>__ip_route_output_key()</code>确定的</strong></li>
<li><strong>设置本机IP的时候，调用<code>fib_inetaddr_event()</code>函数完成设置的</strong></li>
</ul>
<h5 id="533">5.3.3、网络设备子系统<a class="headerlink" href="#533" title="Permanent link">&para;</a></h5>
<ul>
<li>网络设备子系统的入口函数是<code>dev_queue_xmit()</code>，net/core/dev.c</li>
<li>一、邻居子系统</li>
<li>二、网络设备子系统<ul>
<li>dev_queue_xmit()，<strong>选择队列skb入队出队并发送</strong></li>
<li>dev_hard_start_xmit()</li>
</ul>
</li>
<li>三、驱动程序<ul>
<li>igb_xmit_frame<ul>
<li>1、获取可用缓存区，并关联skb</li>
<li>2、dma_map_single构造内存映射</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="534">5.3.4、“驱动”程序<a class="headerlink" href="#534" title="Permanent link">&para;</a></h5>
<ul>
<li>对于真实的igb网卡来说，它的驱动代码都在drivers/net/ethernet/intel/igb/igb_main.c文件中</li>
<li>drivers/net/loopback.c<ul>
<li><code>loopback_xmit()</code><ul>
<li>1、剥离skb</li>
<li>2、加入input_pkt_queue</li>
<li>3、触发软中断</li>
</ul>
</li>
</ul>
</li>
<li>net/core/dev.c<ul>
<li><code>__napi_schedule()</code></li>
</ul>
</li>
</ul>
<h4 id="54">5.4、本机接收过程<a class="headerlink" href="#54" title="Permanent link">&para;</a></h4>
<ul>
<li>软中断处理函数<code>net_rx_action()</code></li>
<li>一、软中断，net_rx_action，<strong>调用驱动提供的poll函数</strong></li>
<li>二、驱动程序，process_backlog，<strong>使用新链表</strong><ul>
<li>process_queue，<code>skb</code>的队列</li>
</ul>
</li>
</ul>
<h4 id="55">5.5、本章总结<a class="headerlink" href="#55" title="Permanent link">&para;</a></h4>
<ul>
<li><em>自己想的</em><ul>
<li>细节是<strong>中断</strong>，这个怎么理解呢？<ul>
<li>网卡收到数据了，<strong>给CPU一个硬中断</strong>，然后<strong>CPU简单处理后，发出软中断</strong></li>
<li><em>这里的，软中断、硬中断</em>，怎么理解？</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="chap6tcp">chap6、深度理解TCP连接建立过程<a class="headerlink" href="#chap6tcp" title="Permanent link">&para;</a></h3>
<h4 id="62listen">6.2、深入理解listen<a class="headerlink" href="#62listen" title="Permanent link">&para;</a></h4>
<h5 id="621listen">6.2.1、listen系统调用<a class="headerlink" href="#621listen" title="Permanent link">&para;</a></h5>
<ul>
<li>net/sock.c中的<code>listen</code></li>
<li><strong>用户态socket_fd只是一个整数而已，内核没有办法直接用</strong>，要先查找socket内核对象<code>sock = sockfd_lookup_light(fd,&amp;err,&amp;fput_needed);</code></li>
<li><em>入参的backlog是啥意思？</em></li>
<li><code>err = sock-&gt;ops-&gt;listen(sock, backlog);</code></li>
</ul>
<h5 id="622listen">6.2.2、协议栈listen<a class="headerlink" href="#622listen" title="Permanent link">&para;</a></h5>
<ul>
<li>net/ipv4/af_inet.c中的<code>inet_listen()</code></li>
<li><strong>服务端的全连接队列长度</strong>，执行listen函数时传入的backlog和net.core.somaxconn之间较小的那个值。<ul>
<li>啥叫<em>全连接？相对于谁的全？</em></li>
</ul>
</li>
<li>net/ipv4/inet_connection_sock.c中的<code>inet_csk_listen_start()</code></li>
</ul>
<h5 id="623">6.2.3、接收队列定义<a class="headerlink" href="#623" title="Permanent link">&para;</a></h5>
<ul>
<li>include/net/inet_connection_sock.h</li>
<li>include/net/request_sock.h中的<code>struct request_sock_queue{};</code></li>
<li><strong>全连接队列</strong>，不需要进行复杂的查找工作，accept处理时只要先进先出即可，<strong>以链表的方式管理</strong></li>
<li><strong>半连接队列</strong>，<code>listen_opt</code>，<strong>需要在第三次握手时快速地查找出第一次握手时留存的request_sock对象</strong>，所以需要用<strong>哈希表管理</strong></li>
</ul>
<h5 id="624">6.2.4、接收队列申请和初始化<a class="headerlink" href="#624" title="Permanent link">&para;</a></h5>
<ul>
<li>net/ipv4/inet_connection_sock.c中的<code>inet_csk_listen_start()</code></li>
</ul>
<h5 id="625">6.2.5、半连接队列长度计算<a class="headerlink" href="#625" title="Permanent link">&para;</a></h5>
<ul>
<li>net/core/request_sock.c</li>
</ul>
<h5 id="626listen">6.2.6、listen过程小结<a class="headerlink" href="#626listen" title="Permanent link">&para;</a></h5>
<ul>
<li>listen最主要的工作，<strong>申请和初始化接收队列，包括全连接队列和半连接队列</strong><ul>
<li>全连接队列，是个<strong>链表</strong></li>
<li>半连接队列，是个<strong>哈希表</strong></li>
</ul>
</li>
</ul>
<h4 id="63connect">6.3、深入理解connect<a class="headerlink" href="#63connect" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>图6.4 socket数据结构</strong></li>
</ul>
<h5 id="631connect">6.3.1、connect调用链展开<a class="headerlink" href="#631connect" title="Permanent link">&para;</a></h5>
<ul>
<li>net/sock.c中的<code>connect</code></li>
<li>ipv4/af_inet.c中的<code>inet_stream_connect()</code></li>
<li>net/ipv4/tcp_ipv4.c中的<code>tcp_v4_connect()</code></li>
</ul>
<h5 id="632">6.3.2、选择可用端口<a class="headerlink" href="#632" title="Permanent link">&para;</a></h5>
<ul>
<li>net/ipv4/inet_hashtables.c中的<code>inet_hash_connect()</code></li>
</ul>
<h5 id="633">6.3.3、端口被使用过怎么办<a class="headerlink" href="#633" title="Permanent link">&para;</a></h5>
<ul>
<li></li>
</ul>
<h5 id="634syn">6.3.4、发起syn请求<a class="headerlink" href="#634syn" title="Permanent link">&para;</a></h5>
<ul>
<li>net/ipv4/tcp_output.c中的<code>tcp_connect()</code>，根据入参sk中的信息，构建一个完美的syn报文，并将它发送出去</li>
</ul>
<h5 id="635connect">6.3.5、connect小结<a class="headerlink" href="#635connect" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>客户端在执行connect函数的时候，把本地socket状态设置成了TCP_SYN_SENT，选了一个可用的端口，接着发出SYN握手请求并启动重传定时器</strong>。</li>
</ul>
<h4 id="64tcp">6.4、完整TCP连接建立过程<a class="headerlink" href="#64tcp" title="Permanent link">&para;</a></h4>
<h5 id="641connect">6.4.1、客户端connect<a class="headerlink" href="#641connect" title="Permanent link">&para;</a></h5>
<h5 id="642syn">6.4.2、服务端响应SYN<a class="headerlink" href="#642syn" title="Permanent link">&para;</a></h5>
<h5 id="643synack">6.4.3、客户端响应SYNACK<a class="headerlink" href="#643synack" title="Permanent link">&para;</a></h5>
<h5 id="644ack">6.4.4、服务端响应ACK<a class="headerlink" href="#644ack" title="Permanent link">&para;</a></h5>
<h5 id="645accept">6.4.5、服务端accept<a class="headerlink" href="#645accept" title="Permanent link">&para;</a></h5>
<ul>
<li>net/ipv4/inet_connection_sock.c中的<code>inet_csk_accept()</code></li>
</ul>
<h5 id="646">6.4.6、连接建立过程总结<a class="headerlink" href="#646" title="Permanent link">&para;</a></h5>
<h4 id="65tcp">6.5、异常TCP连接建立情况<a class="headerlink" href="#65tcp" title="Permanent link">&para;</a></h4>
<h5 id="651connect">6.5.1、connect系统调用耗时失控<a class="headerlink" href="#651connect" title="Permanent link">&para;</a></h5>
<h5 id="652">6.5.2、第一次握手丢包<a class="headerlink" href="#652" title="Permanent link">&para;</a></h5>
<h5 id="653">6.5.3、第三次握手丢包<a class="headerlink" href="#653" title="Permanent link">&para;</a></h5>
<h5 id="654">6.5.4、握手异常总结<a class="headerlink" href="#654" title="Permanent link">&para;</a></h5>
<h4 id="66">6.6、如何查看是否有连接队列溢出发生<a class="headerlink" href="#66" title="Permanent link">&para;</a></h4>
<h5 id="661">6.6.1、全连接队列溢出判断<a class="headerlink" href="#661" title="Permanent link">&para;</a></h5>
<h5 id="662">6.6.2、半连接队列溢出判断<a class="headerlink" href="#662" title="Permanent link">&para;</a></h5>
<h4 id="67">6.7、本章总结<a class="headerlink" href="#67" title="Permanent link">&para;</a></h4>
<h3 id="chap7tcp">chap7、一条TCP连接消耗多大内存<a class="headerlink" href="#chap7tcp" title="Permanent link">&para;</a></h3>
<h4 id="71">7.1、相关实际问题<a class="headerlink" href="#71" title="Permanent link">&para;</a></h4>
<p>7.2、Linux内核如何管理内存</p>
<p>7.3、TCP连接相关内核对象</p>
<h4 id="74tcp">7.4、实测TCP内核对象开销<a class="headerlink" href="#74tcp" title="Permanent link">&para;</a></h4>
<h4 id="75">7.5、本章小结<a class="headerlink" href="#75" title="Permanent link">&para;</a></h4>
<h3 id="chap8tcp">chap8、一台机器最多能支持多少条TCP连接<a class="headerlink" href="#chap8tcp" title="Permanent link">&para;</a></h3>
<h4 id="82linux">8.2、理解Linux最大文件描述符<a class="headerlink" href="#82linux" title="Permanent link">&para;</a></h4>
<h4 id="83tcp">8.3、一台服务端机器最多可以支撑多少条TCP连接<a class="headerlink" href="#83tcp" title="Permanent link">&para;</a></h4>
<h4 id="8465535">8.4、一台客户端机器最多只能发起65535条连接吗<a class="headerlink" href="#8465535" title="Permanent link">&para;</a></h4>
<h4 id="85">8.5、单机百万并发连接的动手实验<a class="headerlink" href="#85" title="Permanent link">&para;</a></h4>
<h3 id="chap9">chap9、网络性能优化建议<a class="headerlink" href="#chap9" title="Permanent link">&para;</a></h3>
<h3 id="chap10">chap10、容器网络虚拟化<a class="headerlink" href="#chap10" title="Permanent link">&para;</a></h3>
<h4 id="102veth">10.2、veth设备对<a class="headerlink" href="#102veth" title="Permanent link">&para;</a></h4>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90/" class="btn btn-neutral float-left" title="《Linux内核网络栈源代码情景分析》"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../../30machineLearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/" class="btn btn-neutral float-right" title="《机器学习线性代数基础》">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../../30machineLearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
