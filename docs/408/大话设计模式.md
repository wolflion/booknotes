## 《大话设计模式》

+ 全书29章，想解决一下**自己写代码**

  + chap13(builder，初步成功)
  + chap17（Adapter，初步成功）
  + chap24（Chain of Responsibilty，全章逻辑没啥问题，代码自己还没完全敲完，思路没问题了）
  + chap25（Mediator，初步成功），但没运行过，我对这部分内容，还缺少了解

+ 3个分类，7个原则
  
  + [设计模式总结篇-创建型&结构型&行为型 区别、联系](https://blog.csdn.net/jason_jiahongfei/article/details/104937128)
  
+ 创建型（5），**创建对象的模式，抽象了实例化的过程**，关注的是对象的创建，**工、建、单、原**
  
  + 如何new出一个对象来
  + 工厂方法（返回普通类型）、抽象工厂（返回抽象类型）、单例（首先是工厂，简单对象，只有一个实例）、建造者（元素较多）、原型（类对象复制出来）  *这个是错的，工厂方法是1个，抽象工厂是多个，暂时是这么觉得的*
  + 类创建实例，实例化过程中有效的使用类之间的继承关系
  + 对象创建实例，使用代理来完成其任务
  
+ 结构型（7），**解决怎么组装现有类**，设计它们的交互模式  **适、享、代、组、装、外、桥**，【类和对象的复合关系】
  
  + 适配器（兼容老接口）、装饰器（增加额外功能）、代理（控制访问）、外观（封装底层）、桥接（分离抽象与实现）、组合（树形父子关系）、享元（复制对象）
  + 桥接（抽象的手机品牌类，与，抽象的手机软件类，之间是**聚合**的，这条聚合线，看起来像一座桥），然后具体品牌和具体软件去各自继承，然后在clinet去构建，然后用具体手机品牌去跑具体的应用软件。
  
+ 行为型（11），**算法和对象间的职责分配**，描述对象与类的模式，以及它们之间的通信模式 **命、中、观、策、解、责、备、迭、状、模、访**，【对象之间如何通讯的】
  
  + 策略、模板方法、观察者、迭代子、责任链、命令、备忘录、状态、访问者、中介者、解释器
  + 这里分**类模式**（动态的）和**对象模式**（静态的）
  
+ 7个原则
  + chap3、单一职责原则
  + chap4、开放-封闭原则
  + chap5、依赖倒转原则
    + 里面有**里氏替换原则**
  + chap11、迪米特原则
  + chap22、合成复用（用组合和聚合，少用继承）【22.3节】
  + 差了1个
    + 接口隔离
  
+ 类与类之间的关系（6种）

  + 继承（类与类）
  + 实现（类与接口）
  + 依赖（**虚线**，类B作为参数）
  + 关联（**强依赖**，双向实线）
    + 聚合（has-a），空菱形，【计算机与CPU，可以分开的组件】
    + 组合，**强聚合**，实菱形，**不可分**，【人与人的大脑】

+ 基础知识

  + C++ 中聚合和组合的实现       https://blog.csdn.net/guanguanboy/article/details/84750139

    C++类的组合和聚合         https://www.cnblogs.com/qlzstudy/p/16496140.html
    
  + 《写给大家看的面向对象编程书》，《面向对象分析与设计》
  
  + 类的设计（定义一个类；如何设计一个类）
  + OO（面向对象）
    + 封装（接口、实现）
    + 继承
      + is-a，超类、子类、单一继承
      + has-a，**组合**，（聚合、关联）
    + 多态
      + 编译（重载）
      + 运行（重写）覆盖（override，final）
      + 隐藏（重定义）子类与父类有同名函数
      + 实现（抽象类、抽象方法、虚方法、方法重载）

### chap0、附录

#### 0.2、类与实例

#### 0.3、构造方法（构造函数）

#### 0.4、方法重载

#### 0.5、属性与修饰符

#### 0.6、封装

0.7、继承

0.8、多态

0.9、重构

#### 0.10、抽象类

+ 抽象类注意：
  + 第一，抽象类不能实例化
  + 第二，抽象方法是必须被子类重写的方法
  + 第三，如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其他一般方法
+ **当设计一个新的抽象类时，一定是用来继承的**。

#### 0.11、接口

#### 0.12、集合

+ **用于数据存储和检索的专用类**，这些类提供对堆栈、队列、列表和哈希表的支持。大多数集合类实现相同的接口。
+ 装箱和拆箱

0.13、泛型

#### 0.14、委托与事件

+ **委托**：对函数的封装，可以当作给方法的特征指定一个名称
+ **事件**：委托的一种特殊形式，当发生有意义的事情时，事件对象处理通知过程。**事件其实就是设计模式中 观察者模式 在.NET中的一种实现方式**。

### chap1、简单工厂

#### 1.1、面试受挫

#### 1.2、初学者代码毛病

+ 命名不规范、判断分支（每个条件都要判断）、除数为0的异常没处理

#### 1.3、代码规范

#### 1.4、面向对象编程

+ 用面向对象的语言实现，意思就是用**面向对象的编程方法去实现**
+ 大部分初学者遇到问题**直觉地用计算机能够理解的逻辑来描述和表达待解决的问题及具体的求解过程**

+ 如果一开始用**计算机能够理解的逻辑**去描述和解决问题，*只能满足当前需求，不能复用、维护和扩展*

#### 1.5、活字印刷，面向对象

+ 第一，要改，只要改一个字，称为**可维护**
+ 第二，有些字用完这次，后面还可以继续用，称为**可复用**
+ 第三，若要加字，只要另外刻字后加入，称为**可扩展**
+ 第四，横排还是竖排，只要活动移动下即可，称为**灵活性好**

#### 1.6、面向对象的好处

#### 1.7、复制vs.复用

#### 1.8、业务的封装

+ 让**业务逻辑与界面逻辑**分开，让它们之间的耦合度下降
+ 分离出一个Operation类（里面主要是+,-,*,/），再一个client（调用Operation类）

#### 1.9、紧耦合 vs. 松耦合

+ 增加一个平方根(sqrt)运算，就需要修改Operation类
+ 解决方案是，Operation类是基类，各个运算类继承Operation类，子类重新实现`GetResult()`
+ 新的问题，如何让计算机知道调用哪个运算子类，就变成**如何实例化的问题**

#### 1.10、简单工厂模式

+ **用一个单独的类来做这个创造实例的过程**，这就是工厂。
+ 到底要实例化谁，将来会不会增加实例化的对象
+ 简单运算工厂类
+ Operation运算类
  + 有2个对象的get,set方法，用于设置相关的值
  + GetResult()，virtual
+ AddOperation类，继承Operation运算类
  + GetResult()，**各个子类有不同的实现**
+ MinusOperation类，继承Operation运算类
  + CetResult()
+ 其它运算类，继承继承Operation运算类
+ 简单工厂类
  + **创建方法**，new一个Operation运算类，根据不同的符号，找对应的子类（最好是个static的方法）
  + 返回一个Operation基类的指针
+ client
  + Operation运算类，一个实例

#### 1.11、UML类图

+ **聚合**（Aggregation），一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。

+ 合成（Composition）也翻译成**组合**，是一种“拥有”关系，体现了严格的部分与整体的关系，部分和整体的生命周期一样。

#### 0

+ 相对于策略，不需要context类了，直接用具体工厂做事

### chap2、策略（Strategy）

#### 2.1、商场收银软件

#### 2.2、增加打折

#### 2.3、简单工厂实现

#### 2.4、策略模式

+ Strategy，**定义了算法家族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户**。
+ 把不同算法封装起来，让它们之间可互相替换，让算法发生变化，不会影响到使用算法的客户。

#### 2.5、策略模式实现

+ CashSuper是抽象策略
  + 正常收费CashNormal
  + 打折收费CashRebate
  + 返利收费CashReturn，*这三个是具体策略*
+ 增加一个CashContext类，构造函数里**传入CashSuper**，创建一个对象，调用**虚方法acceptCash()**

#### 2.6、策略与简单工厂结合

#### 2.7、策略模式解析

+ 策略模式，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少各种算法类与使用算法类之间的耦合。

#### 0

+ 多了一个context类，这里面**传入具体的策略**
+ strategy基类，strategyA子类，strategyB子类
+ clinet，直接调用context类？

### chap3、单一职责原则

3.1、新手机

3.2、拍摄

3.3、没用的东西

#### 3.4、单一职责原则

+ SRP，**就一个类而言，应该仅有一个引起它变化的原因**

#### 3.5、方块游戏的设计

+ **如果你能够想到多于一个的动机去改变一个类**，那么这个类就具有多于一个的职责

3.6、手机职责过多吗？

### chap4、开放-封闭原则

4.1、考研失败

#### 4.2、开放-封闭原则

+ **软件实体（类、模板、函数等等）应该可以扩展，但是不可修改**
  + 对于扩展是开放的（Open for extension）
  + 对于更改的封闭的（Closed for modification）
+ 怎么的设计才能面对需求的改变却可以保持相对稳定

#### 4.3、何时应对变化

+ 先猜测出具有可能发生的变化种类，然后构造抽象来隔离这些变化
+ **面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码**。

4.4、两手准备，并全力以赴

### chap5、依赖倒转原则

5.1、MM请求修电脑

5.2、电话遥控修电脑

#### 5.3、依赖倒转原则

+ **高层模块不应该依赖低层模块。两个都应该依赖抽象**
+ **抽象不应该依赖细节，细节应该依赖于抽象**（针对接口编程，不要对实现编程）
+ *低层数据库可替换，不影响上层应用*

#### 5.4、里氏代换原则

+ LSP，**子类型必须能够替换掉它们的父类型**【在软件里面，把父类都替换成它的子类，程序的行为没有变化】

#### 5.5、修收音机

+ 程序中所有的依赖关系都是终止于抽象类或者接口，这才是面向对象的设计

### chap6、装饰（Decorator）

6.1、穿什么有这么重要？

#### 6.2、小菜扮靓第一版

+ Person类，里面提供各种穿的方法，穿裤子，穿T
+ client
  + 只能在现有的person方法里组合

#### 6.3、小菜扮靓第二版

+ Person类
  + 提供show的方法
+ 服饰抽象类Finery
  + 提供show()方法，抽象的
+ 各服饰子类，都继承服务抽象类Finery
+ client

#### 6.4、装饰模式（Decorator）

+ **Decorator**：动态地给一个对象添加一些额外的职责，就增加功能来说，**装饰模式比生成子类更为灵活**
+ Component类
+ ConcreteComponet类，继承Component类
+ Decorator类，继承Component类
+ ComponentDecoratorA类，继承Decorator类
+ ComponentDecoratorB类，继承Decorator类

#### 6.5、小菜扮靓第三版

+ 服饰类Decorator，继承自 人类Person

#### 6.6、装饰模式总结

+ 优点：
  + 把类中的装饰功能从类中搬移去除，这样可以简化原有的类，**把类的核心职责和装饰功能区分开**

#### 0

+ 多了一个装饰子类？

### chap7、代理（Proxy）

7.1、为别人做嫁衣！

#### 7.2、没有代理的代码

+ 追求者类
+ 被追求者类
+ Client

#### 7.3、只有代理的代码

+ 代理类
+ 被追求者类
+ Client

#### 7.4、符合实际的代码

+ *没怎么看呢，lionel*

#### 7.5、代理模式（Proxy）

+ **Proxy**：为其他对象提供一种代理以控制对这个对象的访问
+ Subject类，
  + 定义公共接口
+ RealSubject类，继承Subject类，**定义Proxy所代表的真实实体**
+ Proxy类，继承Subject类
  + new RealSubject，然后调用与Subject一样接口，当然也要负责实现
  + 保存一个引用使得代理可以访问实体，并提供一个与Subject的接口相同的接口
+ Client
  + new Proxy

#### 7.6、代理模式的应用

+ 远程代理
+ 虚拟代理
+ 安全代理

7.7、秀才让小六代其求婚

#### 0

+ client直接调用Proxy类
+ Proxy类和RealSubject类，都继承于Subject类，，那么代理干了啥呢？

### chap8、工厂方法（Factory Method）

8.1、活雷锋

#### 8.2、简单工厂模式实现

+ OperationFactory类里有个**静态createOperate()**

#### 8.3、工厂方法模式实现

+ 创建一个工厂接口，里面有个`Operation  CreateOperation()`，这就不是static的了

#### 8.4、简单工厂vs.工厂方法（Factory Method）

+ 简单工厂：client类里不需要有业务逻辑

+ **Factory Method**：定义一个用于创建对象的接口，让子类决定实例化哪一个类。**工厂方法使一个类的实例化延迟到其子类**
+ 工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行

#### 8.5、雷锋工厂

### chap9、原型

#### 9.1、夸张的简历

+ 简历类，设置性别和年龄，设置工作经历，需要写3份

#### 9.2、简历代码初步实现

+ 3份简历，需要3次实例化

#### 9.3、原型模式（Prototype）

+ **用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象**。（从一个对象再创建另一个可定制的对象，而且不需知道任何创建的细节）
+ 原型类（接口，*clone()是个纯虚函数？*）
+ 具体原型类
+ 客户端代码（调用 原型类）
+ Prototype：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
+ "原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。"
+ *直接调用clone()即可？*

#### 9.4、简历的原型实现

+ *为啥要调用clone()，直接赋值不行吗？*  【**主要是为了省构造函数的时间**-lionel，目前是猜的】

#### 9.5、浅复制与深复制

#### 9.6、简历的深复制实现

#### 9.7、复制简历 vs. 手写求职信

#### 0

+ 自己实现了一个clone()方法

### chap10、模板方法（TemplateMethod）

#### 10.1、选择题不会做，蒙呗！

+ 考试题目抄错了，就算会错，最后也白搭

#### 10.2、重复=易错+难改

+ A和B都抄了题目

#### 10.3、提炼代码

+ 老师出试卷，学生填答案
+ *没太理解，lionel*

#### 10.4、模板方法模式（TemplateMethod）

+ **定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤**。
+ 基类里定义了一个模板方法，里面调用基类的虚函数
  + 然后根据具体的子类，直接调用模板方法()，是根据虚函数里的方法，重新调用具体子类的

#### 10.5、模板方法模式特点

+ 通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势。

+ 提取类库中的公共行为到抽象类中

#### 10.6、主观题，看你怎么蒙

#### 0、

+ `virtual void PrimitiveOperation1() {}; //lionel,这个地方只写声明，不写定义会怎么样？编译失败 ` 【C++系列——关于类中添加virtual虚函数只声明不定义报错的一点理解   https://blog.csdn.net/qq_33429968/article/details/120926778】

### chap11、迪米特原则

11.1、第一天上班

11.2、无熟人难办事

#### 11.3、迪米特法则

+ LoD：**如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用**
+ 主要是强调**松耦合**，类之间耦合越弱，越有利于复用

### chap12、外观（Facade）

12.1、牛市股票还会亏钱？

#### 12.2、股民炒股代码

+ 股票1class，有买、卖方法
+ 股票2class，有买、卖方法
+ 国债class，有买、卖方法

#### 12.3、投资基金代码

+ 这就是一个Facade模式，*相当于通过基金公司去买，去卖，至于卖具体的股票A，股票B，还是货基，债基，不管*

#### 12.4、外观模式

+ **Facade**，为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
+ 它完美的体现了，依赖倒转原则和迪米特法则的思想。
+ 四个子系统类（SubSystemOne类、SubSystemTwo类、SubSystemThree类、SubSystemFour类）
+ Facade外观类
  + new 4个子系统类
  + 实现其MethodA()，MethodB()这样的方法
+ client
  + 直接调用Facade对象
+ 思考：（*facade外观类 与 四个子系统类  是啥有关系呢，lionel*）

#### 12.5、何时使用外观模式

+ 设计时考虑分层
+ 新系统与Facade对象交互，Facade与遗留代码交互

#### 0

+ A产品有买、卖方法；B产品也有买、卖方法
+ 现在有了Fund基金公司这个一个类，可以重组一下买的方法（这里面可以买A，买B）

### chap13、建造者

#### 13.1、炒面没放盐

+ 抽象不应该依赖细节，细节应该依赖于抽象

#### 13.2、建造小人一

+ 画人的时候，头身手脚不可少

#### 13.3、建造小人二

+ 瘦人class
+ 胖人class，没有解决**头身手脚不可少**

#### 13.4、建造者模式

+ Builder：**将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示**
+ 用户只需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需知道了。
+ *这个是代码没写出来，有点体会不深，lionel*

#### 13.5、建造者模式解析

+ Builder类，**抽象类**
  + ConcreteBuilder才是具体类
+ Director类，
  + 根据用户需求构造小人对象
+ Product类
  + 由多个部件组成
+ 主要创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化

#### 13.6、建造者模式基本代码

#### 0

+ 构建、表示，分离（啥是构建，啥是表示）

### chap14、观察者

14.1、老板回来？我不知道！

#### 14.2、双向耦合的代码

+ 秘书class里有 观察者class，就耦合了

#### 14.3、解耦实践一

#### 14.4、解耦实践二

#### 14.5、观察者模式（发布/订阅模式）

+ Publish/Subscribe：定义了一种**一对多的依赖关系，让多个观察者对象同时监听某一个主题对象**。这样主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己
+ Subject类
  + 加入观察者
  + 移除观察者
  + 通知｛调用observer的update方法｝
+ Observer类
  + concateObserverA类
  + concreateObserverB类

#### 14.6、观察者模式的特点

+ **解耦合**，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。

#### 14.7、观察者模式的不足

#### 14.8、事件委托实现

#### 14.9、事件委托说明

14.10、石守吉失手机后的委托

#### 0、

+ 类的前向声明（不能创建对象，只能定义指针或引用，作为参数或返回值类型）
+ 抽象类就不能实例化，那么如何通知呢？

### chap15、抽象工厂

15.1、就不能不换DB吗？

#### 15.2、最基本的数据访问程序

+ class User，操作ID和name
+ class SqlServerUser，操作User类，insert()和get()方法

#### 15.3、用了工厂方法模式的数据访问程序

+ IUser接口，**解决与具体数据库的耦合**，里面有insert()和get()
  + 具体的数据库继承IUser接口
+ IFactory接口，里面有`IUser CreateUser()`
  + 具体的数据库，具体new相关的用户
+ Client

#### 15.4、用了抽象工厂模式的数据访问程序

+ **从例子来看，也就比15.3多了一组的概念**，[工厂方法模式 和 抽象工厂模式的对比](https://blog.csdn.net/zjj_flower/article/details/131570251)
  + 这个链接的解答：工厂方法只针对一个抽象产品类，抽象工厂针对多种抽象产品

#### 15.5、抽象工厂模式

+ Abstract Factory：**提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类**

15.6、抽象工厂模式的优点与缺点

15.7、用简单工厂来改进抽象工厂

15.8、

15.9、用反射+配置文件实现数据访问程序

15.10、无痴迷，不成功

### chap16、状态

16.1、加班，又是加班！

#### 16.3、工作状态-分类版

+ 把各种判断放在了`Work::WriteProgram()`里，显得太过于冗长了

16.4、方法过长是坏味道

#### 16.5、状态模式

+ State：**当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类**
+ 状态模式解决**当控制一个对象状态转换的条件表达式过于复杂时**，把**状态的判断逻辑转移到表示不同状态的一系列类当中，把复杂的判断逻辑简化**
+ State类（抽象类）
+ ConcreteState类（具体类），
+ Context类（维护一个ConcretSate类的实例），这个不继续于谁
+ Client，调用Context类即可

#### 16.6、状态模式好处与用处

#### 16.7、工作状态-状态模式版

+ 抽象工作状态类
+ 上午状态类，中午状态类，下午状态类，etc..
+ 工作类（就是Context类？）
+ Client

### chap17、适配器（Adapter）

#### 17.1、在NBA我需要翻译

#### 17.2、适配器模式

+ **Adapter**：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
+ 适配器模式分两种类型
  + 类适配器模式
  + 对象适配器模式
+ Target类
+ Adaptee（需要适配的类）
+ Adapter（内部包装一个Adaptee对象，**把源接口转换成目标接口**）
  + 继承自Target类
+ Client

#### 17.3、何时使用适配器模式

#### 17.4、篮球翻译适配器

+ Player是个抽象类，
  + 中锋，前锋，后卫继承于它，同时就需要**翻译**也继承它
  + 现在有了个**外籍中锋**类
+ client
  + 不直接new**外籍中锋**，而是new**翻译**，让翻译去调用**外籍中锋**的进攻或防守指令

#### 17.5、适合器模式的.NET应用

+ 对不同数据库的**DataAdapter**

#### 17.6、扁鹊的医术

### chap18、备忘录

#### 18.2、游戏存进度

#### 18.3、备忘录模式

+ **Memento**，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可该对象恢复到原先保存的状态

#### 18.4、备忘录模式基本代码

+ Originator类（发起人）
  + 创建或恢复备忘录
+ Memento类（备忘录）
+ Caretaker类（管理者）
  + 得到或设置备忘录
+ client（**上面3个没有继承关系**）

### chap19、组合

#### 19.2、组合模式

+ **Composite**，将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性

#### 19.3、透明方式与安全方式

#### 19.4、何时使用组合模式

#### 19.5、公司管理系统

+ 公司class（）
  + 有纯虚的add、remove、depth、dispaly()方法
  + 具体公司类，继承并实现它
  + 人力资源部，继承并实现它（add和remove是空的）
  + 财务部，继承并实现它（add和remove是空的）
+ Clinet
  + 用具体公司类，实现总公司的时候，add了 人力资源部、财务部
  + 用具体公司类，实现分公司时，add了人力资源部，财务部  【**这时调用总公司的add()方法，把分公司放进去**】
  + 办事处也是类似

### chap20、迭代器（Iterator）

#### 20.1、乘车买票，不管你是谁！

+ 只计算人头个数，不管具体的人是谁，还是行李，都要算钱

#### 20.2、迭代器模式

+ **Iterator**：提供一种方法顺序访问一个聚合对象中各个元素，而不暴露该对象的内部表示。

#### 20.3、迭代器实现

+ *lionel，真的写代码后发现不对，c#有个object类型呢，C++没有，怎么转呢？所以，代码暂时没有调通*

+ Iterator类：
  + First()
  + Next()，下一个
  + IsDone()，是否结束
+ ConcreteIterator
  + 继承Iteraotr并实现它
+ Aggregate类
  + 创建迭代器，`Iterator CreateIterator()`
+ ConcreteAggreagate类
  + 存放聚合对象
  + 重载`CreateIterator()`
  + *要不要提供啥方法？*
+ Client
  + 创建公交车，即聚集对象
  + 公交车上乘客，即对象数组
  + 创建迭代器对象，即售票员看上车的是哪些人
  + 迭代器操作，`First()，Next()，isDone()`，
    + 从第一个开始，只要没有结束，就不断Next
+ **当你需要对聚集有多种方式遍历时，可以考虑用迭代器模式**
  + 比如按重量遍历

#### 20.4、.NET的迭代器实现

+ foreach in，*我想到的是STL里的迭代器*

#### 20.5、迭代高手

### chap21、单例

#### 21.4、单例模式

+ **Singleton**，保证一个类仅有一个实例，并提供一个访问它的全局访问点

#### 21.5、多线程时的单例

#### 21.6、双重锁定

#### 2.17、静态初始化

+ *这只是c#的嘛，还是说，都可以用？lionel*

### chap22、桥接

22.1、凭什么你的游戏我不能玩

22.2、紧耦合的程序演化

#### 22.3、合成复用原则

+ **CARP**，尽量使用合成/聚合，尽量不要使用类继承

22.4、松耦合的程序

#### 22.5、桥接模式

+ **Bridge**，将抽象部分和它的实现部分分离，使它们都可以独立地变化。**实现，指的是抽象类和派生类用来实现自己的对象**

#### 22.6、桥接模式基本代码

+ Implementor抽象类
  + ConcreteImplementorA，ConcreteImplementorB，继承它
+ Abastraction类
  + 定义一个operation()调用Implementor类的方法
  + RefinedAbstraction类，继承它，并实现它的虚函数
+ Client

22.7、我要开发“好”游戏

### chap23、命令

23.1、吃烤羊肉串

23.2、烧烤摊 VS. 烧烤店

23.3、紧耦合设计

#### 23.4、松耦合设计

23.5、松耦合后

#### 23.6、命令模式

+ **Command**，将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化：对请求排队或记录请求日志，以及支持可撤销的操作

23.7、命令模式的作用

### chap24、职责链（Chain of Responsibility）

#### 24.1、老板，我要加薪！

+ 向经理申请，经理没权利，向总监汇报，也没有权限，向总经理上报。

#### 24.2、加薪代码初步

+ 申请类
  + 申请类别
  + 申请内容
  + 数量
+ 管理类
  + 得到结果，`GetResult()`，一个函数里面判断当前的经理能不能批
+ Client

#### 24.3、职责链模式

+ *这个图，其实没太看，lionel*

+ **Chain of Responsibility**：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
+ Handler类
  + 定义一个处理请示的接口，`HandleRequest()`
+ ConcreteHandler1类
  + 请求数在1-10之间的有权处理
+ ConcreteHandler2类
  + 请求数在11-20之间的有权处理
+ ConcreteHandler3类
  + 请求数在21-30之间的有权处理
+ Client

#### 24.4、职责链的好处

+ 职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用

#### 24.5、加薪代码重构

+ 管理者类，Manager  【**设置继任者**是个纯虚函数】
  + 经理类CommonManager，继承Manger（如果自己处理不了，继任者非空，就转给继任者）
  + 总监类MajorManager，继承Manger
  + 总经理类GeneralManager，继承Manger
+ Client
  + **指定了继任者**

#### 24.6、加薪成功

### chap25、中介者

25.1、世界需要和平

+ 提到了之前讲过的**迪米特法则**

#### 25.2、中介者模式

+ **Mediator**，用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

25.3、安理会做中介

#### 25.4、中介者模式优缺点

+ 当系统出现了“多对多”交互复杂的对象群时，不要急于使用中介者模式，而要先反思你的系统在设计上是不是合理？
+ 中介者模式一般应用于**一组对象以定义良好但是复杂的方式进行通信的场合**

### chap26、享元

26.1、项目多也没傻做

#### 26.2、享元模式

+ **Flyweight**，运用共享技术有效地支持大量细粒度的对象

#### 26.4、内部状态与外部状态

### chap27、解释器

### chap28、访问者

#### 28.5、访问者模式

+ **Visitor**，表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

### chap29、模式总结

### 学习过程

+ 0531，看了2章，建造者模式builder（13）、观察者模式observer（14）
+ 0601，看了3章，抽象工厂模式（15），状态模式（16），适配器模式（17），*抽象工厂模式，没太看懂*，0605看了chap01、02的2章
+ 0710，看了3章，适配器（17，*之前看过了*），迭代器（20），职责链（24）
+ 202303月，大概看一下，全书的前15章左右，*感觉还是忘光了*
+ 20230717，**感觉核心还是有意识的多琢磨，多问，多去想**，目标是第一阶段，**2023年7月底，书中前14章结束掉**（2023年8月，看剩下的）
+ 时间曲线：我看自己的纸质笔记上，2022年4月手抄了一些，**没有真正理解**

#### ref

+ design-pattern.readthedocs.io，《图说设计模式》，
+ 如何去记各种设计模式？【一分钟让你记下23种测试模式】
+ 《图解设计模式》
+ liaoxuefeng的设计模式，不过是java的
+ refactoringguru.cn
+ cnblogs.com/weihanli/p/struct-pattersn.hmtl，github就是weihanli

#### 勘误

+ 14.3节的（P126），写成了`:base(name, sub) {}`，应该是`:Observer4(name, sub) {}`，2个子类都错了   【是不是c#就这么写的啊？】