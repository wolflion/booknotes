## 《深入理解C++11》

### chap2、保证稳定性和兼容性

#### 2.1、保持与C99兼容

##### 2.1.1、预定义宏

+ `_STDC_HOSTED_`
+ `_STDC_`
+ `_STDC_VERSION_`
+ `_STDC_ISO_10646`

##### 2.1.2、`_func_`预定义标识符

+ `const char* hello(){return __func__;}`

##### 2.1.3、_Pragma操作符

+ `_Pragma(字符串字面量)`与`#pragma`功能相同

##### 2.1.4、变长参数的宏定义以及__VA_ARGS__

+ 变长参数的宏定义:指宏定义中参数列表的最后一个参数为省略号。
+ 预定义宏`__VA_ARGS__`则可以在宏定义的实现部分替换省略号所代表的字符串。
+ `#define PR(...) printf(__VA_ARGS__)`

##### 2.1.5、宽窄字符串的练接

+ 窄字符（char）与宽字符（wchar_t），会自动转换后再与宽字符运算。

#### 2.2、long long整型

+ 要了解平台上long long大小的方法就是查看<climits>（或<limits.h>）中的宏。
+ 2-2-1.cpp

#### 2.3、扩展的兼容性

#### 2.5、宏_cplusplus

#### 2.5、静态断言

##### 2.5.1、断言：运行时与预处理时

+ 在通常情况下，**断言**就是将一个返回值总是需要为真的判别式放在语句中，用于排除在设计的逻辑上不应该产生的情况。

+ 用宏`NDEBUG`来禁用assert宏。

+ `#error`预处理指令

  + ``` #ifndef _COMPLEX_H
        #error "Never use <bits/cmathcalls.h> directly; include <complex.h> instead."
        #endif
    ```

##### 2.5.2、静态断言与static_assert

+ **断言assert宏只有在程序运行时才能起作用。而#error只在编译器预处理时才能起作用**。
+ 2-5-2.cpp

#### 2.6、noexcept修饰符与noexcept操作符

+ noexcept修饰符
  + `void excpt_func() noexcept;`
  + `void excpt_func() noexcept(常量表达式)`

#### 2.7、快速初始化成员变量

+ C++11用`{}`

+ 2-7-1.cpp

#### 2.8、非静态成员的sizeof

+ **C++11中，非静态成员的sizeof操作是合法的**，C++98时则不行

#### 2.9、扩展的friend语法

+ **为类模板声明友元**

+ 2-9-1.cpp
+ 2-9-3.cpp

#### 2.10、final/override控制

+ final关键字作用：**使派生类不可覆盖它所修饰的虚函数**

+ 虚函数描述符override：**如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数**，否则代码将无法通过编译。

#### 2.11、模板函数的默认模板参数

#### 2.12、外部模板

##### 2.12.1、为什么需要外部模板

+ a.c中和b.c中都有`int i;`定义时，链接器在链接a.o和b.o时，会报错
  + b.c中可以直接`extern int i;`，这样生成的目标文件a.o和b.o中只有i这个符号的一份定义。
    + a.o中i是真实存在的
    + b.o中，只是记录了i符号会引用其他目标文件中数据区中的名为i的数据

##### 2.12.2、显式的实例化与外部模板的声明

+ 模板声明：`template<typename T> void fun(T){}`

+ 显式实例化：`template void fun<int>(int);`
+ 外部模板的声明：`extern template void fun<int>(int);`
  + **不能用于静态函数（即文件域函数）**，但可以用于**类静态成员函数**

#### 2.13、局部和匿名类型作模板实参

+ C++98中，局部的类型和匿名的类型都不做模板类的实参
+ **C/C++中，即使是匿名类型的声明，也需要独立的表达式语句**

#### 2.14、本章小结

### chap3、通用为本，专用为末

#### 3.1 继承构造函数

+ **基类的非虚函数则无法再被派生类使用**。
+ 如果派生类要使用基类的构造函数，通常需要在构造函数中显式声明。
  + ```struct A{A(int i){}};   struct B:A{B(int i):A(i){}};```
+ 基类只有一个构造函数 [3-1-1.cpp]()
+ 基类有多个构造函数 [3-1-2.cpp]()
+ 通过using声明[3-1-3.cpp]()
+ 改造3-1-2.cpp [3-1-4.cpp]()
+ **C++11标准继承构造函数被设计为跟派生类中的各种类默认函数（默认构造、析构、拷贝构造等）一样，都是隐式声明的**。
+ 同时使用继承构造函数和成员变量初始化两个C++11的特性[3-1-5.cpp]()
+ 对于继承构造函数来讲，参数的默认值是不会被继承的。[3-1-6.cpp]()  **参数默认值会导致多个构造函数版本的产生**
+ 继承函数“冲突”的情况 [3-1-7.cpp]()
+ [3-1-8.cpp]

#### 3.2 委派构造函数  86/336

+ 重复代码的构造函数 [3-2-1.cpp]()
+ C++11的写法[3-2-2.cpp]()
+ C++11调用基准版本的构造函数[3-2-3.cpp]()
  + **委派构造函数（delegating constructor）**就是指委派函数将构造的任务委派给了目标构造函数（“基准版本”）来完成这样一种类构造的方式。
+ **在C++中，构造函数不能同时“委派”和使用初始化列表，所以委派构造函数要给变量赋初值，初始化代码必须放在函数体中**。
+ [3-2-4.cpp]
+ **链状委托构造** [3-2-5.cpp]()
+ 委派构造一个很实际的应用就是使用构造函数产生目标构造函数。 [3-2-6.cpp]()
+ 在委派构造函数中使用try [3-2-7.cpp]()

#### 3.3 右值引用：移动语义和完美转发  92/336

#### 3.6 POD类型  124/336

+ C++11将POD（Plain Old Data）划分为
  + 平凡的（trivial）
  + 标准布局的（standard layout）
+ [3-6-1.cpp]

### chap4、

#### 4.1、右尖括号>的改进

+ C++98中会将`>>`优先解析为右移。C++11能智能识别是不是右移。

+ 右移操作的时候，最好还是用括号括起来。

+ 4-1-1.cpp

  + ```cpp
    template <int i> class X{};
    template <class T> class Y{};
    Y<X<1> > x1;//compile success
    Y<X<2>> x2; // compile failure
    // g++ -c 4-1-1.cpp
    ```

+ 4-1-2.cpp

  + ```cpp
    template <int i> class X {};
    X <1 >> 5> x;  // C++98这个>>是位移操作，C++11报错
    ```

#### 4.2、auto类型推导

##### 4.2.1、静态类型、动态类型与类型推导

+ 静态类型和动态类型的区别在于对变量进行类型检查的时间点。**静态检查主要发生在编译阶段；动态类型检查主要发生在运行阶段**。

+ [4-3.cpp]

+ `auto`早期C/C++标准的解释，具有自动存储期的局部变量。**auto声明变量的类型必须由编译器在编译时期推导而得**。

+ [4-2-2.cpp]

  + ```cpp
    int main(){
        double foo();
        auto x = 1;    //int  【本来是const int，const被省了】
        auto y = foo(); // double
        struct m { int i; }str;
        auto str1 = str;  // struct m
        auto z;  // 无法推导，无法通过编译
        z = x;
    }
    ```

    // g++ -std=c++11 4-2-2.cpp

+ **auto并非一种“类型”声明，而是一个类型声明时的“占位符”**。

##### 4.2.2、auto的优势

+ 1、在拥有初始化表达式的复杂类型变量声明时简化代码。
+ 2、免除程序员在一些类型声明时的麻烦，或者避免一些在类型声明时的错误。
  + [4-2-6.cpp]
+ 3、其“自适应”性能够在一定程度上支持泛型的编程。
  + [4-2-7.cpp]

##### 4.2.3、auto的使用细则

+ auto可以与指针和引用结合起来使用
  + [4-2-9.cpp]

#### 4.3、decltype

##### 4.3.1、typeid与decltype

+ C++98对动态类型支持就是C++中的运行时类型识别（RTTI）。

+ RTTI的机制是为每个类型产生一个type_info类型的数据，程序员可以在程序中使用typeid随时查询一个变量的类型，typeid就会返回变量相应的type_info数据。

+ [4-3-1.cpp]

+ **类型推导是随着模板和泛型编程的广泛使用而引入的**。

+ [4-3-2.cpp]

+ **decltype的类型推导并不是像auto一样是从变量声明开始的初始化表达式获得变量的类型，decltype总是以一个普通的表达式为参数，返回该表达式的类型。

  + ```cpp
    int i;
    decltype(i) j = 0;
    ```

##### 4.3.2、decltype的应用

+ 一些例子

  + ```cpp
    using size_t = decltype(sizeof(0));
    using ptrdiff_t = decltype((int*)0-(int*)0);
    using nullptr_t = decltype(nullptr);
    ```

##### 4.3.3、decltype推导四规则

+ ```cpp
  int i;
  decltype((i)) b;  // b int &，无法编译通过
  ```

+ 依序判断以下四规则：

  + 如果e是一个没有带
  + 否则，假设e的类型是T，如果e是一个
  + 否则，假设e的类型是T，如果e是一个
  + 否则，假设e的类型是T，则decltype(e)为T。

##### 4.3.4、cv限制符的继承与冗余的符号

+ [4-3-12.cpp]

#### 4.4、追踪返回类型

##### 4.4.1、追踪返回类型的引入

#### 4.5、基于范围的for循环

+ `for_each`的概念
+ [4-5-5.cpp]

#### 4.6、本章小结

### chap5、

#### 5.1、强类型枚举

##### 5.1.1、枚举：分门别类与数值的名字

+ 当程序中需要“数值的名字”的时候，我们常常可以使用以下3种方式来实现
  + 第一种：宏
  + 第二种：匿名枚举  `enum {Male, Female};`
  + 第三种：静态常量  `const static int Male = 0;`

##### 5.1.2、有缺陷的枚举类型

+ [5-1-1.cpp]
+ [5-1-2.cpp]
+ [5-1-3.cpp]
+ [5-1-4.cpp]

##### 5.1.3、强类型枚举以及C++11对原有枚举类型的扩展

+ 非强类型作用域，允许隐式转换为整型，占用存储空间及符号性不确定，都是**枚举类的缺点**。
+ **枚举类**，也叫“强类型枚举”。`enum class Type{General,Light,Medium,Heavy};`
+ **匿名的enum class可能什么都做不了** [5-1-7.cpp]

#### 5.2、堆内存管理：智能指针与垃圾回收

##### 5.2.1、显式内存管理

+ 野指针：
+ 重复释放：
+ 内存泄漏：

##### 5.2.2、C++11的智能指针

+ C++98中，通过一个模板类型"auto_ptr"实现。
+ C++11中改用unique_ptr、shared_ptr及weak_ptr等智能指针来自动回收堆分配的对象。
+ [5-2-1.cpp]
+ [5-2-2.cpp]

##### 5.2.3、垃圾回收的分类

+ 1、基于引用计数（reference counting garbage collector）的垃圾回收器
+ 2、基于跟踪处理（tracing garbage collector）的垃圾回收器
  + 标记-清除（Mark-Sweep）
  + 标记-整理（Mark-Compact）
  + 标记-拷贝（Mark-Copy）

##### 5.2.4、C++与垃圾回收

+ C/C++垃圾回收库-Boehm

##### 5.2.5、C++11与最小垃圾回收支持

##### 5.2.6、垃圾回收的兼容性

### chap6、提高性能及操作硬件的能力  

#### 6.1、常量表达式

##### 6.1.1、运行时常量性与编译时常量性

+ **const是运行时常量**
  + 6-01-01.cpp
  + 6-01-02.cpp
+ `constexpr`是**编译时期常量**，即常量表达式

##### 6.1.2、常量表达式函数

+ 常量表达式函数的情况
  + 函数体只有单一的return返回语句
  + 函数必须返回值（不能是void函数）
  + 在使用前必须已有定义
  + return返回语句表达式中不能使用非常量表达式的函数、全局数据，且必须是一个常量表达式

+ 6-01-03.cpp

##### 6.1.3、常量表达式值

+ `const int i=3;`与`constexpr int j=1;`有什么区别
  + 如果i在全局名字空间中，编译器一定会为i产生数据。
  + 而对于j，如果不是有代码显式地使用了它的地址，编译器可以选择不为它生成数据，而仅将其当做编译时期的值
+ 常量表达式的构造函数也有使用上的约束
  + 函数体必须为空
  + 初始化列表只能由常量表达式来赋值
+ 6-01-05.cpp

##### 6.1.4、常量表达式的其他应用

+ 6-01-06.cpp

#### 6.2、变长模板

##### 6.2.1、变长函数和变长的模板参数

##### 6.2.2、变长模板：模板参数包和函数参数包

##### 6.2.3、变长模板：进阶

#### 6.3、原子类型与原子操作

##### 6.3.1、并行编程、多线程与C++

##### 6.3.2、原子操作与C++11原子类型

##### 6.3.3、内存模型，顺序一致性与memory_order

#### 6.4、线程局部存储

#### 6.5、快速退出：quick_exit与at_quick_exit

#### 6.6、本章小结

### chap7、

#### 7.1、指针空值-nullptr

##### 7.1.1、指针空值：从0到NULL，再到nullptr

+ [7-1-1.cpp]
+ [7-1-2.cpp]

##### 7.1.2、nullptr和nullptr_t

+ nullptr是指针空值常量
+ nullptr_t是指针空值类型
+ [7-1-3.cpp]

##### 7.1.3、一些关于nullptr规则的讨论

+ nullptr类型数据所占用的内存空间大小跟void*相同，`sizeof(nullptr_t) == sizeof(void*)`
+ nullptr是一个编译时期的常量，它的名字是一个编译时期的关键字，能够为编译器所识别。`(void*)0`只是一个强制转换表达式，其返回的也是一个void*指针类型。

#### 7.2、默认函数的控制

##### 7.2.1、类与默认函数

##### 7.2.2、

#### 7.3、lambda函数   261/336

##### 7.3.1、lambda的一些历史

+ 希腊字母表中位于第11位，**lambda则是被用来表示一种匿名函数**。

##### 7.3.2、C++11中的lambda函数

+ `[capture](parameters) mutable ->return-type{statement}`，具体`auto totalChild = [](int x, int y) ->int{return x + y; };`

##### 7.3.3、lambda与仿函数

+ **仿函数**简单地说，就是重定义了成员函数operator()的一种自定义类型对象。**不是函数名称，而是对象名称**。

##### 7.3.4、lambda的基础使用

+ [7-3-7.cpp]
+ lambda函数等同于一个“局部函数”。

##### 7.3.5、关于lambda的一些问题及有趣的实验

+ [7-3-9.cpp]

##### 7.3.6、lambda与STL

+ [7-3-13.cpp]

##### 7.3.7、更多的一些关于lambda的讨论

### 最后

+ 2019年3月就零星看了些，**没有形成知识网**，2023年11月准备花1个月整理一下。