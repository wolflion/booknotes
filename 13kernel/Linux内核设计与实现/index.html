<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>《Linux内核设计与实现》 - lionel的技术笔记</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u300aLinux\u5185\u6838\u8bbe\u8ba1\u4e0e\u5b9e\u73b0\u300b";
        var mkdocs_page_input_path = "13kernel\\Linux\u5185\u6838\u8bbe\u8ba1\u4e0e\u5b9e\u73b0.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> lionel的技术笔记
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../01daily/">daily</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../02ds/">ds</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../03cpp/">cpp</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../21tool/">cpp</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">C++</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/effectiveC%2B%2B/">《Effective C++》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">《深度探索C++对象模型》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/EffectiveSTL/">《Effective STL》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/C%2B%2B%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/">《C++泛型STL原理和应用》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">《STL源码剖析》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../22C%2B%2Bmodern/%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8C%2B%2B11/">《深入应用C++11》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">基础知识</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">《操作系统导论》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">《大话设计模式》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90_C%2B%2B4th/">《数据结构与算法分析_C++4th》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E7%AE%97%E6%B3%95%284th%29/">《算法4th》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%BC%A0%E5%86%9B/">《算法设计与分析-张军》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E5%A4%A9%E8%A1%8C-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《天行-算法设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B-%E6%9D%8E%E6%98%A5%E8%91%86/">《数据结构教程》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网络编程</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">《TCP/IP网络编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">《Linux高性能服务器编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71/">《TCPIP详解卷1》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90/">《Linux内核网络栈源代码情景分析》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C/">《深入理解Linux网络》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">文件系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/Linux%E5%86%85%E6%A0%B8%E6%8E%A2%E7%A7%98/">《Linux内核探秘》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《文件系统技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">《存储技术原理分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">存储</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../12storage/ceph%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《ceph设计原理与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">视频</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/FFmpeg%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">《FFmpeg入门到精通》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">《WebRTC权威指南》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AE%9E%E6%97%B6%E4%BA%92%E5%8A%A8%E6%8A%80%E6%9C%AF/">《WebRTC音视频实时互动技术》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/%E6%96%B0%E4%B8%80%E4%BB%A3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%A0%81%E6%A0%87%E5%87%86-H.264_AVC/">《新一代视频压缩码标准-H.264_AVC》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">内核</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">《Linux内核设计与实现》</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#chap3">chap3、进程管理</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#31">3.1、进程</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#32">3.2、进程描述符及任务结构</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#321">3.2.1、分配进程描述符</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#322">3.2.2、进程描述符的存放</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#323">3.2.3、进程状态</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#324">3.2.4、设置当前进程状态</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#325">3.2.5、进程上下文</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#326">3.2.6、进程家族树</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#33">3.3、进程创建</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#331">3.3.1、写时拷贝</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#332fork">3.3.2、fork()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#333vfork">3.3.3、vfork()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#34linux">3.4、线程在linux中的实现</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#341">3.4.1、创建线程</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#342">3.4.2、内核线程</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#35">3.5、线程终结</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_1">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#351">3.5.1、删除进程描述符</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#352">3.5.2、孤儿进程造成的进退维谷</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#36">3.6、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap4">chap4、进程调度</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#41">4.1、多任务</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#42linux">4.2、Linux的进程调度</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#43">4.3、策略</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#431io">4.3.1、I/O消耗型和处理器消耗型的进程</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#432">4.3.2、进程优先级</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#433">4.3.3、时间片</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#434">4.3.4、调度策略的活动</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#44linux">4.4、Linux调度算法</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#441">4.4.1、调度器类</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#442unix">4.4.2、Unix系统中的进程调度</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#443">4.4.3、公平调度</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#45linux">4.5、Linux调度的实现</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#451">4.5.1、时间记账</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#452">4.5.2、进程选择</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#453">4.5.3、调度器入口</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#454">4.5.4、睡眠和唤醒</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#46">4.6、抢占和上下文切换</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#461">4.6.1、用户抢占</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#462">4.6.2、内核抢占</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#47">4.7、实时调度策略</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#48">4.8、与调度相关的系统调用</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#481">4.8.1、与调度策略和优先级相关的系统调用</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#482">4.8.2、与处理器绑定有关的系统调用</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#483">4.8.3、放弃处理器时间</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#49">4.9、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap5">chap5、系统调用</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#51">5.1、与内核通信</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#52apiposixc">5.2、API、POSIX和C库</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#53">5.3、系统调用</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_2">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#531">5.3.1、系统调用号</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#532">5.3.2、系统调用的性能</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#54">5.4、系统调用处理程序</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_3">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#541">5.4.1、指定恰当的系统调用</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#542">5.4.2、参数传递</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#55">5.5、系统调用的实现</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#551">5.5.1、实现系统调用</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#552">5.5.2、参数验证</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#56">5.6、系统调用上下文</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_4">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#561">5.6.1、绑定一个系统调用的最后步骤</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#562">5.6.2、从用户空间访问系统调用</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#563">5.6.3、为什么不通过系统调用的方式实现</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#57">5.7、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap6">chap6、内核数据结构</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#61">6.1、链表</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_5">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#611">6.1.1、单向链表和双向链表</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#612">6.1.2、环形链表</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#613">6.1.3、沿链表移动</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#614linux">6.1.4、Linux内核中的实现</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#615">6.1.5、操作链表</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#616">6.1.6、遍历链表</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#62">6.2、队列</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_6">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#621kfifo">6.2.1、kfifo</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#622">6.2.2、创建队列</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#623">6.2.3、推入队列数据</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#624">6.2.4、摘取队列数据</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#625">6.2.5、获取队列数据</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#626">6.2.6、重置和撤销队列</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#627">6.2.7、队列使用举例</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#63">6.3、映射</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_7">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#631idr">6.3.1、初始化一个idr</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#632uid">6.3.2、分配一个新的UID</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#633uid">6.3.3、查找UID</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#634uid">6.3.4、删除UID</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#635idr">6.3.5、撤销idr</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#64">6.4、二叉树</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#641bst">6.4.1、二叉搜索树（BST）</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#642">6.4.2、自平衡二叉搜索树</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#65">6.5、数据结构以及选择</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#66">6.6、算法复杂度</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#661">6.6.1、算法</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#662o">6.6.2、大O符号</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#663xita">6.6.3、大xita符号</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#664">6.6.4、时间复杂度</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#67">6.7、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap7">chap7、中断和中断处理</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#71">7.1、中断</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#72">7.2、中断处理程序</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#73">7.3、上半部和下半部的对比</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#74">7.4、注册中断处理程序</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#741">7.4.1、中断处理程序标志</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#742">7.4.2、一个中断例子</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#743">7.4.3、释放中断处理程序</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#75">7.5、编写中断处理程序</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#751">7.5.1、共享的中断处理程序</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#752">7.5.2、中断处理程序实例</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#76">7.6、中断上下文</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#77">7.7、中断处理机制的实现</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#78procinterrupts">7.8、/proc/interrupts</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#79">7.9、中断控制</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#791">7.9.1、禁止和激活中断</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#792">7.9.2、禁止指定中断线</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#793">7.9.3、中断系统的状态</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#710">7.10、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap8">chap8、下半部和推后执行的工作</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#81">8.1、下半部</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_8">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#811">8.1.1、为什么要用下半部</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#812">8.1.2、下半部的环境</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#82">8.2、软中断</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#821">8.2.1、软中断的实现</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#822">8.2.2、使用软中断</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#83tasklet">8.3、tasklet</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#831tasklet">8.3.1、tasklet的实现</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#832tasklet">8.3.2、使用tasklet</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#833bh">8.3.3、老的BH机制</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#84">8.4、工作队列</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_9">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#841">8.4.1、工作队列的实现</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#842">8.4.2、使用工作队列</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#843">8.4.3、老的任务队列机制</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#85">8.5、下半部机制的选择</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#86">8.6、在下半部之间加锁</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#87">8.7、禁止下半部</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#88">8.8、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap9">chap9、内核同步介绍</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#91">9.1、临界区和竞争条件</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_10">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#911">9.1.1、为什么我们需要保护</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#912">9.1.2、单个变量</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#92">9.2、加锁</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_11">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#921">9.2.1、造成并发执行的原因</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#922">9.2.2、了解要保护些什么</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#93">9.3、死锁</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#94">9.4、争用和扩展性</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#95">9.5、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap10-158353">chap10、内核同步方法 （158/353）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#101">10.1、原子操作</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1011">10.1.1、原子整数操作</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#101264">10.1.2、64位原子操作</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1013">10.1.3、原子位操作</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#102">10.2、自旋锁</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_12">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1021">10.2.1、自旋锁方法</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1022">10.2.2、其他针对自旋锁的操作</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1023">10.2.3、自旋锁和下半部</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#103-">10.3、读写-自旋锁</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#104">10.4、信号量</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_13">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1041">10.4.1、计数信号量和二值信号量</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1042">10.4.2、创建和初始化信号量</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1043">10.4.3、使用信号量</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#105-">10.5、读写-信号量</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#106">10.6、互斥体</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_14">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1061">10.6.1、信号量和互斥体</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1062">10.6.2、自旋锁和互斥体</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#107">10.7、完成变量</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#108blk">10.8、BLK：大内核锁</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#109">10.9、顺序锁</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1010">10.10、禁止抢占</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1011_1">10.11、顺序和屏障</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1012">10.12、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap11183353">chap11、定时器和时间管理（183/353）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#111">11.1、内核中的时间概念</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#112hz">11.2、节拍率：HZ</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_15">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1121hz">11.2.1、理想的HZ值</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1122hz">11.2.2、高HZ的优势</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1123hz">11.2.3、高HZ的劣势</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#113jiffies">11.3、jiffies</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_16">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1131jiffies">11.3.1、jiffies的内部表示</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1132jiffies">11.3.2、jiffies的回绕</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1133hz">11.3.3、用户空间和HZ</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#114">11.4、硬时钟和定时器</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1141">11.4.1、实时时钟</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1142">11.4.2、系统定时器</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#115">11.5、时钟中断处理程序</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#116">11.6、实际时间</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#117">11.7、定时器</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_17">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1171">11.7.1、使用定时器</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1172">11.7.2、定时器竞争条件</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1173">11.7.3、实现定时器</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#118">11.8、延迟执行</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1181">11.8.1、忙等待</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1182">11.8.2、短延迟</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1183schedule-timeout">11.8.3、schedule timeout()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#119">11.9、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap12">chap12、内存管理</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#121">12.1、页</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#122">12.2、区</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#123">12.3、获得页</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_18">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#12310">12.3.1、获得填充为0的页</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1232">12.3.2、释放页</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#124kmalloc">12.4、kmalloc</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_19">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1241gfp_mask">12.4.1、gfp_mask标志</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1242kfree">12.4.2、kfree</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#125vmalloc">12.5、vmalloc</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#126slab">12.6、slab层</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_20">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1261slab">12.6.1、slab层的设计</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1262slab">12.6.2、slab分配器的接口</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#127">12.7、在栈上的静态分配</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_21">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1271">12.7.1、单页内核栈</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1272">12.7.2、在栈上光明正大地工作</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#128">12.8、高端内存的映射</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_22">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1281">12.8.1、永久映射</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1282">12.8.2、临时映射</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#129cpu">12.9、每个CPU的分配</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1210cpu">12.10、新的每个CPU接口</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_23">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#12101cpu">12.10.1、编译时的每个CPU数据</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#12102cpu">12.10.2、运行时的每个CPU数据</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1211cpu">12.11、使用每个CPU数据的原因</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1212">12.12、分配函数的选择</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1213">12.13、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap13">chap13、虚拟文件系统</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#131">13.1、通用文件系统接口</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#132">13.2、文件系统抽象层</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#133unix">13.3、Unix文件系统</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#134vfs">13.4、VFS对象及其数据结构</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#135">13.5、超级块对象</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#136">13.6、超级块操作</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#137">13.7、索引节点对象</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#138">13.8、索引节点操作</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#139">13.9、目录项对象</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_24">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1391">13.9.1、目录项状态</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1392">13.9.2、目录项缓存</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1310">13.10、目录项操作</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1311">13.11、文件对象</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1312">13.12、文件操作</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1313">13.13、和文件系统相关的数据结构</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1314">13.14、和进程相关的数据结构</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1315">13.15、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap14io">chap14、块I/O</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#0_25">0、</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#141">14.1、剖析一个块设备</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#142">14.2、缓冲区和缓冲区头</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#143bio">14.3、bio结构体</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_26">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1431io">14.3.1、I/O向量</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1432">14.3.2、新老办法对比</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#144">14.4、请求队列</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#145io">14.5、I/O调度程序</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1451io">14.5.1、I/O调度程序的工作</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1452linux">14.5.2、Linux电梯</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1453io">14.5.3、最终期限I/O调试程序</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1454io">14.5.4、预测I/O调度程序</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1455io">14.5.5、完全公正的排队I/O调度程序</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1456io">14.5.6、空操作的I/O调度程序</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1457io">14.5.7、I/O调度程序的选择</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#146">14.6、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap15">chap15、进程地址空间</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#151">15.1、地址空间</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#152">15.2、内存描述符</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_27">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1521">15.2.1、分配内存描述符</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1522">15.2.2、撤销内存描述符</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1523mm_struct">15.2.3、mm_struct与内核线程</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#153">15.3、虚拟内存区域</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_28">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1531vma">15.3.1、VMA标志</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1532vma">15.3.2、VMA操作</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1533">15.3.3、内存区域的树型结构和内存区域的链表结构</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1534">15.3.4、实际使用中的内存区域</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#154">15.4、操作内存区域</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1541find_vma">15.4.1、find_vma()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1542find_vma_prev">15.4.2、find_vma_prev()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1543find_vma_intersection">15.4.3、find_vma_intersection()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#155mmapdo_mmap">15.5、mmap和do_mmap：创建地址空间</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#156nummapdo_nummap">15.6、nummap和do_nummap：删除地址区间</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#157">15.7、页表</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#158">15.8、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap16">chap16、页高速缓存和页回写</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#161">16.1、缓存手段</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1611">16.1.1、写缓存</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1612">16.1.2、缓存回收</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#162linux">16.2、Linux页高速缓存</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1621address_space">16.2.1、address_space对象</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1622address_space">16.2.2、address_space操作</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1623">16.2.3、基树</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1624">16.2.4、以前的页散列表</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#163">16.3、缓冲区高速缓存</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#164flusher">16.4、flusher线程</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1641">16.4.1、膝上型计算机模式</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1642bdflushkupdatedpdflush">16.4.2、历史上的bdflush、kupdated和pdflush</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1643">16.4.3、避免拥塞的方法：使用多线程</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#165">16.5、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap17">chap17、设备与模块</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#171">17.1、设备类型</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#172">17.2、模块</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1721helloworld">17.2.1、Hello，World</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1722">17.2.2、构建模块</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1723">17.2.3、安装模块</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1724">17.2.4、产生模块的依赖性</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1725">17.2.5、载入模块</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1726">17.2.6、管理配置选项</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1727">17.2.7、模块参数</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1728">17.2.8、导出符号表</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#173">17.3、设备模型</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_29">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1731kobject">17.3.1、kobject</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1732ktype">17.3.2、ktype</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1733kset">17.3.3、kset</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1734kobjectktypekset">17.3.4、kobject、ktype和kset的相互关系</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1735kobject">17.3.5、管理和操作kobject</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1736">17.3.6、引用计数</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#174sysfs">17.4、sysfs</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#0_30">0、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1741sysfskobject">17.4.1、sysfs中添加和删除kobject</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1742sysfs">17.4.2、向sysfs中添加文件</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1743">17.4.3、内核事件层</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#175">17.5、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap18">chap18、调试</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#181">18.1、准备开始</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#182bug">18.2、内核中的bug</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#183">18.3、通过打印来调试</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1831">18.3.1、健壮性</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1832">18.3.2、日志等级</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1833">18.3.3、记录缓冲区</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1834syslogdklogd">18.3.4、syslogd和klogd</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1835printfprintk">18.3.5、从printf到printk的转换</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#184oops">18.4、oops</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1841ksymoops">18.4.1、ksymoops</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1842kallsyms">18.4.2、kallsyms</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#185">18.5、内核调试配置选项</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#186bug">18.6、引发bug并打印信息</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#187">18.7、神奇的系统请求键</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#188">18.8、内核调试器的传奇</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1881gdb">18.8.1、gdb</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1882kgdb">18.8.2、kgdb</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#189">18.9、探测系统</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1891uid">18.9.1、用UID作为选择条件</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1892">18.9.2、使用条件变量</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1893">18.9.3、使用统计量</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1894">18.9.4、重复频率限制</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1810">18.10、用二分查找法找出引发罪恶的变更</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1811git">18.11、使用Git进行二分搜索</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1812">18.12、当所有的努力都失败时：社区</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1813">18.13、小结</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/">《深入Linux设备驱动程序内核机制》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">《深入理解Linux虚拟内存管理》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《深入理解Linux网络技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90-tcpip%E5%AE%9E%E7%8E%B0/">《Linux内核源代码剖析-TCP/IP实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/">《深入理解Linux内核》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">工具</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/">《Wireshark网络分析实战》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%283rd%29/">《Linux命令行与shell脚本编程大全(3rd)》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%883rd%EF%BC%89/">《python程序设计（3rd）》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">刷题</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../91leetcode/%E5%89%91%E6%8C%87offer2nd/">《剑指offer2nd》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../91leetcode/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/">《剑指offer专项突破》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网课</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/01Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/">《Linux高并发网络编程开发》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/%E4%BE%AF%E6%8D%B7/%E4%BE%AF%E6%8D%B7C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8660%E8%AE%B2/">《侯捷C++内存管理60讲》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/11NJU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">《NJU算法设计与分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">英语专</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../60English/00794%E7%BB%BC%E5%90%88%E8%8B%B1%E8%AF%AD%E4%B8%80%E4%B8%8A/">《综合英语(一)上》</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">lionel的技术笔记</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>内核 &raquo;</li>
      <li>《Linux内核设计与实现》</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h2 id="linux">《Linux内核设计与实现》<a class="headerlink" href="#linux" title="Permanent link">&para;</a></h2>
<h3 id="chap3">chap3、进程管理<a class="headerlink" href="#chap3" title="Permanent link">&para;</a></h3>
<ul>
<li>Linux内核如何管理每个进程：它们在内核中如何被列举，如何创建，最终又如何消亡。</li>
</ul>
<h4 id="31">3.1、进程<a class="headerlink" href="#31" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Linux系统的线程实现非常特别：它对线程和进程并不特别区分</strong>。</li>
<li>在现代操作系统中，进程提供两种虚拟机制：<strong>虚拟处理器和虚拟内存</strong></li>
<li>进程是处于执行期的程序以及相关的资源的总称。</li>
<li>fork()，然后<code>exec()</code>创建新的地址空间，并把新的程序载入其中。<strong>fork()实际是由clone()系统调用实现的</strong>。程序通过exit()系统调用退出执行。父进程通过wait4()系统调用查询子进程是否终结。</li>
</ul>
<h4 id="32">3.2、进程描述符及任务结构<a class="headerlink" href="#32" title="Permanent link">&para;</a></h4>
<ul>
<li>linux/sched.h中的<code>struct task_struct{};</code>，<strong>在32位机器上，它大约有1.7KB</strong>。</li>
<li>任务队列的双向循环链表</li>
<li>进程描述符，包含一个具体进程的所有信息，能完整地描述一个正在执行的程序
    + 它打开的文件
    + 进程的地址空间
    + 挂起的信号
    + 进程的状态
    + 还有其它</li>
</ul>
<h5 id="321">3.2.1、分配进程描述符<a class="headerlink" href="#321" title="Permanent link">&para;</a></h5>
<ul>
<li>Linux通过slab分配器分配task_struct结构，asm/thread_info中的<code>struct thread_info{};</code></li>
<li>每个任务的thread_info结构在它的内核栈的尾端分配。结构中task域中存放的是指向该任务实际task_struct的指针。</li>
</ul>
<h5 id="322">3.2.2、进程描述符的存放<a class="headerlink" href="#322" title="Permanent link">&para;</a></h5>
<ul>
<li>PID的最大默认值设置为32768，linux/threads.h中定义</li>
<li>通过修改<code>/proc/sys/kernel/pid_max</code>来提高上限</li>
<li><strong>通过current宏查找到当前正在运行进程的进程描述符的速度就显得尤为重要</strong>，<code>current_thread_info()</code>实现，不同的平台上有不同的实现。</li>
</ul>
<h5 id="323">3.2.3、进程状态<a class="headerlink" href="#323" title="Permanent link">&para;</a></h5>
<ul>
<li>五大状态
    + 运行
    + 可中断
    + 不可中断
    + 被其他进程跟踪的进程
    + 进程停止执行</li>
</ul>
<h5 id="324">3.2.4、设置当前进程状态<a class="headerlink" href="#324" title="Permanent link">&para;</a></h5>
<ul>
<li><code>set_task_state()</code></li>
<li>linux/sched.h中的实现</li>
</ul>
<h5 id="325">3.2.5、进程上下文<a class="headerlink" href="#325" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>当一个程序调执行了系统调用或者触发了某个异常，它就陷入了内核空间</strong>。此时，我们称内核”代表进程执行“并处于进程上下文中。</li>
</ul>
<h5 id="326">3.2.6、进程家族树<a class="headerlink" href="#326" title="Permanent link">&para;</a></h5>
<ul>
<li>内核在系统启动的最后阶段启动init进程。该进程读取系统的初始化脚本（initscript）并执行其他的相关程序，最终完成系统启动的整个过程。</li>
<li><strong>init进程的进程描述符是作为init_task静态分配的</strong>。</li>
<li><code>list_entry()</code></li>
</ul>
<h4 id="33">3.3、进程创建<a class="headerlink" href="#33" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>产生（spawn）进程的机制：</strong> 首先在新的地址空间里创建进程，读入可执行文件，最后开始执行。</li>
<li>Unix采用了与众不同的实现方式，<strong>把上述步骤分解到两个单独的函数中去执行：fork()和exec()</strong><ul>
<li>fork()</li>
<li>exec()负责读取可执行文件并将其载入地址空间开始运行。</li>
</ul>
</li>
</ul>
<h5 id="331">3.3.1、写时拷贝<a class="headerlink" href="#331" title="Permanent link">&para;</a></h5>
<ul>
<li>传统的fork()系统调用直接把所有的资源复制给新创建的进程。</li>
<li>Linux的fork()使用写时拷贝（copy-on-write）页实现。<strong>写时拷贝是一种可以推迟甚至免除拷贝数据的技术</strong></li>
<li><strong>fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符</strong></li>
</ul>
<h5 id="332fork">3.3.2、fork()<a class="headerlink" href="#332fork" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>Linux通过<code>clone()</code>系统调用实现<code>fork()</code></strong></li>
<li>kernel/fork.c中的<code>do_fork()</code>中的<code>copy_process()</code></li>
<li>copy_process()完成的工作:<ul>
<li>1) 调用dup_task_struct()为新进程创建一个内核栈、thread_info结构和task_struct，这些值与当前进程的值相同。</li>
<li>2) 检查并确保新创建这个子进程后，当前用户所拥有的进程数目没有超出给它分配的资源的限制</li>
<li>7)</li>
<li>8)最后，copy_process()做扫尾工作并返回一个指向子进程的指针</li>
</ul>
</li>
</ul>
<h5 id="333vfork">3.3.3、vfork()<a class="headerlink" href="#333vfork" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>除了不拷贝父进程的页表项外，vfork()系统调用和fork()的功能相同</strong>。</li>
<li>vfork()系统调用的实现是通过向clone()系统调用传递一个特殊标志来进行的
    + 1) 在调用copy_process()时，task_struct的vfork_done成员被置为NULL
    + 5)回到do_fork()，父进程醒来并返回</li>
</ul>
<h4 id="34linux">3.4、线程在linux中的实现<a class="headerlink" href="#34linux" title="Permanent link">&para;</a></h4>
<h5 id="0">0、<a class="headerlink" href="#0" title="Permanent link">&para;</a></h5>
<h5 id="341">3.4.1、创建线程<a class="headerlink" href="#341" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>调用<code>clone()</code>需要传递一些参数标志来指明需要共享的资源</strong></li>
</ul>
<h5 id="342">3.4.2、内核线程<a class="headerlink" href="#342" title="Permanent link">&para;</a></h5>
<ul>
<li>内核线程和普通的进程间的区别在于，<strong>内核线程没有独立的地址空间（实际上指向地址空间的mm指针被设置为NULL）</strong></li>
</ul>
<h4 id="35">3.5、线程终结<a class="headerlink" href="#35" title="Permanent link">&para;</a></h4>
<h5 id="0_1">0、<a class="headerlink" href="#0_1" title="Permanent link">&para;</a></h5>
<ul>
<li>kernel/exit.c中的<code>do_exit()</code></li>
</ul>
<h5 id="351">3.5.1、删除进程描述符<a class="headerlink" href="#351" title="Permanent link">&para;</a></h5>
<ul>
<li>当最终需要释放进程描述符时，<code>release_task()</code>会被调用，完成以下工作：
    + 1、
    + 2、<code>_exit_signal()</code>释放目前僵死进程所使用的所有剩余资源，并进行最终统计和记录</li>
</ul>
<h5 id="352">3.5.2、孤儿进程造成的进退维谷<a class="headerlink" href="#352" title="Permanent link">&para;</a></h5>
<h4 id="36">3.6、小结<a class="headerlink" href="#36" title="Permanent link">&para;</a></h4>
<h3 id="chap4">chap4、进程调度<a class="headerlink" href="#chap4" title="Permanent link">&para;</a></h3>
<h4 id="41">4.1、多任务<a class="headerlink" href="#41" title="Permanent link">&para;</a></h4>
<ul>
<li>多任务系统可以划分为两类：
    + 非抢占式多任务
    + 抢占式多任务：<strong>强制挂起的动作</strong></li>
<li>非抢占式多任务模式下，<strong>进程主动挂起自己的操作称为让步（yielding）</strong></li>
</ul>
<h4 id="42linux">4.2、Linux的进程调度<a class="headerlink" href="#42linux" title="Permanent link">&para;</a></h4>
<h4 id="43">4.3、策略<a class="headerlink" href="#43" title="Permanent link">&para;</a></h4>
<h5 id="431io">4.3.1、I/O消耗型和处理器消耗型的进程<a class="headerlink" href="#431io" title="Permanent link">&para;</a></h5>
<h5 id="432">4.3.2、进程优先级<a class="headerlink" href="#432" title="Permanent link">&para;</a></h5>
<ul>
<li>Linux采用两种不同的优先级范围：
    + 第一种是用nice值
    + 第二种是实时优先级</li>
</ul>
<h5 id="433">4.3.3、时间片<a class="headerlink" href="#433" title="Permanent link">&para;</a></h5>
<h5 id="434">4.3.4、调度策略的活动<a class="headerlink" href="#434" title="Permanent link">&para;</a></h5>
<h4 id="44linux">4.4、Linux调度算法<a class="headerlink" href="#44linux" title="Permanent link">&para;</a></h4>
<h5 id="441">4.4.1、调度器类<a class="headerlink" href="#441" title="Permanent link">&para;</a></h5>
<h5 id="442unix">4.4.2、Unix系统中的进程调度<a class="headerlink" href="#442unix" title="Permanent link">&para;</a></h5>
<h5 id="443">4.4.3、公平调度<a class="headerlink" href="#443" title="Permanent link">&para;</a></h5>
<h4 id="45linux">4.5、Linux调度的实现<a class="headerlink" href="#45linux" title="Permanent link">&para;</a></h4>
<ul>
<li>kernel/sched_fair.c</li>
<li>关注四个组成部分
    + 时间记账
    + 进程选择
    + 调度器入口
    + 睡眠和唤醒</li>
</ul>
<h5 id="451">4.5.1、时间记账<a class="headerlink" href="#451" title="Permanent link">&para;</a></h5>
<ul>
<li>1、调度器实体结构
    + linux/sched.h中的<code>struct sched_entity{};</code></li>
<li>2、虚拟实时</li>
</ul>
<h5 id="452">4.5.2、进程选择<a class="headerlink" href="#452" title="Permanent link">&para;</a></h5>
<h5 id="453">4.5.3、调度器入口<a class="headerlink" href="#453" title="Permanent link">&para;</a></h5>
<ul>
<li>kernel/sched.c中的<code>schedule()</code></li>
</ul>
<h5 id="454">4.5.4、睡眠和唤醒<a class="headerlink" href="#454" title="Permanent link">&para;</a></h5>
<h4 id="46">4.6、抢占和上下文切换<a class="headerlink" href="#46" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>上下文切换</strong>：从一个可执行进程切换到另一个可执行进程，定义在kernel/sched.c中的<code>context_switch()</code>负责，<code>schedule()</code>会调用<code>context_switch()</code>，它完成了两项基本的工作：
    + asm/mmu_context.h中的<code>switch_mm()</code>，把虚拟内存从上一个进程映射切换到新进程中。
    + asm/system.h中的<code>switch_to()</code>，从上一个进程的处理器状态切换到新进程的处理器状态</li>
<li><strong>内核必须知道在什么时候调用schedule()</strong>
    + need_resched标志</li>
</ul>
<h5 id="461">4.6.1、用户抢占<a class="headerlink" href="#461" title="Permanent link">&para;</a></h5>
<ul>
<li>用户抢占在以下情况时产生：
    + 从系统调用返回用户空间时
    + 从中断处理程序返回用户空间时</li>
</ul>
<h5 id="462">4.6.2、内核抢占<a class="headerlink" href="#462" title="Permanent link">&para;</a></h5>
<ul>
<li>内核抢占发生在
    + 中断处理程序正在执行，且返回内核空间之前</li>
</ul>
<h4 id="47">4.7、实时调度策略<a class="headerlink" href="#47" title="Permanent link">&para;</a></h4>
<ul>
<li>Linux提供了两种调度策略：<strong>SCHED_FIFO和SCHED_RR</strong></li>
<li>kernel/sched_rt.c</li>
</ul>
<h4 id="48">4.8、与调度相关的系统调用<a class="headerlink" href="#48" title="Permanent link">&para;</a></h4>
<h5 id="481">4.8.1、与调度策略和优先级相关的系统调用<a class="headerlink" href="#481" title="Permanent link">&para;</a></h5>
<ul>
<li><code>sched_setscheduler()</code></li>
<li><code>sched_setparam()</code>设置进程的实时优先级</li>
</ul>
<h5 id="482">4.8.2、与处理器绑定有关的系统调用<a class="headerlink" href="#482" title="Permanent link">&para;</a></h5>
<ul>
<li><code>sched_getaffinity()</code></li>
</ul>
<h5 id="483">4.8.3、放弃处理器时间<a class="headerlink" href="#483" title="Permanent link">&para;</a></h5>
<ul>
<li>Linux通过<code>sched_yield()</code>，提供了一种让进程显式地将处理器时间让给其他等待执行进程的机制。</li>
<li>内核，可以直接调用yield()，先要确定给定进程确实处于可执行状态，然后再调用<code>sched_yield()</code></li>
<li>用户空间的应用程序直接使用<code>sched_yield()</code>系统调用就可以了</li>
</ul>
<h4 id="49">4.9、小结<a class="headerlink" href="#49" title="Permanent link">&para;</a></h4>
<h3 id="chap5">chap5、系统调用<a class="headerlink" href="#chap5" title="Permanent link">&para;</a></h3>
<h4 id="51">5.1、与内核通信<a class="headerlink" href="#51" title="Permanent link">&para;</a></h4>
<ul>
<li>系统调用在用户空间进程和硬件设备之间添加了一个中间层。<strong>中间层</strong>的3个作用：</li>
</ul>
<h4 id="52apiposixc">5.2、API、POSIX和C库<a class="headerlink" href="#52apiposixc" title="Permanent link">&para;</a></h4>
<ul>
<li>POSIX是个标准</li>
<li>C库：实现了Unix系统的主要API，包括标准C库函数和系统调用接口</li>
<li>接口设计格言：<strong>提供机制而不是策略</strong>，<em>这个没懂，lionel</em></li>
</ul>
<h4 id="53">5.3、系统调用<a class="headerlink" href="#53" title="Permanent link">&para;</a></h4>
<h5 id="0_2">0、<a class="headerlink" href="#0_2" title="Permanent link">&para;</a></h5>
<ul>
<li>系统调用在出现错误的时候C库会把错误码写入errno全局变量。通过调用<code>perror</code>库函数，把该变量翻译成用户可以理解的错误字符串。</li>
<li><code>SYSCALL_DEFINE0</code>-这个在2.6.18里没找到啊，直接在<code>/include/linux/syscalls.h</code>中定义了<code>asmlinkage long sys_getpid(void);</code>，实现怎么在time.c了呢？
    + asmlinkage是个<strong>编译指令</strong>，通知编译器仅从栈中提取该函数的参数
    + 返回值是long的原因，兼容32位和64位
    + 系统调用的命名规则是<code>sys_</code>开头</li>
</ul>
<h5 id="531">5.3.1、系统调用号<a class="headerlink" href="#531" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>进程不会提及系统调用的名称</strong>，通过系统调用号来关联，<strong>一旦分配就不会再有任何变更</strong></li>
<li>所有已经注册过的系统调用的列表，存储在sys_call_table中。<em>2.6里搜了一下在arch/x86_64/kernel/syscall.c</em></li>
<li><em>问题1：何时删除系统调用号呢？ 问题2：系统调用号存在哪？</em></li>
<li>其它
    + <code>sys_ni_syscall()</code></li>
</ul>
<h5 id="532">5.3.2、系统调用的性能<a class="headerlink" href="#532" title="Permanent link">&para;</a></h5>
<h4 id="54">5.4、系统调用处理程序<a class="headerlink" href="#54" title="Permanent link">&para;</a></h4>
<h5 id="0_3">0、<a class="headerlink" href="#0_3" title="Permanent link">&para;</a></h5>
<ul>
<li>通知内核的机制是靠<strong>软中断</strong>实现的：通过引发一个异常</li>
<li>x86系统上预定义的软中断是<strong>中断号128，<code>int $0x80</code>指令</strong>，名称叫<code>system_call()</code></li>
<li>entry_64.S中用汇编编写</li>
<li>sysenter的指令</li>
</ul>
<h5 id="541">5.4.1、指定恰当的系统调用<a class="headerlink" href="#541" title="Permanent link">&para;</a></h5>
<ul>
<li>在x86上，<strong>系统调用号是通过eax寄存器传递给内核的</strong>。<em>eax寄存器是啥？lionel，问题1，什么时候传给eax寄存器的，用什么方式传的？</em></li>
<li><em>表项是64位存放的，所以要乘4，不太懂啥意思，lionel</em></li>
</ul>
<h5 id="542">5.4.2、参数传递<a class="headerlink" href="#542" title="Permanent link">&para;</a></h5>
<ul>
<li>x86-32系统上，<strong>ebx，ecx，edx，esi和edi按照顺序存放前5个参数</strong>。</li>
</ul>
<h4 id="55">5.5、系统调用的实现<a class="headerlink" href="#55" title="Permanent link">&para;</a></h4>
<h5 id="551">5.5.1、实现系统调用<a class="headerlink" href="#551" title="Permanent link">&para;</a></h5>
<ul>
<li><em>通过思考这个过程，去想一下，日常的接口怎么设计？lionel</em></li>
</ul>
<h5 id="552">5.5.2、参数验证<a class="headerlink" href="#552" title="Permanent link">&para;</a></h5>
<ul>
<li><code>copy_from_user()</code>和<code>copy_to_user()</code></li>
<li>书上以<code>kernel/sys.c</code>中的<code>sys_reboot()</code>为例，说了些要注意的权限问题</li>
<li><code>CAP_SYS_BOOT</code>，权限的定义在<code>/include/linux/capability.h</code>中，<em>以CAP开头，是因为capability.h的命名</em></li>
</ul>
<h4 id="56">5.6、系统调用上下文<a class="headerlink" href="#56" title="Permanent link">&para;</a></h4>
<h5 id="0_4">0、<a class="headerlink" href="#0_4" title="Permanent link">&para;</a></h5>
<ul>
<li><em>问题，为何可以休眠，是比较重要的呢</em></li>
</ul>
<h5 id="561">5.6.1、绑定一个系统调用的最后步骤<a class="headerlink" href="#561" title="Permanent link">&para;</a></h5>
<ul>
<li>注册
    + 1、在系统调用表的最后加入一个表项，<code>entry.S</code>
    + 2、支持各种体系结构，系统调用号都必须定义于<code>&lt;asm/unistd.h&gt;</code>
    + 3、<strong>系统调用必须被编译进内核映像（不能被编译成模块）</strong>，放在<code>kernel/</code>下的一个相关文件就可以了，比如sys.c</li>
</ul>
<h5 id="562">5.6.2、从用户空间访问系统调用<a class="headerlink" href="#562" title="Permanent link">&para;</a></h5>
<ul>
<li><code>_syscalln</code>，n的范围是0-6，表示<strong>需要传递给系统调用的参数个数</strong>。</li>
<li><em>lionel，这个没具体看，想实践一下，怎么编进内核，怎么写了跟内核交互，系统调用</em></li>
</ul>
<h5 id="563">5.6.3、为什么不通过系统调用的方式实现<a class="headerlink" href="#563" title="Permanent link">&para;</a></h5>
<ul>
<li>系统调用有好处（创建容易且使用方便，性能高），但有问题：</li>
<li>替代方法：（<em>不太懂</em>）
    + 实现一个设备节点，并对此实现<code>read()</code>和<code>write()</code>
        + 像信号量这样的某些接口
        + 把增加的信息作为一个文件放在sysfs的合适位置</li>
</ul>
<h4 id="57">5.7、小结<a class="headerlink" href="#57" title="Permanent link">&para;</a></h4>
<h3 id="chap6">chap6、内核数据结构<a class="headerlink" href="#chap6" title="Permanent link">&para;</a></h3>
<h4 id="61">6.1、链表<a class="headerlink" href="#61" title="Permanent link">&para;</a></h4>
<h5 id="0_5">0、<a class="headerlink" href="#0_5" title="Permanent link">&para;</a></h5>
<h5 id="611">6.1.1、单向链表和双向链表<a class="headerlink" href="#611" title="Permanent link">&para;</a></h5>
<h5 id="612">6.1.2、环形链表<a class="headerlink" href="#612" title="Permanent link">&para;</a></h5>
<ul>
<li>末尾元素指向链表的首元素，因为<strong>首尾相连</strong>，被称为是环形链表</li>
<li>Linux内核的标准链表就是采用环形双向链表形式实现的</li>
</ul>
<h5 id="613">6.1.3、沿链表移动<a class="headerlink" href="#613" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>只能是线性移动</strong></li>
<li>使用链表存放数据的理想情况是，需要遍历所有数据或需要动态加入和删除数据时。</li>
<li><strong>头指针</strong></li>
</ul>
<h5 id="614linux">6.1.4、Linux内核中的实现<a class="headerlink" href="#614linux" title="Permanent link">&para;</a></h5>
<ul>
<li>0、
    + <strong>linux内核，将链表节点塞入数据结构，不是将数据结构塞入链表</strong>。</li>
<li>1、链表数据结构
    + linux/list.h
    + <strong>理解list_head结构是如何使用的</strong></li>
<li>2、定义一个链表</li>
<li>3、链表头</li>
</ul>
<h5 id="615">6.1.5、操作链表<a class="headerlink" href="#615" title="Permanent link">&para;</a></h5>
<ul>
<li>0、<ul>
<li>都是O(1)</li>
</ul>
</li>
<li>1、向链表中增加一个节点
    + <code>list_add(struct list_head *new, struct list_head *head)</code>
    + <code>list_add_tail(struct list_head *new, struct list_head *head)</code></li>
<li>2、从链表中删除一个节点
    + <code>list_del(struct list_head *entry)</code>
    + <code>list_del_init(struct list_head *entry)</code></li>
<li>3、移动和合并链表节点
    + <code>list_move(struct list_head *new, struct list_head *head)</code>
    + <code>list_move_tail(struct list_head *new, struct list_head *head)</code>
    + <code>list_empty(struct list_head *head)</code>
    + <code>list_splice(struct list_head *list, struct list_head *head)</code>
    + <code>list_splice_init(struct list_head *list, struct list_head *head)</code></li>
</ul>
<h5 id="616">6.1.6、遍历链表<a class="headerlink" href="#616" title="Permanent link">&para;</a></h5>
<ul>
<li>0、<ul>
<li>O(n)</li>
</ul>
</li>
<li>1、基本方法<ul>
<li><code>list_for_each()</code>宏</li>
</ul>
</li>
<li>2、可用的方法<ul>
<li><code>list_for_each_entry()</code>宏</li>
</ul>
</li>
<li>3、反向遍历链表
    + <code>list_for_each_entry_reverse()</code> </li>
<li>4、遍历的同时删除
    + <code>list_for_each_entry_safe()</code></li>
<li>5、其它链表方法</li>
</ul>
<h4 id="62">6.2、队列<a class="headerlink" href="#62" title="Permanent link">&para;</a></h4>
<h5 id="0_6">0、<a class="headerlink" href="#0_6" title="Permanent link">&para;</a></h5>
<ul>
<li><code>linux/kfifo.h</code></li>
</ul>
<h5 id="621kfifo">6.2.1、kfifo<a class="headerlink" href="#621kfifo" title="Permanent link">&para;</a></h5>
<ul>
<li>kfifo对象维护了两个偏移量：入口偏移和出口偏移（<strong>下一次出队列时的位置</strong>）</li>
<li>enqueue</li>
<li>dequeue</li>
</ul>
<h5 id="622">6.2.2、创建队列<a class="headerlink" href="#622" title="Permanent link">&para;</a></h5>
<ul>
<li>动态创建<code>kfifo_alloc()</code></li>
<li>静态创建</li>
</ul>
<h5 id="623">6.2.3、推入队列数据<a class="headerlink" href="#623" title="Permanent link">&para;</a></h5>
<ul>
<li><code>kfifo_in()</code></li>
</ul>
<h5 id="624">6.2.4、摘取队列数据<a class="headerlink" href="#624" title="Permanent link">&para;</a></h5>
<ul>
<li><code>kfifo_out()</code></li>
</ul>
<h5 id="625">6.2.5、获取队列数据<a class="headerlink" href="#625" title="Permanent link">&para;</a></h5>
<ul>
<li><code>kfifo_size()</code></li>
</ul>
<h5 id="626">6.2.6、重置和撤销队列<a class="headerlink" href="#626" title="Permanent link">&para;</a></h5>
<ul>
<li><code>kfifo_reset()</code></li>
</ul>
<h5 id="627">6.2.7、队列使用举例<a class="headerlink" href="#627" title="Permanent link">&para;</a></h5>
<ul>
<li><em>未看，lionel</em></li>
</ul>
<h4 id="63">6.3、映射<a class="headerlink" href="#63" title="Permanent link">&para;</a></h4>
<h5 id="0_7">0、<a class="headerlink" href="#0_7" title="Permanent link">&para;</a></h5>
<h5 id="631idr">6.3.1、初始化一个idr<a class="headerlink" href="#631idr" title="Permanent link">&para;</a></h5>
<h5 id="632uid">6.3.2、分配一个新的UID<a class="headerlink" href="#632uid" title="Permanent link">&para;</a></h5>
<ul>
<li>第一步，告诉idr你需要分配新的UID，允许其在必要时调整后备树的大小</li>
<li>第二步，才是真正请求新的UID</li>
</ul>
<h5 id="633uid">6.3.3、查找UID<a class="headerlink" href="#633uid" title="Permanent link">&para;</a></h5>
<ul>
<li><code>idr_find</code></li>
</ul>
<h5 id="634uid">6.3.4、删除UID<a class="headerlink" href="#634uid" title="Permanent link">&para;</a></h5>
<ul>
<li><code>idr_move</code></li>
</ul>
<h5 id="635idr">6.3.5、撤销idr<a class="headerlink" href="#635idr" title="Permanent link">&para;</a></h5>
<ul>
<li><code>idr_destroy</code></li>
</ul>
<h4 id="64">6.4、二叉树<a class="headerlink" href="#64" title="Permanent link">&para;</a></h4>
<h5 id="641bst">6.4.1、二叉搜索树（BST）<a class="headerlink" href="#641bst" title="Permanent link">&para;</a></h5>
<ul>
<li>BST法则<ul>
<li>根的左分支节点值都小于根节点值</li>
<li>右分支节点值都大于根节点值</li>
<li>所有的子树也都是BST</li>
</ul>
</li>
</ul>
<h5 id="642">6.4.2、自平衡二叉搜索树<a class="headerlink" href="#642" title="Permanent link">&para;</a></h5>
<ul>
<li>0、<ul>
<li><strong>平衡二叉搜索树</strong>是一个所有叶子节点深度差不超过1的二叉搜索树</li>
</ul>
</li>
</ul>
<ul>
<li>1、红黑树<ul>
<li>（1）所有节点要么是黑色，要么是红色</li>
<li>（2）叶子节点都是黑色</li>
<li>（3）叶子节点不包含数据</li>
<li>（4）所有非叶子节点都有两个子节点</li>
<li>（5）如果一个节点是红色，则它的子节点都是黑色</li>
<li>（6）在一个节点到其叶子节点的路径中，如果总是包含同样数目的黑色节点，则该路径相比其他路径是最短的</li>
</ul>
</li>
<li>2、rbtree
    + linux/rbtree.h
    + lib/rbtree.c</li>
</ul>
<h4 id="65">6.5、数据结构以及选择<a class="headerlink" href="#65" title="Permanent link">&para;</a></h4>
<ul>
<li>遍历数据，就使用链表</li>
<li>如果需要存储大量数据，并且检索迅速，那么红黑树最好</li>
</ul>
<h4 id="66">6.6、算法复杂度<a class="headerlink" href="#66" title="Permanent link">&para;</a></h4>
<h5 id="661">6.6.1、算法<a class="headerlink" href="#661" title="Permanent link">&para;</a></h5>
<h5 id="662o">6.6.2、大O符号<a class="headerlink" href="#662o" title="Permanent link">&para;</a></h5>
<h5 id="663xita">6.6.3、大xita符号<a class="headerlink" href="#663xita" title="Permanent link">&para;</a></h5>
<h5 id="664">6.6.4、时间复杂度<a class="headerlink" href="#664" title="Permanent link">&para;</a></h5>
<h4 id="67">6.7、小结<a class="headerlink" href="#67" title="Permanent link">&para;</a></h4>
<h3 id="chap7">chap7、中断和中断处理<a class="headerlink" href="#chap7" title="Permanent link">&para;</a></h3>
<ul>
<li>让硬件在需要的时候再向内核发出信号，<strong>这就是中断</strong></li>
</ul>
<h4 id="71">7.1、中断<a class="headerlink" href="#71" title="Permanent link">&para;</a></h4>
<ul>
<li>中断使得硬件得以发出通知给处理器</li>
<li><strong>中断值通常被称为中断请求（IRQ）线</strong>。</li>
<li><strong>异常</strong>
    + 异常也常常称为同步中断。</li>
</ul>
<h4 id="72">7.2、中断处理程序<a class="headerlink" href="#72" title="Permanent link">&para;</a></h4>
<ul>
<li>中断处理程序（interrupt handler）、中断服务例程（interrupt service routine）</li>
</ul>
<h4 id="73">7.3、上半部和下半部的对比<a class="headerlink" href="#73" title="Permanent link">&para;</a></h4>
<ul>
<li>中断处理程序是上半部（top half）-接收到一个中断，它就立即开始执行，但只做有严格时限的工作。</li>
<li><strong>能够被允许稍后完成的工作会推迟到下半部（bottom half）</strong></li>
</ul>
<h4 id="74">7.4、注册中断处理程序<a class="headerlink" href="#74" title="Permanent link">&para;</a></h4>
<ul>
<li>linux/interrupt.h中的<code>request_irq()</code>注册一个中断处理程序</li>
</ul>
<h5 id="741">7.4.1、中断处理程序标志<a class="headerlink" href="#741" title="Permanent link">&para;</a></h5>
<ul>
<li>第3个参数：
    + IRQF_DISABLED</li>
<li>第4个参数：name，是与中断相关的设备的ASCII文本表示</li>
<li>第5个参数：dev，用于共享中断线</li>
</ul>
<h5 id="742">7.4.2、一个中断例子<a class="headerlink" href="#742" title="Permanent link">&para;</a></h5>
<h5 id="743">7.4.3、释放中断处理程序<a class="headerlink" href="#743" title="Permanent link">&para;</a></h5>
<ul>
<li><code>free_irq()</code></li>
</ul>
<h4 id="75">7.5、编写中断处理程序<a class="headerlink" href="#75" title="Permanent link">&para;</a></h4>
<ul>
<li><code>static irqreturn_t intr_handler(int irq, void *dev)</code></li>
</ul>
<h5 id="751">7.5.1、共享的中断处理程序<a class="headerlink" href="#751" title="Permanent link">&para;</a></h5>
<h5 id="752">7.5.2、中断处理程序实例<a class="headerlink" href="#752" title="Permanent link">&para;</a></h5>
<h4 id="76">7.6、中断上下文<a class="headerlink" href="#76" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>进程上下文</strong>是一种内核所处的操作模式</li>
</ul>
<h4 id="77">7.7、中断处理机制的实现<a class="headerlink" href="#77" title="Permanent link">&para;</a></h4>
<h4 id="78procinterrupts">7.8、/proc/interrupts<a class="headerlink" href="#78procinterrupts" title="Permanent link">&para;</a></h4>
<ul>
<li><code>show_interrupts()</code> </li>
</ul>
<h4 id="79">7.9、中断控制<a class="headerlink" href="#79" title="Permanent link">&para;</a></h4>
<h5 id="791">7.9.1、禁止和激活中断<a class="headerlink" href="#791" title="Permanent link">&para;</a></h5>
<h5 id="792">7.9.2、禁止指定中断线<a class="headerlink" href="#792" title="Permanent link">&para;</a></h5>
<h5 id="793">7.9.3、中断系统的状态<a class="headerlink" href="#793" title="Permanent link">&para;</a></h5>
<ul>
<li>asm/system.h中的宏<code>irqs_disable()</code></li>
<li>linux/hardirq.h中的<code>in_interrupt()</code></li>
</ul>
<h4 id="710">7.10、小结<a class="headerlink" href="#710" title="Permanent link">&para;</a></h4>
<h3 id="chap8">chap8、下半部和推后执行的工作<a class="headerlink" href="#chap8" title="Permanent link">&para;</a></h3>
<ul>
<li>局限包括：
    + 1、中断处理程序以异步方式执行</li>
</ul>
<h4 id="81">8.1、下半部<a class="headerlink" href="#81" title="Permanent link">&para;</a></h4>
<h5 id="0_8">0、<a class="headerlink" href="#0_8" title="Permanent link">&para;</a></h5>
<ul>
<li>下半部的任务：<strong>执行与中断处理密切相关但中断处理程序本身不执行的工作</strong>。</li>
</ul>
<h5 id="811">8.1.1、为什么要用下半部<a class="headerlink" href="#811" title="Permanent link">&para;</a></h5>
<h5 id="812">8.1.2、下半部的环境<a class="headerlink" href="#812" title="Permanent link">&para;</a></h5>
<ul>
<li>1、”下半部“的起源</li>
<li>2、任务队列</li>
<li>3、软中断和tasklet</li>
<li>4、混乱的下半部概念</li>
</ul>
<h4 id="82">8.2、软中断<a class="headerlink" href="#82" title="Permanent link">&para;</a></h4>
<ul>
<li>kernel/softirq.c</li>
</ul>
<h5 id="821">8.2.1、软中断的实现<a class="headerlink" href="#821" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>软中断</strong>是编译期间静态分配的。linux/interrupt.h中的<code>softirq_action{};</code></li>
<li>1、软中断处理程序</li>
<li>2、执行软中断</li>
</ul>
<h5 id="822">8.2.2、使用软中断<a class="headerlink" href="#822" title="Permanent link">&para;</a></h5>
<ul>
<li>1、分配索引</li>
<li>2、注册你的处理程序</li>
<li>3、触发你的软中断</li>
</ul>
<h4 id="83tasklet">8.3、tasklet<a class="headerlink" href="#83tasklet" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>tasklet是利用软中断实现的一种下半部机制</strong>。</li>
</ul>
<h5 id="831tasklet">8.3.1、tasklet的实现<a class="headerlink" href="#831tasklet" title="Permanent link">&para;</a></h5>
<ul>
<li>1、tasklet结构体</li>
<li>2、调度tasklet</li>
</ul>
<h5 id="832tasklet">8.3.2、使用tasklet<a class="headerlink" href="#832tasklet" title="Permanent link">&para;</a></h5>
<ul>
<li>1、声明你自己的tasklet</li>
<li>2、编写你自己的tasklet处理程序</li>
<li>3、调度你自己的tasklet</li>
<li>4、ksoftirqd</li>
</ul>
<h5 id="833bh">8.3.3、老的BH机制<a class="headerlink" href="#833bh" title="Permanent link">&para;</a></h5>
<ul>
<li>2.6已经废弃</li>
</ul>
<h4 id="84">8.4、工作队列<a class="headerlink" href="#84" title="Permanent link">&para;</a></h4>
<h5 id="0_9">0、<a class="headerlink" href="#0_9" title="Permanent link">&para;</a></h5>
<h5 id="841">8.4.1、工作队列的实现<a class="headerlink" href="#841" title="Permanent link">&para;</a></h5>
<ul>
<li>1、表示线程的数据结构
    + 工作者线程用<code>struct workqueue_struct{};</code></li>
<li>2、表示工作的数据结构
    + linux/workqueue.h中的<code>struct work_struct{};</code></li>
</ul>
<h5 id="842">8.4.2、使用工作队列<a class="headerlink" href="#842" title="Permanent link">&para;</a></h5>
<ul>
<li>1、创建推后的工作</li>
<li>2、工作队列处理函数</li>
<li>3、对工作进行调度</li>
<li>4、刷新操作</li>
<li>5、创建新的工作队列</li>
</ul>
<h5 id="843">8.4.3、老的任务队列机制<a class="headerlink" href="#843" title="Permanent link">&para;</a></h5>
<h4 id="85">8.5、下半部机制的选择<a class="headerlink" href="#85" title="Permanent link">&para;</a></h4>
<ul>
<li>tasklet和软中断，两者很接近。<strong>工作队列，靠内核线程实现</strong></li>
</ul>
<h4 id="86">8.6、在下半部之间加锁<a class="headerlink" href="#86" title="Permanent link">&para;</a></h4>
<ul>
<li>任何在工作队列中被共享的数据也需要使用锁机制。</li>
</ul>
<h4 id="87">8.7、禁止下半部<a class="headerlink" href="#87" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>先得到一个锁然后再禁止下半部的处理</strong>。</li>
<li>如果需要禁止所有的下半部处理（明确点说，就是所有软中断和所有tasklet），可以调用<code>local_bh_disable()</code>。</li>
<li>由于软中断和tasklet是异步发生的（就是说，在中断处理返回的时候），所以，内核代码必须禁止它们。</li>
</ul>
<h4 id="88">8.8、小结<a class="headerlink" href="#88" title="Permanent link">&para;</a></h4>
<ul>
<li>下半部中相当程度地用到了同步和并发。</li>
</ul>
<h3 id="chap9">chap9、内核同步介绍<a class="headerlink" href="#chap9" title="Permanent link">&para;</a></h3>
<h4 id="91">9.1、临界区和竞争条件<a class="headerlink" href="#91" title="Permanent link">&para;</a></h4>
<h5 id="0_10">0、<a class="headerlink" href="#0_10" title="Permanent link">&para;</a></h5>
<ul>
<li>临界区<ul>
<li>访问和操作共享数据的代码段</li>
</ul>
</li>
<li>竞争条件race coditions<ul>
<li>如果两个执行线程有可能处于同一个临界区中同时执行，那么这就是程序包含的一个bug。<strong>这种情况发生了</strong>，称它为竞争条件</li>
</ul>
</li>
</ul>
<h5 id="911">9.1.1、为什么我们需要保护<a class="headerlink" href="#911" title="Permanent link">&para;</a></h5>
<ul>
<li><em>以取钱为例</em></li>
</ul>
<h5 id="912">9.1.2、单个变量<a class="headerlink" href="#912" title="Permanent link">&para;</a></h5>
<h4 id="92">9.2、加锁<a class="headerlink" href="#92" title="Permanent link">&para;</a></h4>
<h5 id="0_11">0、<a class="headerlink" href="#0_11" title="Permanent link">&para;</a></h5>
<ul>
<li><em>lionel，没太看懂啊</em></li>
</ul>
<h5 id="921">9.2.1、造成并发执行的原因<a class="headerlink" href="#921" title="Permanent link">&para;</a></h5>
<ul>
<li>内核中有类似可能造成并发执行的原因。它们是
    + 中断
    + 软中断和tasklet
    + 内核抢占
    + 睡眠及与用户空间的同步
    + 对称多处理</li>
</ul>
<h5 id="922">9.2.2、了解要保护些什么<a class="headerlink" href="#922" title="Permanent link">&para;</a></h5>
<h4 id="93">9.3、死锁<a class="headerlink" href="#93" title="Permanent link">&para;</a></h4>
<h4 id="94">9.4、争用和扩展性<a class="headerlink" href="#94" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>锁的争用（争用）lock contention</strong>，是指当锁正在被占用时，有其他线程试图获得该锁。</li>
</ul>
<h4 id="95">9.5、小结<a class="headerlink" href="#95" title="Permanent link">&para;</a></h4>
<h3 id="chap10-158353">chap10、内核同步方法 （158/353）<a class="headerlink" href="#chap10-158353" title="Permanent link">&para;</a></h3>
<h4 id="101">10.1、原子操作<a class="headerlink" href="#101" title="Permanent link">&para;</a></h4>
<h5 id="1011">10.1.1、原子整数操作<a class="headerlink" href="#1011" title="Permanent link">&para;</a></h5>
<ul>
<li>linux/types.h中<code>atomic_t</code>类型，占用32位中的24位。</li>
</ul>
<h5 id="101264">10.1.2、64位原子操作<a class="headerlink" href="#101264" title="Permanent link">&para;</a></h5>
<ul>
<li><code>atomic64_t</code>类型</li>
</ul>
<h5 id="1013">10.1.3、原子位操作<a class="headerlink" href="#1013" title="Permanent link">&para;</a></h5>
<ul>
<li>asm/bitops.h</li>
</ul>
<h4 id="102">10.2、自旋锁<a class="headerlink" href="#102" title="Permanent link">&para;</a></h4>
<h5 id="0_12">0、<a class="headerlink" href="#0_12" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>自旋锁（spin lock）最多只能被一个可执行线程持有</strong>，浪费处理器时间</li>
</ul>
<h5 id="1021">10.2.1、自旋锁方法<a class="headerlink" href="#1021" title="Permanent link">&para;</a></h5>
<ul>
<li>asm/spinlock.h或linux/spinlock.h</li>
</ul>
<h5 id="1022">10.2.2、其他针对自旋锁的操作<a class="headerlink" href="#1022" title="Permanent link">&para;</a></h5>
<ul>
<li><code>spin_lock_init()</code>初始化动态创建的自旋锁</li>
</ul>
<h5 id="1023">10.2.3、自旋锁和下半部<a class="headerlink" href="#1023" title="Permanent link">&para;</a></h5>
<h4 id="103-">10.3、读写-自旋锁<a class="headerlink" href="#103-" title="Permanent link">&para;</a></h4>
<h4 id="104">10.4、信号量<a class="headerlink" href="#104" title="Permanent link">&para;</a></h4>
<h5 id="0_13">0、<a class="headerlink" href="#0_13" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>睡眠锁</strong>，信号量会将其推进一个等待队列，然后让其睡眠。</li>
</ul>
<h5 id="1041">10.4.1、计数信号量和二值信号量<a class="headerlink" href="#1041" title="Permanent link">&para;</a></h5>
<h5 id="1042">10.4.2、创建和初始化信号量<a class="headerlink" href="#1042" title="Permanent link">&para;</a></h5>
<ul>
<li>asm/semaphore.h</li>
</ul>
<h5 id="1043">10.4.3、使用信号量<a class="headerlink" href="#1043" title="Permanent link">&para;</a></h5>
<h4 id="105-">10.5、读写-信号量<a class="headerlink" href="#105-" title="Permanent link">&para;</a></h4>
<ul>
<li>linux/rwsem.h</li>
</ul>
<h4 id="106">10.6、互斥体<a class="headerlink" href="#106" title="Permanent link">&para;</a></h4>
<h5 id="0_14">0、<a class="headerlink" href="#0_14" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>互斥体是一种互斥信号</strong></li>
</ul>
<h5 id="1061">10.6.1、信号量和互斥体<a class="headerlink" href="#1061" title="Permanent link">&para;</a></h5>
<h5 id="1062">10.6.2、自旋锁和互斥体<a class="headerlink" href="#1062" title="Permanent link">&para;</a></h5>
<h4 id="107">10.7、完成变量<a class="headerlink" href="#107" title="Permanent link">&para;</a></h4>
<ul>
<li>linux/completion.h中<code>DECLARE_COMPLETION(mr_comp);</code></li>
<li><code>init_completion()</code></li>
</ul>
<h4 id="108blk">10.8、BLK：大内核锁<a class="headerlink" href="#108blk" title="Permanent link">&para;</a></h4>
<ul>
<li>linux/smp_lock.h</li>
</ul>
<h4 id="109">10.9、顺序锁<a class="headerlink" href="#109" title="Permanent link">&para;</a></h4>
<ul>
<li><code>seqlock_t</code></li>
</ul>
<h4 id="1010">10.10、禁止抢占<a class="headerlink" href="#1010" title="Permanent link">&para;</a></h4>
<h4 id="1011_1">10.11、顺序和屏障<a class="headerlink" href="#1011_1" title="Permanent link">&para;</a></h4>
<h4 id="1012">10.12、小结<a class="headerlink" href="#1012" title="Permanent link">&para;</a></h4>
<h3 id="chap11183353">chap11、定时器和时间管理（183/353）<a class="headerlink" href="#chap11183353" title="Permanent link">&para;</a></h3>
<h4 id="111">11.1、内核中的时间概念<a class="headerlink" href="#111" title="Permanent link">&para;</a></h4>
<h4 id="112hz">11.2、节拍率：HZ<a class="headerlink" href="#112hz" title="Permanent link">&para;</a></h4>
<h5 id="0_15">0、<a class="headerlink" href="#0_15" title="Permanent link">&para;</a></h5>
<ul>
<li>asm/param.h</li>
</ul>
<h5 id="1121hz">11.2.1、理想的HZ值<a class="headerlink" href="#1121hz" title="Permanent link">&para;</a></h5>
<h5 id="1122hz">11.2.2、高HZ的优势<a class="headerlink" href="#1122hz" title="Permanent link">&para;</a></h5>
<h5 id="1123hz">11.2.3、高HZ的劣势<a class="headerlink" href="#1123hz" title="Permanent link">&para;</a></h5>
<h4 id="113jiffies">11.3、jiffies<a class="headerlink" href="#113jiffies" title="Permanent link">&para;</a></h4>
<h5 id="0_16">0、<a class="headerlink" href="#0_16" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>全局变量jiffies用来记录自系统启动以来产生的节拍的总数</strong>。</li>
<li>linux/jiffies.h中的<code>extern unsigned long volatile jiffies;</code></li>
</ul>
<h5 id="1131jiffies">11.3.1、jiffies的内部表示<a class="headerlink" href="#1131jiffies" title="Permanent link">&para;</a></h5>
<h5 id="1132jiffies">11.3.2、jiffies的回绕<a class="headerlink" href="#1132jiffies" title="Permanent link">&para;</a></h5>
<h5 id="1133hz">11.3.3、用户空间和HZ<a class="headerlink" href="#1133hz" title="Permanent link">&para;</a></h5>
<h4 id="114">11.4、硬时钟和定时器<a class="headerlink" href="#114" title="Permanent link">&para;</a></h4>
<h5 id="1141">11.4.1、实时时钟<a class="headerlink" href="#1141" title="Permanent link">&para;</a></h5>
<ul>
<li>实时时钟（RTC）是用来持久存放系统时间的设备。<strong>靠主板上的微型电池</strong></li>
</ul>
<h5 id="1142">11.4.2、系统定时器<a class="headerlink" href="#1142" title="Permanent link">&para;</a></h5>
<h4 id="115">11.5、时钟中断处理程序<a class="headerlink" href="#115" title="Permanent link">&para;</a></h4>
<h4 id="116">11.6、实际时间<a class="headerlink" href="#116" title="Permanent link">&para;</a></h4>
<ul>
<li>kernel/time/timekeeping.c中的<code>struct timespec xtime;</code></li>
</ul>
<h4 id="117">11.7、定时器<a class="headerlink" href="#117" title="Permanent link">&para;</a></h4>
<h5 id="0_17">0、<a class="headerlink" href="#0_17" title="Permanent link">&para;</a></h5>
<h5 id="1171">11.7.1、使用定时器<a class="headerlink" href="#1171" title="Permanent link">&para;</a></h5>
<ul>
<li>linux/timer.h</li>
</ul>
<h5 id="1172">11.7.2、定时器竞争条件<a class="headerlink" href="#1172" title="Permanent link">&para;</a></h5>
<h5 id="1173">11.7.3、实现定时器<a class="headerlink" href="#1173" title="Permanent link">&para;</a></h5>
<h4 id="118">11.8、延迟执行<a class="headerlink" href="#118" title="Permanent link">&para;</a></h4>
<h5 id="1181">11.8.1、忙等待<a class="headerlink" href="#1181" title="Permanent link">&para;</a></h5>
<h5 id="1182">11.8.2、短延迟<a class="headerlink" href="#1182" title="Permanent link">&para;</a></h5>
<ul>
<li>linux/delay.h和asm/delay.h中，<strong>处理ms、ns和ms级别的延迟函数</strong>，<code>void udelay(unsigned long usecs);</code></li>
</ul>
<h5 id="1183schedule-timeout">11.8.3、schedule timeout()<a class="headerlink" href="#1183schedule-timeout" title="Permanent link">&para;</a></h5>
<ul>
<li>1、schedule timeout()的实现</li>
<li>2、设置好超时时间，在等待队列上睡眠</li>
</ul>
<h4 id="119">11.9、小结<a class="headerlink" href="#119" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>只要你编写驱动程序，就需要处理内核定时器</strong></li>
</ul>
<h3 id="chap12">chap12、内存管理<a class="headerlink" href="#chap12" title="Permanent link">&para;</a></h3>
<h4 id="121">12.1、页<a class="headerlink" href="#121" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>MMU</strong>（是硬件），以页为单位进行处理。</li>
<li>大多数32位体系结构支持4KB的页，而64位体系结构一般会支持8KB的页。</li>
<li><code>struct page{};</code>，include/linux/mm.h</li>
<li><strong>page结构与物理页相关，而并非与虚拟页相关</strong>。</li>
</ul>
<h4 id="122">12.2、区<a class="headerlink" href="#122" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>内核把页划分为不同的区（zone）</strong>,Linux主要使用了四种区:
    + ZONE_DMA
    + ZONE_DMA32
    + ZONE_NORMAL
    + ZONE_HGHEM</li>
<li><code>struct zone {};</code></li>
</ul>
<h4 id="123">12.3、获得页<a class="headerlink" href="#123" title="Permanent link">&para;</a></h4>
<h5 id="0_18">0、<a class="headerlink" href="#0_18" title="Permanent link">&para;</a></h5>
<ul>
<li><code>alloc_pages()</code></li>
<li><code>page_address()</code></li>
</ul>
<h5 id="12310">12.3.1、获得填充为0的页<a class="headerlink" href="#12310" title="Permanent link">&para;</a></h5>
<ul>
<li><code>get_zeroed_page()</code></li>
</ul>
<h5 id="1232">12.3.2、释放页<a class="headerlink" href="#1232" title="Permanent link">&para;</a></h5>
<ul>
<li><code>free_page()</code></li>
<li><strong>内核是完全相信自己的</strong></li>
</ul>
<h4 id="124kmalloc">12.4、kmalloc<a class="headerlink" href="#124kmalloc" title="Permanent link">&para;</a></h4>
<h5 id="0_19">0、<a class="headerlink" href="#0_19" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>以字节为单位，确保页在物理地址上是连续的</strong>，实现在include/linux/slab.h中</li>
</ul>
<h5 id="1241gfp_mask">12.4.1、gfp_mask标志<a class="headerlink" href="#1241gfp_mask" title="Permanent link">&para;</a></h5>
<p>标志分为<strong>3种</strong></p>
<ul>
<li>1、行为修饰符<ul>
<li>内存应当如何分配所需的内存</li>
</ul>
</li>
<li>2、区修饰符<ul>
<li>表示从哪儿分配内存</li>
</ul>
</li>
<li>3、类型标志<ul>
<li>组合了行为修饰符和区修饰符</li>
</ul>
</li>
</ul>
<h5 id="1242kfree">12.4.2、kfree<a class="headerlink" href="#1242kfree" title="Permanent link">&para;</a></h5>
<ul>
<li><code>void kfree(const void *ptr);</code></li>
</ul>
<h4 id="125vmalloc">12.5、vmalloc<a class="headerlink" href="#125vmalloc" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>分配的内存虚拟地址是连续的，而物理地址无须连续</strong></li>
<li>vmalloc()函数为了把物理上不连续的页转称为虚拟地址空间上连续的页，必须专门建立页表项，糟糕的是，通过vmalloc()获得的页必须一个个地进行映射（因为它们物理上是不连续的），这就会导致比直接内存映射大得多的TLB抖动。<strong>vmalloc()仅在不得已时才会使用</strong></li>
</ul>
<h4 id="126slab">12.6、slab层<a class="headerlink" href="#126slab" title="Permanent link">&para;</a></h4>
<h5 id="0_20">0、<a class="headerlink" href="#0_20" title="Permanent link">&para;</a></h5>
<ul>
<li>slab分配器扮演了通用数据结构缓存层的角色</li>
</ul>
<h5 id="1261slab">12.6.1、slab层的设计<a class="headerlink" href="#1261slab" title="Permanent link">&para;</a></h5>
<ul>
<li>slab层把不同对象划分为所谓的高速缓存组，slab由一个或多个物理上连续的页组成</li>
<li>每个高速缓存都使用kmem_cache结构来表示。(mm/slab.c中定义)，该结构包含三个链表：slabs_full, slabs_partial和slabs_empty，均存放在kmem_list3结构内。</li>
</ul>
<h5 id="1262slab">12.6.2、slab分配器的接口<a class="headerlink" href="#1262slab" title="Permanent link">&para;</a></h5>
<ul>
<li>0、<ul>
<li><code>kmem_cache_create()</code></li>
<li>撤销一个高速缓存，<code>int kmem_cache_destroy(struct kmem_cache *cachep)</code></li>
</ul>
</li>
<li>1、从缓存中分配</li>
<li>2、slab分配器的使用实例</li>
</ul>
<h4 id="127">12.7、在栈上的静态分配<a class="headerlink" href="#127" title="Permanent link">&para;</a></h4>
<h5 id="0_21">0、<a class="headerlink" href="#0_21" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>32位和64位体系结构的页面大小分别是4KB和8KB，所以通常它们的内核栈的大小分别是8KB和16KB</strong>。</li>
</ul>
<h5 id="1271">12.7.1、单页内核栈<a class="headerlink" href="#1271" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>中断栈</strong></li>
</ul>
<h5 id="1272">12.7.2、在栈上光明正大地工作<a class="headerlink" href="#1272" title="Permanent link">&para;</a></h5>
<h4 id="128">12.8、高端内存的映射<a class="headerlink" href="#128" title="Permanent link">&para;</a></h4>
<h5 id="0_22">0、<a class="headerlink" href="#0_22" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>在高端内存中的页不能永久地映射到内核地址空间上</strong>。</li>
<li>x86体系结构上，高于896MB的所有物理内存的范围大都是高端内存</li>
</ul>
<h5 id="1281">12.8.1、永久映射<a class="headerlink" href="#1281" title="Permanent link">&para;</a></h5>
<ul>
<li>linux/highmem.h</li>
<li><code>void *kmap(struct page *page)</code></li>
<li><code>void *kunmap(struct page *page)</code></li>
</ul>
<h5 id="1282">12.8.2、临时映射<a class="headerlink" href="#1282" title="Permanent link">&para;</a></h5>
<ul>
<li><code>void *kmap_atomic(struct page *page, enum km_type type)</code></li>
</ul>
<h4 id="129cpu">12.9、每个CPU的分配<a class="headerlink" href="#129cpu" title="Permanent link">&para;</a></h4>
<ul>
<li>每个CPU的数据存放在一个数组中。</li>
<li>内核抢占会引起下面提及的两个问题：
    + 如果你的代码被其他
    + 如果另一个</li>
</ul>
<h4 id="1210cpu">12.10、新的每个CPU接口<a class="headerlink" href="#1210cpu" title="Permanent link">&para;</a></h4>
<h5 id="0_23">0、<a class="headerlink" href="#0_23" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>percpu</strong>，简化了创建和操作每个CPU的数据。</li>
<li>linux/percpu.h</li>
</ul>
<h5 id="12101cpu">12.10.1、编译时的每个CPU数据<a class="headerlink" href="#12101cpu" title="Permanent link">&para;</a></h5>
<h5 id="12102cpu">12.10.2、运行时的每个CPU数据<a class="headerlink" href="#12102cpu" title="Permanent link">&para;</a></h5>
<h4 id="1211cpu">12.11、使用每个CPU数据的原因<a class="headerlink" href="#1211cpu" title="Permanent link">&para;</a></h4>
<ul>
<li>首先，<strong>减少了数据锁定</strong></li>
<li>第二个好处，<strong>使用每个CPU数据可以大大减少缓存失效</strong></li>
</ul>
<h4 id="1212">12.12、分配函数的选择<a class="headerlink" href="#1212" title="Permanent link">&para;</a></h4>
<ul>
<li>连续的物理页：<strong>使用某个低级页分配器或kmalloc()</strong>
    + GFP_ATOMIC：进行不睡眠的高优先级分配
    + GFP_KERNEL：如果有必要，进程可以睡眠</li>
<li>不需要物理上连续的页，<strong>仅仅需要虚拟地址上连续的页</strong>，就使用vmalloc 【<strong>vmalloc相对kmalloc，有一定的性能损失</strong>】，把物理内存块映射到连续的逻辑地址空间上。</li>
<li>如果你想从高端内存进行分配，使用alloc_pages()。<strong>为了获得真正的指针，应该调用kmap()，把高端内存映射到内核的逻辑地址空间</strong>。</li>
<li>创建和撤销很多大的数据结构，考虑建立<strong>slab高速缓存</strong>。slab层会给每个处理器维持一个对象高速缓存（空闲链表），这种高速缓存会极大地提高对象分配和回收的性能。<strong>为你把事先分配好的对象存放到高速缓存中</strong></li>
</ul>
<h4 id="1213">12.13、小结<a class="headerlink" href="#1213" title="Permanent link">&para;</a></h4>
<ul>
<li>在内核中分配内存并非总是轻而易举，因为你必须小心地<strong>确保分配过程遵从内核特定的状态约束</strong>。</li>
<li><strong>分配内存相对复杂</strong>是内核开发和用户开发的最大区别之一。</li>
</ul>
<h3 id="chap13">chap13、虚拟文件系统<a class="headerlink" href="#chap13" title="Permanent link">&para;</a></h3>
<h4 id="131">13.1、通用文件系统接口<a class="headerlink" href="#131" title="Permanent link">&para;</a></h4>
<h4 id="132">13.2、文件系统抽象层<a class="headerlink" href="#132" title="Permanent link">&para;</a></h4>
<h4 id="133unix">13.3、Unix文件系统<a class="headerlink" href="#133unix" title="Permanent link">&para;</a></h4>
<ul>
<li>4种与文件系统相关的传统抽象概念<ul>
<li>文件：可以看作有序的字节串（unix把目录也看作文件）</li>
<li>目录项：路径中的每一部分称作<strong>目录条目</strong>，也叫<strong>目录项</strong></li>
<li>索引节点：文件信息按照索引形式存储在单独的块中，<strong>控制信息存储在超级块中</strong>。</li>
<li>安装点（mount point）</li>
</ul>
</li>
<li>文件的相关信息和文件本身是两个概念，<strong>文件的元数据</strong>（文件的相关信息）被存储在一个单独的数据结构中，被称为索引节点（inode）。</li>
</ul>
<h4 id="134vfs">13.4、VFS对象及其数据结构<a class="headerlink" href="#134vfs" title="Permanent link">&para;</a></h4>
<ul>
<li>VFS采用<strong>面向对象</strong>的设计原理，不过是用C语言实现的</li>
<li>VFS中有四个主要的对象类型：（这里对象是指<strong>结构体</strong>）<ul>
<li>超级块对象：代表一个具体的已安装文件系统<ul>
<li>super_operations</li>
</ul>
</li>
<li>索引节点对象：代表一个具体文件<ul>
<li>inode_operations</li>
</ul>
</li>
<li>目录项对象：代表一个目录项，是路径的一个组成部分<ul>
<li>dentry_operations</li>
</ul>
</li>
<li>文件对象：代表由进程打开的文件<ul>
<li>file_operations</li>
</ul>
</li>
</ul>
</li>
<li>每个主要对象都包含一个<strong>操作对象</strong>，操作对象作为一个结构体指针来实现的</li>
</ul>
<h4 id="135">13.5、超级块对象<a class="headerlink" href="#135" title="Permanent link">&para;</a></h4>
<ul>
<li><code>struct super_block{};</code>这个定义在linux/fs.h</li>
<li><strong>创建、管理和撤销超级块对象</strong>代码位于fs/super.c</li>
</ul>
<h4 id="136">13.6、超级块操作<a class="headerlink" href="#136" title="Permanent link">&para;</a></h4>
<ul>
<li>最重要的一个域<code>s_op</code></li>
</ul>
<h4 id="137">13.7、索引节点对象<a class="headerlink" href="#137" title="Permanent link">&para;</a></h4>
<ul>
<li><em>lionel，Q1，是不是每个文件都有inode?</em></li>
<li><strong>没有索引节点的文件系统通常将文件的描述信息作为文件的一部分来存放</strong></li>
<li>linux/fs.h中的</li>
<li>一个索引节点代表文件系统中的一个文件，也可以是特殊文件</li>
</ul>
<h4 id="138">13.8、索引节点操作<a class="headerlink" href="#138" title="Permanent link">&para;</a></h4>
<ul>
<li>i指向给定的索引节点，<code>truncate()</code>是由索引节点i所在的文件系统定义的</li>
</ul>
<h4 id="139">13.9、目录项对象<a class="headerlink" href="#139" title="Permanent link">&para;</a></h4>
<h5 id="0_24">0、<a class="headerlink" href="#0_24" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>为了便于查找操作</strong>，引入了目录项，每个dentry代表路径中的一个特定部分</li>
<li><strong>目录项，也可包括安装点</strong>，linux/dcache.h中，即dentry cache</li>
<li>目录项对象并非真正保存在磁盘上，所以目录项结构体没有是否被修改的标志</li>
</ul>
<h5 id="1391">13.9.1、目录项状态<a class="headerlink" href="#1391" title="Permanent link">&para;</a></h5>
<ul>
<li>3种状态<ul>
<li>被使用</li>
<li>未被使用</li>
<li>负状态</li>
</ul>
</li>
</ul>
<h5 id="1392">13.9.2、目录项缓存<a class="headerlink" href="#1392" title="Permanent link">&para;</a></h5>
<ul>
<li>包括3个主要部分</li>
</ul>
<h4 id="1310">13.10、目录项操作<a class="headerlink" href="#1310" title="Permanent link">&para;</a></h4>
<h4 id="1311">13.11、文件对象<a class="headerlink" href="#1311" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>文件结构体（对象）表示已经打开的文件</strong></li>
<li>进程直接处理文件，而不是超级块、索引节点或目录项</li>
</ul>
<h4 id="1312">13.12、文件操作<a class="headerlink" href="#1312" title="Permanent link">&para;</a></h4>
<h4 id="1313">13.13、和文件系统相关的数据结构<a class="headerlink" href="#1313" title="Permanent link">&para;</a></h4>
<ul>
<li>file_system_type结构体，用来描述各种特定文件系统类型，linux/fs.h</li>
<li>vfsmount结构体，用来描述一个安装文件系统的实例，linux/mount.h</li>
</ul>
<h4 id="1314">13.14、和进程相关的数据结构<a class="headerlink" href="#1314" title="Permanent link">&para;</a></h4>
<h4 id="1315">13.15、小结<a class="headerlink" href="#1315" title="Permanent link">&para;</a></h4>
<h3 id="chap14io">chap14、块I/O<a class="headerlink" href="#chap14io" title="Permanent link">&para;</a></h3>
<h4 id="0_25">0、<a class="headerlink" href="#0_25" title="Permanent link">&para;</a></h4>
<ul>
<li>系统中能够<strong>随机（不需要按顺序）访问</strong>固定大小数据片（chunks）的硬件设备称为<strong>块设备</strong>，这些固定大小的数据片就称作<strong>块</strong>（磁盘）</li>
</ul>
<h4 id="141">14.1、剖析一个块设备<a class="headerlink" href="#141" title="Permanent link">&para;</a></h4>
<ul>
<li>块设备中最小的可寻址单元是<strong>扇区</strong>，最常见是512字节。</li>
<li>块大小【<strong>文件系统的最小寻址单元</strong>】一般是扇区的2倍。</li>
</ul>
<h4 id="142">14.2、缓冲区和缓冲区头<a class="headerlink" href="#142" title="Permanent link">&para;</a></h4>
<ul>
<li>linux/buffer_head.h中的<code>struct buffer_head{};</code></li>
<li><strong>缓冲区头</strong>的目的在于描述磁盘块和物理内存缓冲区（在特定页面上的字节序列）之间的映射关系。</li>
<li>缓冲区头的弊端
    + 1、是一个很大且不易控制的数据结构体
    + 2、它仅能描述单个缓冲区</li>
</ul>
<h4 id="143bio">14.3、bio结构体<a class="headerlink" href="#143bio" title="Permanent link">&para;</a></h4>
<h5 id="0_26">0、<a class="headerlink" href="#0_26" title="Permanent link">&para;</a></h5>
<ul>
<li>linux/bio.h中的<code>struct bio{};</code> 代表了正在现场的（活动的）以片断（segment）链表形式组织的块I/O操作。<strong>一个片段是一小块连续的内存缓冲区</strong>。</li>
</ul>
<h5 id="1431io">14.3.1、I/O向量<a class="headerlink" href="#1431io" title="Permanent link">&para;</a></h5>
<ul>
<li>bi_io_vec域指向一个<code>bio_vec</code>结构体数组，结构形式为<code>&lt;page,offset,len&gt;</code>，片段所在的物理页、块在物理页中的偏移位置、从给定偏移量开始的块长度</li>
</ul>
<h5 id="1432">14.3.2、新老办法对比<a class="headerlink" href="#1432" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>利用bio结构体代替buffer_head结构</strong>还有以下好处：
    + bio结构体很容易处理高端内存</li>
</ul>
<h4 id="144">14.4、请求队列<a class="headerlink" href="#144" title="Permanent link">&para;</a></h4>
<ul>
<li>linux/blkdev.h中的<code>reques_queue{}</code>，<strong>包含一个双向请求链表以及相关控制信息</strong>。</li>
</ul>
<h4 id="145io">14.5、I/O调度程序<a class="headerlink" href="#145io" title="Permanent link">&para;</a></h4>
<h5 id="1451io">14.5.1、I/O调度程序的工作<a class="headerlink" href="#1451io" title="Permanent link">&para;</a></h5>
<ul>
<li>两种方法减少磁盘寻址时间：<strong>合并与排序</strong></li>
<li>合并：</li>
</ul>
<h5 id="1452linux">14.5.2、Linux电梯<a class="headerlink" href="#1452linux" title="Permanent link">&para;</a></h5>
<ul>
<li><em>加入尾部太多的话，会导致饥饿问题？lionel</em></li>
<li>一个请求加入队列中时，有可能发生四种操作，依次是：
    + 1）如果队列中已存在一个对相邻磁盘扇区操作的请求，那么新请求将和这个已经存在的请求合并成一个请求
    + 2）如果队列中存一个驻留时间过长的请求，那么新请求将被插入到队列尾部，以防止其他旧的请求饥饿发生
    + 3）如果队列中以扇区方向为序存在合适的插入位置，那么新的请求将被插入到该位置，保证队列中的请求是以被访问磁盘物理位置为序进行排序的
       + 4）如果队列中不存在合适的请求插入位置，请求将插入到队列尾部</li>
</ul>
<h5 id="1453io">14.5.3、最终期限I/O调试程序<a class="headerlink" href="#1453io" title="Permanent link">&para;</a></h5>
<ul>
<li>block/deadline-iosched.c</li>
<li>deadline，解决电梯中的饥饿问题</li>
<li><strong>写-饥饿-读（writes-starving-reads）</strong></li>
<li>有3个队列
    + 读请求FIFO队列
    + 写请求FIFO队列
    + 排序队列</li>
<li><strong>降低了系统吞吐量</strong></li>
</ul>
<h5 id="1454io">14.5.4、预测I/O调度程序<a class="headerlink" href="#1454io" title="Permanent link">&para;</a></h5>
<ul>
<li>block/as-ioshed.c</li>
<li><strong>在保持良好的读响应的同时也能提供良好的全局吞吐量</strong>，最主要的改进是<strong>它增加了预测启发（anticipation-heuristic）能力</strong>。</li>
</ul>
<h5 id="1455io">14.5.5、完全公正的排队I/O调度程序<a class="headerlink" href="#1455io" title="Permanent link">&para;</a></h5>
<ul>
<li>block/cfq-iosched.c</li>
<li>（Complete Fair Queuing，CFQ），<strong>根据引起I/O请求的进程组织的</strong>，即每一个提交I/O的进程都有自己的队列。</li>
<li>以时间片轮转调度队列，从每个队列中选取请求数（默认值为4，可配置），然后进行下一轮调度。</li>
</ul>
<h5 id="1456io">14.5.6、空操作的I/O调度程序<a class="headerlink" href="#1456io" title="Permanent link">&para;</a></h5>
<ul>
<li>block/noop-iosched.c</li>
<li><strong>不进行排序，也不进行其他形式的预寻址操作</strong>，忘不了执行合并</li>
</ul>
<h5 id="1457io">14.5.7、I/O调度程序的选择<a class="headerlink" href="#1457io" title="Permanent link">&para;</a></h5>
<ul>
<li>内核命令行选项 <code>elevator=as</code> ，表示启用 <strong>预测I/O</strong></li>
</ul>
<h4 id="146">14.6、小结<a class="headerlink" href="#146" title="Permanent link">&para;</a></h4>
<h3 id="chap15">chap15、进程地址空间<a class="headerlink" href="#chap15" title="Permanent link">&para;</a></h3>
<h4 id="151">15.1、地址空间<a class="headerlink" href="#151" title="Permanent link">&para;</a></h4>
<ul>
<li>内存区域可以包含各种内存对象：
    + 可执行文件代码的内存映射，称为<strong>代码段（text section）</strong></li>
</ul>
<h4 id="152">15.2、内存描述符<a class="headerlink" href="#152" title="Permanent link">&para;</a></h4>
<h5 id="0_27">0、<a class="headerlink" href="#0_27" title="Permanent link">&para;</a></h5>
<ul>
<li>内存描述符<strong>表示进程的地址空间</strong>，linux/sched.h中的<code>struct mm_struct{};</code></li>
<li><strong>所有的mm_struct结构体都通过自身的mmlist域连接在一个双向链表中，该链表的首元素是init_mm内存描述符，它代表init进程的地址空间</strong>。需要使用kernel/fork.c中的<code>mmlist_lock</code>锁来防止并发访问</li>
</ul>
<h5 id="1521">15.2.1、分配内存描述符<a class="headerlink" href="#1521" title="Permanent link">&para;</a></h5>
<ul>
<li><em>没太完全明白，lionel</em></li>
</ul>
<h5 id="1522">15.2.2、撤销内存描述符<a class="headerlink" href="#1522" title="Permanent link">&para;</a></h5>
<ul>
<li>kernel/exit.c中的<code>exit_mm()</code>函数，常规的撤销工作</li>
</ul>
<h5 id="1523mm_struct">15.2.3、mm_struct与内核线程<a class="headerlink" href="#1523mm_struct" title="Permanent link">&para;</a></h5>
<h4 id="153">15.3、虚拟内存区域<a class="headerlink" href="#153" title="Permanent link">&para;</a></h4>
<h5 id="0_28">0、<a class="headerlink" href="#0_28" title="Permanent link">&para;</a></h5>
<ul>
<li>linux/mm_types.h中的<code>vm_area_struct</code>，<strong>指定地址空间内连续区间上的一个独立内存范围</strong>。</li>
</ul>
<h5 id="1531vma">15.3.1、VMA标志<a class="headerlink" href="#1531vma" title="Permanent link">&para;</a></h5>
<ul>
<li>是个位标志</li>
</ul>
<h5 id="1532vma">15.3.2、VMA操作<a class="headerlink" href="#1532vma" title="Permanent link">&para;</a></h5>
<ul>
<li>linux/mm.h中的<code>vm_operations_struct</code>结构体</li>
</ul>
<h5 id="1533">15.3.3、内存区域的树型结构和内存区域的链表结构<a class="headerlink" href="#1533" title="Permanent link">&para;</a></h5>
<ul>
<li>mmap域使用单独链表连接所有的内存区域对象</li>
<li>mm_rb域使用红-黑树连接所有的内存区域对象</li>
</ul>
<h5 id="1534">15.3.4、实际使用中的内存区域<a class="headerlink" href="#1534" title="Permanent link">&para;</a></h5>
<ul>
<li><strong><code>pmap</code>工具查看给定进程的内存空间和其中所含的内存区域</strong></li>
</ul>
<h4 id="154">15.4、操作内存区域<a class="headerlink" href="#154" title="Permanent link">&para;</a></h4>
<ul>
<li>linux/mm.h中</li>
</ul>
<h5 id="1541find_vma">15.4.1、find_vma()<a class="headerlink" href="#1541find_vma" title="Permanent link">&para;</a></h5>
<h5 id="1542find_vma_prev">15.4.2、find_vma_prev()<a class="headerlink" href="#1542find_vma_prev" title="Permanent link">&para;</a></h5>
<h5 id="1543find_vma_intersection">15.4.3、find_vma_intersection()<a class="headerlink" href="#1543find_vma_intersection" title="Permanent link">&para;</a></h5>
<ul>
<li>返回第一个和指定地址区间相交的VMA</li>
</ul>
<h4 id="155mmapdo_mmap">15.5、mmap和do_mmap：创建地址空间<a class="headerlink" href="#155mmapdo_mmap" title="Permanent link">&para;</a></h4>
<ul>
<li>linux/mm.h中的<code>do_mmap()</code>，<strong>将一个地址区间加入到进程的地址空间中</strong></li>
<li>file指定的文件，具体映射的是文件中从偏移offset处开始，长度为len字节的范围内的数据。如果file参数是NULL并且offset参数也是0，那么就代表这次映射没有和文件有关，称为<strong>匿名映射（anonymous mapping）</strong></li>
</ul>
<h4 id="156nummapdo_nummap">15.6、nummap和do_nummap：删除地址区间<a class="headerlink" href="#156nummapdo_nummap" title="Permanent link">&para;</a></h4>
<ul>
<li>linux/mm.h中的<code>do_mummap()</code>从特定的进程地址空间中删除指定地址区间</li>
</ul>
<h4 id="157">15.7、页表<a class="headerlink" href="#157" title="Permanent link">&para;</a></h4>
<ul>
<li>页表定义在asm/page.h中</li>
<li>顶级页表是<strong>页全局目录（PGD）</strong>，它包含一个pgd_t类型数组，</li>
<li>二级页表是<strong>中间页目录（PMD）</strong>，它是个pmd_t类型数组，其中的表项<strong>指向PTE中的表项</strong>。</li>
<li>最后一级的页表简称<strong>页表</strong>，其中包含了pte_t类型的页表项，<strong>该页表指向物理页面</strong></li>
<li>（translate lookaside buffer，TLB），<strong>一个将虚拟地址映射到物理地址的硬件缓存</strong>。</li>
</ul>
<h4 id="158">15.8、小结<a class="headerlink" href="#158" title="Permanent link">&para;</a></h4>
<h3 id="chap16">chap16、页高速缓存和页回写<a class="headerlink" href="#chap16" title="Permanent link">&para;</a></h3>
<h4 id="161">16.1、缓存手段<a class="headerlink" href="#161" title="Permanent link">&para;</a></h4>
<h5 id="1611">16.1.1、写缓存<a class="headerlink" href="#1611" title="Permanent link">&para;</a></h5>
<ul>
<li>缓存一般被实现成下面三种策略之一:
    + 第一种：不缓存（nowrite）
    + 第二种：写透缓存（write-through cache）：<strong>写操作将自动更新内存缓存，同时也更新磁盘文件</strong>。
    + 第三种：回写，<strong>脏页链表</strong></li>
</ul>
<h5 id="1612">16.1.2、缓存回收<a class="headerlink" href="#1612" title="Permanent link">&para;</a></h5>
<ul>
<li>1、最近最少使用</li>
<li>2、双链策略</li>
</ul>
<h4 id="162linux">16.2、Linux页高速缓存<a class="headerlink" href="#162linux" title="Permanent link">&para;</a></h4>
<h5 id="1621address_space">16.2.1、address_space对象<a class="headerlink" href="#1621address_space" title="Permanent link">&para;</a></h5>
<ul>
<li>linux/fs.h中的<code>struct address_space{};</code></li>
</ul>
<h5 id="1622address_space">16.2.2、address_space操作<a class="headerlink" href="#1622address_space" title="Permanent link">&para;</a></h5>
<ul>
<li>linux/fs.h中的<code>struct address_space_operations{};</code></li>
</ul>
<h5 id="1623">16.2.3、基树<a class="headerlink" href="#1623" title="Permanent link">&para;</a></h5>
<ul>
<li>lib/radix-tree.c</li>
<li>linux/radix_tree.h</li>
</ul>
<h5 id="1624">16.2.4、以前的页散列表<a class="headerlink" href="#1624" title="Permanent link">&para;</a></h5>
<h4 id="163">16.3、缓冲区高速缓存<a class="headerlink" href="#163" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>内核提供了<code>bread()</code>实现从磁盘读一个块的底层操作</strong>。</li>
</ul>
<h4 id="164flusher">16.4、flusher线程<a class="headerlink" href="#164flusher" title="Permanent link">&para;</a></h4>
<h5 id="1641">16.4.1、膝上型计算机模式<a class="headerlink" href="#1641" title="Permanent link">&para;</a></h5>
<h5 id="1642bdflushkupdatedpdflush">16.4.2、历史上的bdflush、kupdated和pdflush<a class="headerlink" href="#1642bdflushkupdatedpdflush" title="Permanent link">&para;</a></h5>
<h5 id="1643">16.4.3、避免拥塞的方法：使用多线程<a class="headerlink" href="#1643" title="Permanent link">&para;</a></h5>
<h4 id="165">16.5、小结<a class="headerlink" href="#165" title="Permanent link">&para;</a></h4>
<h3 id="chap17">chap17、设备与模块<a class="headerlink" href="#chap17" title="Permanent link">&para;</a></h3>
<ul>
<li>设备类型：在所有Unix系统中为了统一普通设备的操作所采用的分类</li>
<li>模块：Linux内核中用于按需加载和卸载目标码的机制</li>
<li>内核对象：内核数据结构中支持面向对象的简单操作，还支持维护对象之间的父子关系</li>
<li>sysfs：表示系统中设备树的一个文件系统</li>
</ul>
<h4 id="171">17.1、设备类型<a class="headerlink" href="#171" title="Permanent link">&para;</a></h4>
<ul>
<li>3种设备类型:
    + 块设备：blkdev
    + 字符设备：cdev
    + 网络设备：ethernet devices</li>
<li><strong>杂项设备（miscellaneous device）</strong>：miscdev</li>
<li><strong>伪设备（pseudo device）</strong></li>
</ul>
<h4 id="172">17.2、模块<a class="headerlink" href="#172" title="Permanent link">&para;</a></h4>
<h5 id="1721helloworld">17.2.1、Hello，World<a class="headerlink" href="#1721helloworld" title="Permanent link">&para;</a></h5>
<h5 id="1722">17.2.2、构建模块<a class="headerlink" href="#1722" title="Permanent link">&para;</a></h5>
<h5 id="1723">17.2.3、安装模块<a class="headerlink" href="#1723" title="Permanent link">&para;</a></h5>
<ul>
<li><code>/lib/modules/version/kernel</code></li>
<li>命令：<code>make modules_install</code></li>
</ul>
<h5 id="1724">17.2.4、产生模块的依赖性<a class="headerlink" href="#1724" title="Permanent link">&para;</a></h5>
<ul>
<li><code>depmod -A</code></li>
<li>模块依赖关系信息存放在<code>/lib/modules/version/modules.dep</code></li>
</ul>
<h5 id="1725">17.2.5、载入模块<a class="headerlink" href="#1725" title="Permanent link">&para;</a></h5>
<ul>
<li><code>insmod</code></li>
</ul>
<h5 id="1726">17.2.6、管理配置选项<a class="headerlink" href="#1726" title="Permanent link">&para;</a></h5>
<h5 id="1727">17.2.7、模块参数<a class="headerlink" href="#1727" title="Permanent link">&para;</a></h5>
<ul>
<li><code>module_param()</code>宏</li>
</ul>
<h5 id="1728">17.2.8、导出符号表<a class="headerlink" href="#1728" title="Permanent link">&para;</a></h5>
<ul>
<li><code>EXPORT_SYMBOL()</code></li>
</ul>
<h4 id="173">17.3、设备模型<a class="headerlink" href="#173" title="Permanent link">&para;</a></h4>
<h5 id="0_29">0、<a class="headerlink" href="#0_29" title="Permanent link">&para;</a></h5>
<ul>
<li>2.6增加了新特性：<strong>统一设备模型（device model）</strong>，提供了一个独立的机制专门来表示设备，并描述其在系统中的拓扑结构</li>
</ul>
<h5 id="1731kobject">17.3.1、kobject<a class="headerlink" href="#1731kobject" title="Permanent link">&para;</a></h5>
<ul>
<li>linux/kobject.h中的<code>struct kobject{};</code></li>
</ul>
<h5 id="1732ktype">17.3.2、ktype<a class="headerlink" href="#1732ktype" title="Permanent link">&para;</a></h5>
<ul>
<li>linux/kobject.h中的<code>struct kobj_type{};</code></li>
</ul>
<h5 id="1733kset">17.3.3、kset<a class="headerlink" href="#1733kset" title="Permanent link">&para;</a></h5>
<ul>
<li>linux/kobject.h中的<code>struct kset{};</code></li>
</ul>
<h5 id="1734kobjectktypekset">17.3.4、kobject、ktype和kset的相互关系<a class="headerlink" href="#1734kobjectktypekset" title="Permanent link">&para;</a></h5>
<h5 id="1735kobject">17.3.5、管理和操作kobject<a class="headerlink" href="#1735kobject" title="Permanent link">&para;</a></h5>
<h5 id="1736">17.3.6、引用计数<a class="headerlink" href="#1736" title="Permanent link">&para;</a></h5>
<ul>
<li>1、递增和递减引用计数</li>
<li>2、kref</li>
</ul>
<h4 id="174sysfs">17.4、sysfs<a class="headerlink" href="#174sysfs" title="Permanent link">&para;</a></h4>
<h5 id="0_30">0、<a class="headerlink" href="#0_30" title="Permanent link">&para;</a></h5>
<h5 id="1741sysfskobject">17.4.1、sysfs中添加和删除kobject<a class="headerlink" href="#1741sysfskobject" title="Permanent link">&para;</a></h5>
<ul>
<li><code>kobject_add()</code></li>
</ul>
<h5 id="1742sysfs">17.4.2、向sysfs中添加文件<a class="headerlink" href="#1742sysfs" title="Permanent link">&para;</a></h5>
<ul>
<li>1、</li>
<li>2、创建新属性</li>
<li>3、删除新属性</li>
</ul>
<h5 id="1743">17.4.3、内核事件层<a class="headerlink" href="#1743" title="Permanent link">&para;</a></h5>
<ul>
<li><code>kobject_uevent()</code></li>
</ul>
<h4 id="175">17.5、小结<a class="headerlink" href="#175" title="Permanent link">&para;</a></h4>
<h3 id="chap18">chap18、调试<a class="headerlink" href="#chap18" title="Permanent link">&para;</a></h3>
<h4 id="181">18.1、准备开始<a class="headerlink" href="#181" title="Permanent link">&para;</a></h4>
<h4 id="182bug">18.2、内核中的bug<a class="headerlink" href="#182bug" title="Permanent link">&para;</a></h4>
<h4 id="183">18.3、通过打印来调试<a class="headerlink" href="#183" title="Permanent link">&para;</a></h4>
<h5 id="1831">18.3.1、健壮性<a class="headerlink" href="#1831" title="Permanent link">&para;</a></h5>
<h5 id="1832">18.3.2、日志等级<a class="headerlink" href="#1832" title="Permanent link">&para;</a></h5>
<ul>
<li>printk()可以指定日志等级（<strong>printf()不可以</strong>）</li>
<li>linux/kernel.h中定义，<code>KERN_WARING</code>和<code>KERN_DEBUG</code></li>
<li>没有指定时，会选用默认的<code>DEFAULT_MESSAGE_LOGLEVEL</code>，也就是<code>KERN_WARING</code></li>
</ul>
<h5 id="1833">18.3.3、记录缓冲区<a class="headerlink" href="#1833" title="Permanent link">&para;</a></h5>
<h5 id="1834syslogdklogd">18.3.4、syslogd和klogd<a class="headerlink" href="#1834syslogdklogd" title="Permanent link">&para;</a></h5>
<h5 id="1835printfprintk">18.3.5、从printf到printk的转换<a class="headerlink" href="#1835printfprintk" title="Permanent link">&para;</a></h5>
<h4 id="184oops">18.4、oops<a class="headerlink" href="#184oops" title="Permanent link">&para;</a></h4>
<h5 id="1841ksymoops">18.4.1、ksymoops<a class="headerlink" href="#1841ksymoops" title="Permanent link">&para;</a></h5>
<h5 id="1842kallsyms">18.4.2、kallsyms<a class="headerlink" href="#1842kallsyms" title="Permanent link">&para;</a></h5>
<h4 id="185">18.5、内核调试配置选项<a class="headerlink" href="#185" title="Permanent link">&para;</a></h4>
<h4 id="186bug">18.6、引发bug并打印信息<a class="headerlink" href="#186bug" title="Permanent link">&para;</a></h4>
<h4 id="187">18.7、神奇的系统请求键<a class="headerlink" href="#187" title="Permanent link">&para;</a></h4>
<h4 id="188">18.8、内核调试器的传奇<a class="headerlink" href="#188" title="Permanent link">&para;</a></h4>
<h5 id="1881gdb">18.8.1、gdb<a class="headerlink" href="#1881gdb" title="Permanent link">&para;</a></h5>
<h5 id="1882kgdb">18.8.2、kgdb<a class="headerlink" href="#1882kgdb" title="Permanent link">&para;</a></h5>
<h4 id="189">18.9、探测系统<a class="headerlink" href="#189" title="Permanent link">&para;</a></h4>
<h5 id="1891uid">18.9.1、用UID作为选择条件<a class="headerlink" href="#1891uid" title="Permanent link">&para;</a></h5>
<h5 id="1892">18.9.2、使用条件变量<a class="headerlink" href="#1892" title="Permanent link">&para;</a></h5>
<h5 id="1893">18.9.3、使用统计量<a class="headerlink" href="#1893" title="Permanent link">&para;</a></h5>
<h5 id="1894">18.9.4、重复频率限制<a class="headerlink" href="#1894" title="Permanent link">&para;</a></h5>
<h4 id="1810">18.10、用二分查找法找出引发罪恶的变更<a class="headerlink" href="#1810" title="Permanent link">&para;</a></h4>
<h4 id="1811git">18.11、使用Git进行二分搜索<a class="headerlink" href="#1811git" title="Permanent link">&para;</a></h4>
<h4 id="1812">18.12、当所有的努力都失败时：社区<a class="headerlink" href="#1812" title="Permanent link">&para;</a></h4>
<h4 id="1813">18.13、小结<a class="headerlink" href="#1813" title="Permanent link">&para;</a></h4>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../14video/%E6%96%B0%E4%B8%80%E4%BB%A3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%A0%81%E6%A0%87%E5%87%86-H.264_AVC/" class="btn btn-neutral float-left" title="《新一代视频压缩码标准-H.264_AVC》"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/" class="btn btn-neutral float-right" title="《深入Linux设备驱动程序内核机制》">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../../14video/%E6%96%B0%E4%B8%80%E4%BB%A3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%A0%81%E6%A0%87%E5%87%86-H.264_AVC/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
