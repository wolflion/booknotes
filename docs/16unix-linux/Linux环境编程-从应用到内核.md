## 《Linux环境编程-从应用到内核》

### chap9、信号

+ **信号，是一种软件中断，用于处理异步事件**，本质上**是一种进程间的通信**
+ 传统信号机制有一些弊端，信号处理函数的执行流和正常的执行流同时存在，给编程带来了麻烦和困扰

#### 6.1、信号的完整生命周期

+ 基本流程
+ 还需要考虑的情况
  + 目标进程正在执行关键代码，不能被信号中断，需要阻塞某些信号，那么在这期间，信号就不允许被传递到进程，直到目标进程解除阻塞
  + 内核发现同一个信号已经存在，那么它该如何处理这种重复的信号，排队还是丢弃？

#### 6.2、信号的产生

##### 6.2.1、硬件异常220

##### 6.2.2　终端相关的信号221

##### 6.2.3　软件事件相关的信号223

6.3　信号的默认处理函数224
6.4　信号的分类227

#### 6.5、传统信号的特点

6.5.1　信号的ONESHOT特性230
6.5.2　信号执行时屏蔽自身的特性232
6.5.3　信号中断系统调用的重启特性233
6.6　信号的可靠性236
6.6.1　信号的可靠性实验236
6.6.2　信号可靠性差异的根源240

#### 6.7、信号的安装

+ `signal()`有问题后，引入新的`sigaction()`

#### 6.8、信号的发送

##### 6.8.1、kill、tkill和tgkill

##### 6.8.2、raise函数

##### 6.8.3、sigqueue函数

#### 6.9、信号与线程的关系

6.9.1　线程之间共享信号处理函数254
6.9.2　线程有独立的阻塞信号掩码255
6.9.3　私有挂起信号和共享挂起信号257
6.9.4　致命信号下，进程组全体退出260
6.10　等待信号260
6.10.1　pause函数261
6.10.2　sigsuspend函数262
6.10.3　sigwait函数和sigwaitinfo函数263
6.11　通过文件描述符来获取信号265
6.12　信号递送的顺序267
6.13　异步信号安全272
6.14　总结275

### chap7、理解Linux线程（1）

7.1　线程与进程276
7.2　进程ID和线程ID281
7.3　pthread库接口介绍284
7.4　线程的创建和标识285
7.4.1　pthread_create函数285
7.4.2　线程ID及进程地址空间布局286
7.4.3　线程创建的默认属性291
7.5　线程的退出292
7.6　线程的连接与分离293
7.6.1　线程的连接293
7.6.2　为什么要连接退出的线程295
7.6.3　线程的分离299

#### 7.7、互斥量

##### 7.7.1、为什么需要互斥量

+ 如果都是局部变量，属于单个线程，但很多变量都是多个线程共享的，这样的变量称为**共享变量**（shared variable）。**通过数据的共享，完成多个线程之间的交互**，（不加同步措施，会导致每次值会不一样）
+ 例子，`g_cnt`的值是多少？
+ 解决方案需要**做到如下3点**：
  + 1、代码必须要有互斥的行为
  + 2、

##### 7.7.2、互斥量的接口

+ 1、互斥量的初始化
+ 2、互斥量的销毁
+ 3、互斥量的加锁和解锁

##### 7.7.3、临界区的大小

+ 太小锁不住，太大影响性能

##### 7.7.4、互斥量的性能

7.7.5　互斥锁的公平性310
7.7.6　互斥锁的类型311
7.7.7　死锁和活锁314

#### 7.8、读写锁

+ 大部分场景，**线程只是读取共享变量的值，并不修改**

##### 7.8.1、读写锁的接口

+ 1、创建和销毁读写锁

7.8.2　读写锁的竞争策略318
7.8.3　读写锁总结323
7.9　性能杀手：伪共享323
7.10　条件等待328
7.10.1　条件变量的创建和销毁328
7.10.2　条件变量的使用329

### chap8、理解Linux线程（2）

8.1　线程取消333
8.1.1　函数取消接口333
8.1.2　线程清理函数335

#### 8.2、线程局部存储

##### 8.2.1、使用NPTL库函数实现线程局部存储

##### 8.2.2、使用__thread关键字实现线程局部存储

+ `__thread int val = 0;`，**凡是有`__thread`关键字的变量，每个线程都会有该变量的一个拷贝，并行不悖，互不干扰**。
+ 需要以下几点注意：
  + 使用了static或extern，`__thread`应该紧随其后

#### 8.3、线程与信号

##### 8.3.1、设置线程的信号掩码

+ **信号掩码是针对线程的**，`pthread_sigmask()`

##### 8.3.2、向线程发送信号

+ `pthread_kill()`

##### 8.3.3、多线程程序对信号的处理

+ **不要使用信号**

#### 8.4、多线程与fork()

### chap12、网络通信：连接的建立

#### 12.1、socket文件描述符

+ *如何从fd找到文件*
+ `socket->sock_map_fd->sock_alloc_file()`

#### 12.2、绑定IP地址

+ *为何要bind()地址，是每一个都要绑定吗？【TCP,UDP这种】*

##### 12.2.1、bind的使用

##### 12.2.2、bind的源码分析

+ net/socket.c中

#### 12.3、客户端连接过程

##### 12.3.1、connect的使用

+ *重复连接，会有什么问题？*
+ TCP的话，会有**三次握手** 【为什么是阻塞操作？】

##### 12.3.2、connect的源码分析

#### 12.4、服务器端连接过程

##### 12.4.1、listen的使用

##### 12.4.2、listen的源码分析

##### 12.4.3、accept的使用

+ **从指定套接字的连接队列中取出第一个连接，并返回一个新的套接字用于与客户端进行通信**
+ `accept4()`是啥意思？

##### 12.4.4、accept的源码分析

#### 12.5、TCP三次握手的实现分析

##### 12.5.1、SYN包的发送

+ SYN包是指**客户端主动建立一个TCP连接的第一个包**，TCP标志为SYN，**表示同步TCP的序列号**
+ `tcp_connect()`

##### 12.5.2、接收SYN包，发送SYN+ACK包

+ `ip_local_deliver_finish()`

##### 12.5.3、接收SYN+ACK数据包

+ `tcp_v4_do_rcv()`

##### 12.5.4、接收ACK数据包，完成三次握手

+ `tcp_v4_hnd_req()`

### chap13、网络通信：数据报文的发送

#### 13.1、发送相关接口

+ `send()`
+ `sendto()`
+ `sendmsg()`

#### 13.2、数据包从用户空间到内核空间的流程

+ send的内核实现
+ `send()->sendto()->sendmsg()`，这样连贯调用的

#### 13.3、UDP数据包的发送流程

+ `udp_sendmsg()->udp_send_skb()`

#### 13.4、TCP数据包的发送流程

+ `tcp_sendmsg()->__tcp_push_pending_frames()->tcp_write_xmit()`

#### 13.5、IP数据包的发送流程

##### 13.5.1、ip_send_skb源码分析

+ udp调用，`ip_send_skb()->ip_local_out()->__ip_local_out()->ip_output()->ip_finish_output()`

##### 13.5.2、ip_queue_xmit源码分析

+ **TCP调用的是**，`ip_queue_xmit()->ip_local_out()`

#### 13.6、底层模块数据包的发送流程

+ **二层网卡只接受自己地址的数据包**，所以需要**将三层网络地址“映射”为正确的二层硬件地址**
  + ipv4的话，是ARP协议实现的
  + ipv6的话，是**邻居发现协议**（ICMPv6）

+ **二层数据包的发送接口为`neigh_output()`**

### chap14、网络通信：数据报文的接收

#### 14.1、系统调用接口

+ `recv()`
+ `recvfrom()`
+ `recvmsg()`

#### 14.2、数据包从用户空间到内核空间的流程

+ `recv()->recvfrom()->recvmsg()`

#### 14.3、UDP数据包的接收流程

+ `udp_recvmsg()->__skb_recv_datagram()`

#### 14.4、TCP数据包的接收流程

+ `tcp_recvmsg()`

#### 14.5、TCP套接字的三个接收队列

+ struct sock中的sk_receive_queue
+ struct sock中的sk_backlog
+ struct tcp_sock中的prequeue

#### 14.6、从网卡到套接字

+ **数据包是如何进入对应套接字的接收缓冲区的呢？**

##### 14.6.1、从硬中断到软中断

+ 

##### 14.6.2、软中断处理

+ 以下几种条件，内核会检查是否需要处理软中断：
  + 退出硬中断上下文时
  + 重新enable软中断时
  + 每个CPU都有一个ksoftirqd内核线程。当内核的软中断数量过多时，就会唤醒该线程循环处理软中断

##### 14.6.3、传递给协议栈流程

+ `netif_receive_skb()`

##### 14.6.4、IP协议处理流程

+ 在inet_init中，调用了`dev_add_pack(&ip_packet_type)`进行了IPv4协议的注册。

##### 14.6.5、大师的错误？原始套接字的接收

+ **普通的raw socket是无法收到TCP和UDP的数据包的，除非该套接字是从数据链路层就开始读取数据包的**。
+ `raw_local_deliver()->raw_v4_input()`

##### 14.6.6、注册传输层协议

##### 14.6.7、确定UDP套接字

+ `udp_protocol`结构体中`.handler`指定`udp_rcv()`再调用`__udp4_lib_rcv()`

##### 14.6.8、确定TCP套接字

+ `tcp_protocol`结构体中`.handler`指定`tcp_v4_rcv()`

### 最后

#### 履历

+ 2018年在github上写过笔记，不过当时写的是chap2-4基础的
+ 2024-01-15是把7-8两章（关于线程的章节）给过了一下
+ 2024-01-21把12-14三章（网络）给过了下