## Linux命令行与shell脚本编程大全

+ Part2: shell脚本编程基础（11-16）
  + chap15呈现数据
  + chap16控制脚本（`trap, &, jobs, nice, at, cron`）
+ Part3:高级shell脚本编程（17-23）

### chap11、构建基本脚本

#### 11.1、使用多个命令

+ 用`;`分隔，`date;who`
+ 最大命令行字符数不能超过255

#### 11.2、创建shell脚本文件

+ shell的第一行要指定使用的shell。`#!/bin/bash`  **虽然#是注释符，但第一行是例外**
+ 要找到自己写的shell脚本
  + 将shell脚本的目录添加到PATH环境变量中
  + 在提示符中用绝对或相对路径执行
+ shell脚本的执行权限
  + umask的值
  + umask值决定了源文件的默认权限设置，*022是啥意思？lionel*

#### 11.3、显示消息

+ `echo`中的单引号或双引号的问题
+ `echo -n`参数，*文本串+输出在同一行？lionel*

#### 11.4、使用变量

##### 11.4.1、环境变量

+ `set`命令
+ 环境变量前面加美元符号`$`
  + `echo "The cost of the item is \$15"`会认为是要输入$，没有`\`，会被认为是`$1`+5这样的，可以通过`${15}`的方式来表达
  + `\$`才显示$本身

##### 11.4.2、用户变量

+ **区分大小写，不能出现空格**，长度不超过20
+ `=`两边不能有空格
+ 引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符

##### 11.4.3、命令替换

+ 将命令输出给变量
  + 反引号字符  `
  + `$()`格式

#### 11.5、重定向输入和输出

##### 11.5.1、输出重定向

##### 11.5.2、输入重定向

#### 11.6、管道

##### 11.6.1、expr命令

#### 11.7、执行数学运算

##### 11.7.1、expr命令

+ `expr 1+5`，`expr 5 \*2 `（*要用反斜杠）

##### 11.7.2、使用方括号`$[]`

+ `var1=$[1+5]`

##### 11.7.3、浮点解决方案

+ `bc`的基本用法 

#### 11.8、退出脚本

##### 11.8.1、查出退出状态码

+ `$?`

##### 11.8.2、exit命令

+ `exit 5`，表示`$?`就是5

#### 11.9、小结

+ lionel，都是其它地方总结的
  + `#/## 变量名`：第一个字符/最后一个字符左侧
  + `%/%% 变量名`：第一个字符/最后一个字符右侧
  + `bash .sh文件`执行

### chap12、使用结构化命令

#### 12.1、使用if-then语句

```shell
#!/bin/bash
#testing the if statement
if pwd
then
	echo "It worked"
#else
	#echo "else"
fi
```



#### 12.2、if-then-else语句

##### 12.3、嵌套if

+ `elif`组合

#### 12.4、test命令

+ 判断三类条件
+ 方括号定义测试条件，空格

##### 12.4.1、数组比较

+ eq
+ gt

##### 12.4.2、字符串比较

+ 长度非0  `-n str1`
+ 长度为0  `-z str1`

##### 12.4.3、文件比较

#### 12.5、复合条件测试

+ `[ cond1 ] && [ cond2 ]`，还有`||`，**两个空格不能忘**

#### 12.6、if-then的高级特征

##### 12.6.1、使用双括号

+ 使用高级的数学表达式 `(( expression ))`

##### 12.6.2、使用双方括号

+ 字符串比较的高级特性，模式匹配 `[[ ]]`

#### 12.7、case命令

```shell
case var in
par1 | par2) cmd;;
par3 | par4)  cmd;;
*) default cmd;;
esac
```



#### 12.8、小结

### chap13、更多的结构化命令

#### 13.1、for命令

```shell
for var in list
do 
    cmd
done
```



#### 13.2、C语言风格的for命令

#### 13.3、while命令

```shell
while test cmd
do
	cmd
done
```



#### 13.4、until命令

+ 与while相反

13.5、嵌套循环

13.6、循环处理文件数据

#### 13.7、控制循环

##### 13.7.1、break

##### 13.7.2、continue

#### 13.8、处理循环的输出

#### 13.9、实例

##### 13.9.1、查找可执行文件

##### 13.9.2、创建多个用户账户

13.10、小结

### chap14、处理用户输入

#### 14.1、命令行参数

14.1.1、读取参数

+ 位置参数
  + $0，程序名
  + $1，第1个参数

14.1.2、读取脚本名

+ `$0`

14.1.3、测试参数

+ `if[ -n "$1"]`

#### 14.2、特殊参数变量

##### 14.2.1、参数统计

+ `$#`
+ `$[#]`不能在花括号内使用美元符
+ `${!#}`无参数时，返回脚本名

##### 14.2.2、抓取所有的数据

+ `$*`，所有参数当作一个单词保存
+ `$@`，单独处理每一个参数

#### 14.3、移动变量

+ shift命令，`shift 2`一次移动2个位置

14.4、处理选项

14.4.1、查找选项

+ `--`双破折线，表明选项列表结束

14.5、将选项标准化

#### 14.6、获得用户输入

14.6.1、基本的读取

+ read，`read -p`指定提示符

14.6.2、超时

+ `read -t`

14.6.3、隐藏方式读取

+ `read -s`，隐藏密码

##### 14.6.4、从文件中读取

+ `cat test | while read line`

### chap15、呈现数据

#### 15.1、理解输入和输出

##### 15.1.1、标准文件描述符

##### 15.1.2、重定向错误

#### 15.2、在脚本中重定向输出

##### 15.2.1、临时重定向

##### 15.2.2、永久重定向

#### 15.3、在脚本中重定向输入

+ `exec 0< testfile`

#### 15.4、创建自己的重定向

##### 15.4.1、创建输出文件描述符

##### 15.4.2、重定向文件描述符

##### 15.4.3、创建输入文件描述符

##### 15.4.4、创建读写文件描述符

##### 15.4.5、关闭文件描述符

#### 15.5、列出打开的文件描述符

#### 15.6、阻止命令输出

#### 15.7、创建临时文件

##### 15.7.1、创建本地临时文件

##### 15.7.2、在/tmp目录创建临时文件

+ `mktemp -t`选项

##### 15.7.3、创建临时目录

+ `-d`选项

#### 15.8、记录消息

15.9、实例

15.10、小结

### chap16、控制脚本

+ 也就是运行，除了**实时模式**，还有其它方式
  + 向脚本发送信号
  + 修改脚本的优先级
  + 在脚本运行时切换到运行模式

#### 16.1、处理信号

##### 16.1.1、重温Linux信号

+ shell会**忽视SIGQUIT，SIGTERM**，**处理SIGHUP，SIGINT**

##### 16.1.2、生成信号

+ 中断进程
  + ctrl+c，会生成SIGINT信号，停止shell中当前运行的进程
+ 暂停进程
  + ctrl+z，会生成SIGTSTP信号，停止shell中当前运行的进程
+ **停止（stopping）与终止（terminating）不同**
  + 停止，会让程序继续保留在内存中，并能从上次停止的位置继续运行
+ `ps -l`中 S列的值，如果是**T**，说明命令要么被跟踪，要么被停止了

##### 16.1.3、捕获信号

+ `trap`命令
  + `trap "echo 'Sorry! I have trapped Ctrl-C'"  SIGINT`，**用一组空格分开的待捕获的信号**

##### 16.1.4、捕获脚本退出

+ 在trap后面加上`EXIT`信号

##### 16.1.5、修改或移除捕获

#### 16.2、以后台模式运行脚本

+ 在后台模式中，进程运行时不会和终端会话上的STDIN，STDOUT以及STDERR关联

##### 16.2.1、后台运行脚本（`&`）

##### 16.2.2、运行多个后台脚本

+ 只能逐个运行
+ **ps的输出中，每一个后台进程都和终端会话（pts/0）终端联系在一起。如果终端会话退出，那么后台进程也会随之退出**

#### 16.3、在非控制台下运行脚本

+ **nohup命令运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号**
+ `nohup ./test1.sh &`

#### 16.4、作业控制

+ 启动、停止、终止以及恢复作业这些功能统称为**作业控制**

##### 16.4.1、查看作业

+ jobs命令，
  + `jobs -l`查看进程号
  + `$$`分配给脚本的PID

##### 16.4.2、重启停止的作业

+ `bg 作业号`，如果只有1个作业，**直接`bg`命令即可**

#### 16.5、调整谦让度

+ 从-20（最高优先级）到+19（最低优先级）

##### 16.5.1、nice命令

+ `nice -n 10 ./test4.sh > test4.out &`，**只能降低，不能提高**

##### 16.5.2、renice命令

+ renice命令的限制
  + `renice -n 10 -p 5055`，改变系统上已经运行的

#### 16.6、定时运行作业

##### 16.6.1、用at命令来计划执行作业

+ 4、删除作业
  + `atrm`是删除，`atq`查看哪些作业在作业队列中等待

##### 16.6.2、安排需要定期执行的脚本

+ 1、cron时间表
+ 2、构建cron时间表
  + `crontab -l`
  + **添加条目**用`-e`选项，即`crontab -e`
+ 3、浏览cron目录
  + `ls /etc/cron.*ly`

##### 16.6.3、使用新shell启动脚本

#### 16.7、小结

### chap17、创建函数

#### 17.1、基本的脚本函数

##### 17.1.1、创建函数，2种形式

+ 一种是函数名前面加`function`
+ 另一种是函数名后面加`()`

```shell
function name {commands}   #关键字function
name() {commands}    #关键的()
```



##### 17.1.2、使用函数

#### 17.2、返回值

##### 17.2.1、默认退出状态码

+ 函数中最后一条命令返回的退出状态码，可以用`$?`来确定

##### 17.2.2、使用return命令

+ 退出状态码，必须是0-255

##### 17.2.3、使用函数输出

+ `result = $(dbl)	 #dbl是函数`

#### 17.3、在函数中使用变量

##### 17.3.1、向函数传递参数

+ `$#` 判断传给函数的参数数目

##### 17.3.2、在函数中处理变量

+ 全局变量
+ 局部变量
  + `local`关键字，**保证了变量只局限在该函数中**
  + *问题，如果有2个同名的怎么办？*

#### 17.4、数组变量和函数

##### 17.4.1、向函数传数组参数

##### 17.4.2、从函数返回数组

+ test12.sh

#### 17.5、函数递归

+ test13.sh

#### 17.6、创建库

#### 17.7、在命令行上使用函数

##### 17.7.1、在命令行上创建函数

##### 17.7.2、在`.bashrc`文件中定义函数

#### 17.8、实例

+ shtool库

#### 17.9、小结

### chap19、初始sed和gawk

### chap20、正则表达式

### chap21、sed进阶

### chap22、gawk进阶

### chap23、使用其它shell

### 最后

#### 履历

+ 20220319写了点纸上的笔记，2021年1月底和2月初也看了点Part2和Part3方面的知识