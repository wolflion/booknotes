<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>《Linux内核探秘》 - lionel的技术笔记</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u300aLinux\u5185\u6838\u63a2\u79d8\u300b";
        var mkdocs_page_input_path = "11filesystem\\Linux\u5185\u6838\u63a2\u79d8.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> lionel的技术笔记
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../01daily/">daily</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">C++</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/effectiveC%2B%2B/">《Effective C++》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/EffectiveSTL/">《Effective STL》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网络编程</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">《TCP/IP网络编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">《Linux高性能服务器编程》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">文件系统</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">《Linux内核探秘》</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#21">2.1、文件系统的基本概念</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#211vfs">2.1.1、什么是VFS</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#212super_block">2.1.2、超级块super_block</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#213dentry">2.1.3、目录项dentry</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#214inode">2.1.4、索引节点inode</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#215">2.1.5、文件</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#22">2.2、文件系统的架构</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#221">2.2.1、超级块作用分析</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#222dentry">2.2.2、dentry作用分析</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#223inode">2.2.3、inode作用分析</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#224">2.2.4、文件作用分析</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#23">2.3、从代码层次深入分析文件系统</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#231aufs">2.3.1、一个最简单的文件系统aufs</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#232">2.3.2、文件系统如何管理目录和文件</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#233">2.3.3、文件系统的挂载过程</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#234">2.3.4、文件打开的代码分析</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#24">2.4、本章小结</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《文件系统技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">《存储技术原理分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">存储</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../12storage/ceph%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《ceph设计原理与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">内核</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《Linux内核设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/">《深入Linux设备驱动程序内核机制》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网课</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/01Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/">《Linux高并发网络编程开发》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/%E4%BE%AF%E6%8D%B7/%E4%BE%AF%E6%8D%B7C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8660%E8%AE%B2/">《侯捷C++内存管理60讲》</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">lionel的技术笔记</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>文件系统 &raquo;</li>
      <li>《Linux内核探秘》</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h3 id="chap2-1224232">chap2、文件系统   12（24/232）<a class="headerlink" href="#chap2-1224232" title="Permanent link">&para;</a></h3>
<h4 id="21">2.1、文件系统的基本概念<a class="headerlink" href="#21" title="Permanent link">&para;</a></h4>
<h5 id="211vfs">2.1.1、什么是VFS<a class="headerlink" href="#211vfs" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>VFS本身只存在于内存中</strong>，它需要将硬盘上的文件系统抽象到内存中，通过几个<strong>重要的结构</strong>（<code>dentry、inode、super_block</code>）</li>
</ul>
<h5 id="212super_block">2.1.2、超级块super_block<a class="headerlink" href="#212super_block" title="Permanent link">&para;</a></h5>
<ul>
<li>代表了<strong>整个文件系统本身</strong>，<ul>
<li>给出了文件系统的全局信息</li>
<li>包含一些函数指针</li>
</ul>
</li>
</ul>
<h5 id="213dentry">2.1.3、目录项dentry<a class="headerlink" href="#213dentry" title="Permanent link">&para;</a></h5>
<ul>
<li>目录项反映了文件系统的这种树状关系</li>
</ul>
<h5 id="214inode">2.1.4、索引节点inode<a class="headerlink" href="#214inode" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>inode代表一个文件</strong></li>
</ul>
<h5 id="215">2.1.5、文件<a class="headerlink" href="#215" title="Permanent link">&para;</a></h5>
<ul>
<li>文件对象的作用是<strong>描述进程和文件交互的关系</strong>。 【<strong>文件对象</strong>指的是内存中的文件】</li>
<li>进程打开一个文件，内核就动态创建一个文件对象。同一个文件，在不同的进程中有不同的文件对象。</li>
</ul>
<h4 id="22">2.2、文件系统的架构<a class="headerlink" href="#22" title="Permanent link">&para;</a></h4>
<h5 id="221">2.2.1、超级块作用分析<a class="headerlink" href="#221" title="Permanent link">&para;</a></h5>
<h5 id="222dentry">2.2.2、dentry作用分析<a class="headerlink" href="#222dentry" title="Permanent link">&para;</a></h5>
<h5 id="223inode">2.2.3、inode作用分析<a class="headerlink" href="#223inode" title="Permanent link">&para;</a></h5>
<ul>
<li>系统内核提供了一个hash链表数组<code>inode_hashtable</code></li>
<li>inode还有一个重要用作用是<strong>缓存文件的数据内容</strong>，通过成员<code>i_mapping</code>实现的。</li>
</ul>
<h5 id="224">2.2.4、文件作用分析<a class="headerlink" href="#224" title="Permanent link">&para;</a></h5>
<h4 id="23">2.3、从代码层次深入分析文件系统<a class="headerlink" href="#23" title="Permanent link">&para;</a></h4>
<h5 id="231aufs">2.3.1、一个最简单的文件系统aufs<a class="headerlink" href="#231aufs" title="Permanent link">&para;</a></h5>
<pre class="highlight"><code class="language-cpp">#include &lt;linux/moudle.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/pagemap.h&gt;
#include &lt;linux/mount.h&gt;
#include &lt;linut/init.h&gt;
#include &lt;linux/nami.h&gt;

#define AUFS_MAIGC 0x64668735
static struct vfsmount* aufs_mount;
static int aufs_mount_count;

static struct inode* aufs_get_inode(struct super_block* sb, int mode, dev_t dev)
{
    struct inode* inode = new_inode(sb);
    if (inode) {
        inode-&gt;i_mode = mode;
        inode-&gt;i_uid = current-&gt;fsuid;
        inode-&gt;i_gid = current-&gt;fsgid;
        inode-&gt;i_blksize = PAGE_CACHE_SIZE;
        inode-&gt;i_blocks = 0;
        inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;
        switch (mode &amp; S_IFMT) {
        default:
            int_special_inode(inode, mode, dev);
            break;
        case S_IFREG:
            printk("create a file \n");
            break;
        case S_IFDIR:
            inode-&gt;i_op = &amp;simple_dir_inode_operations;
            inode-&gt;i_fop = &amp;simple_dir_operations;
            printk("create a dir file \n");

            inode-&gt;i_nlink++;
            break;
        }
    }
    return inode;
}

//SMP-safe
static int aufs_mknod(struct inode* dir, struct dentry* dentry, int mode, dev_t dev)
{
    struct inode* inode;
    int error = -EPERM;

    if (dentry-&gt;d_inode)
        return -EEXIST;

    inode = aufs_get_inode(dir-&gt;i_sb, mode, dev);
    if (inode) {
        d_instantiate(dentry, inode);
        dget(dentry);
        error = 0;
    }
    return error;
}

static int aufs_mkdir(struct inode* dir, struct dentry* dentry, int mode)
{
    int res;
    res = aufs_mknode(dir, dentry, mode | S_IFDIR, 0);
    if (!res)
        dir-&gt;i_nlink++;
    return res;
}

static int aufs_create(struct inode* dir, struct dentry* dentry, int mode)
{
    return aufs_mknode(dir, entry, mode | S_IFREG, 0);
}

static int aufs_fill_super(struct super_block* sb, void* data, int silent)
{
    static struct tree_descr debug_files[] = { {""} };
    return simple_fill_super(sb, AUFS_MAIGC, debug_files);//lionel，也是系统提供的啊，还是fs目录下libfs.c中的
}

static struct super_block* aufs_get_sb(struct file_system_type* fs_type,
    int flags, const char* dev_name, void* data)
{
    return get_sb_single(fs_type, flags, data, aufs_fill_super);
}

static struct file_system_type au_fs_type = {
    .owner = THIS_MODULE,
.name = "aufs",
.get_sb = aufs_get_sb,
.kill_sb = kill_litter_super,
};

static int aufs_create_by_name(const char* name, mode_t mode,
    struct dentry* parent,
    struct dentry** dentry)
{
    int error = 0;
    /* If the parent is not specified, we create it in the root.
    * We need the root dentry to do this, which is in the super
    * block. A pointer to that is in the struct vfsmount that we
    * have around.
    */
    if (!parent) {
        if (aufs_mount &amp;&amp; aufs_mount-&gt;mnt_sb) {
            parent = aufs_mount-&gt;mnt_sb-&gt;s_root;
        }
    }
    if (!parent) {
        printk("Ah! can not find a parent!\n");
        return -EFAULT;
    }

    *dentry = NULL;
    mutex_lock(&amp;parent-&gt;d_inode-&gt;i_mutex);
    &amp;dentry = lookup_one_len(name, parent, strlen(name));
    if (!IS_ERR(dentry)) {
        if ((mode &amp; S_IFMT) == S_IFDIR)
            error = aufs_mkdir(parent-&gt;d_inode, *dentry, mode);
        else
            error = aufs_create(parent-&gt;d_inode, *dentry, mode);
    }
    else
        error = PTR_ERR(dentry);
    mutex_unlock(&amp;parent-&gt;d_inode-&gt;i_mutex);
    return error;
}

struct dentry* aufs_create_file(const char* name, mode_t mode,
    struct dentry* parent, void* data,
    struct file_operations* fops)
{
    struct dentry* dentry = NULL;
    int error;
    printk("aufs: creating file '%s'\n", name);
    error = aufs_create_by_name(name, mode, parent, &amp;dentry);
    if (error) {
        dentry = NULL;
        goto exit;
    }
    if (dentry-&gt;d_inode) {
        if (data)
            dentry-&gt;d_inode-&gt;u.generic_ip = data;
        if (fops)
            dentry-&gt;d_inode-&gt;i_fop = fops;
    }
exit:
    return dentry;
}

struct dentry* aufs_create_dir(const char* name, struct dentry* parent)
{
    return aufs_create_file(name, S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO, parent, NULL, NULL);
}

static int __init aufs_init(void)
{
    int retval;
    struct dentry* pslot;

    retval = register_filesystem(&amp;au_fs_type);

    if (!retval) {
        aufs_mount = kern_mount(&amp;au_fs_type);  //lionel，kern_mount()【这个在super.c中】与do_mount()【这个在fs里的namespace.c中】有关联不？
        if (IS_ERROR(aufs_mount)) {
            printk(KERN_ERR "aufs: could not mount!\n");
            unregister_filesystem(&amp;au_fs_type);
            return retval;
        }
    }

    pslot = aufs_create_dir("woman star", NULL);
    aufs_create_file("lbb", S_IFREG | S_IRUGO, pslot, NULL, NULL);
    aufs_create_file("fbb", S_IFREG | S_IRUGO, pslot, NULL, NULL);
    aufs_create_file("ljl", S_IFREG | S_IRUGO, pslot, NULL, NULL);

    pslot = aufs_create_dir("man star", NULL);
    aufs_create_file("ldh", S_IFREG | S_IRUGO, pslot, NULL, NULL);
    aufs_create_file("lcw", S_IFREG | S_IRUGO, pslot, NULL, NULL);
    aufs_create_file("jw", S_IFREG | S_IRUGO, pslot, NULL, NULL);

    return retval;
}

static void __exit aufs_exit(void)
{
    simple_release_fs(&amp;aufs_mount, &amp;aufs_mount_count);
    unregister_filesystem(&amp;au_fs_type);
}

module_init(aufs_init);
module_exit(aufs_exit);
MODULE_LICENSE("GPL");
MOUDLE_DESCRIPTION("This is a simple module");
MODULE_VERSION("Ver 0.1");


/*
* mkdir au
* mount -t aufs none /au
* ls
*/
</code></pre>
<h5 id="232">2.3.2、文件系统如何管理目录和文件<a class="headerlink" href="#232" title="Permanent link">&para;</a></h5>
<ul>
<li>代码三部分<ul>
<li>1）<code>register_filesystem</code>函数，把aufs文件系统登记到系统</li>
<li>2）调用<code>kern_mount</code>函数为文件系统申请必备的数据结构</li>
<li>3）最后在aufs文件系统内创建两目录，每个目录下面创建3个文件</li>
</ul>
</li>
</ul>
<h5 id="233">2.3.3、文件系统的挂载过程<a class="headerlink" href="#233" title="Permanent link">&para;</a></h5>
<h5 id="234">2.3.4、文件打开的代码分析<a class="headerlink" href="#234" title="Permanent link">&para;</a></h5>
<h4 id="24">2.4、本章小结<a class="headerlink" href="#24" title="Permanent link">&para;</a></h4>
<h3 id="chap10-143155232">chap10、文件系统读写   143（155/232）<a class="headerlink" href="#chap10-143155232" title="Permanent link">&para;</a></h3>
<h4 id="101page-cache">10.1、page cache机制<a class="headerlink" href="#101page-cache" title="Permanent link">&para;</a></h4>
<ul>
<li>其存储的数据在I/O完成后并不回收，而是一直保留在内存中，除非内存紧张，才开始回收。</li>
</ul>
<h5 id="1011buffer-iodirect-io">10.1.1、buffer I/O和direct I/O<a class="headerlink" href="#1011buffer-iodirect-io" title="Permanent link">&para;</a></h5>
<ul>
<li>buffer I/O，是内核缓存</li>
<li>direct I/O，是应用提供的内存</li>
<li><strong>应用提供的<code>read</code>和<code>write</code>接口，是同步I/O接口</strong>。</li>
</ul>
<h5 id="1012buffer-head">10.1.2、buffer head和块缓存<a class="headerlink" href="#1012buffer-head" title="Permanent link">&para;</a></h5>
<ul>
<li><code>struct buffer_head{}</code></li>
</ul>
<h5 id="1013page-cache">10.1.3、page cache的管理<a class="headerlink" href="#1013page-cache" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>通过数据结构address_space管理page cache</strong></li>
<li><code>add_to_page_cache()</code>，插入页面到page cache</li>
</ul>
<h5 id="1014page-cache">10.1.4、page cache的状态<a class="headerlink" href="#1014page-cache" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p>page cache的状态：</p>
<ul>
<li>PG_dirty：</li>
<li>块缓存</li>
<li>BH_Mapped</li>
</ul>
</li>
</ul>
<h4 id="102">10.2、文件预读<a class="headerlink" href="#102" title="Permanent link">&para;</a></h4>
<ul>
<li>readhead.c中<code>struct backing_dev_info{}</code></li>
</ul>
<h4 id="103">10.3、文件锁<a class="headerlink" href="#103" title="Permanent link">&para;</a></h4>
<ul>
<li>实现机制不同：<ul>
<li>建议锁</li>
<li>强制锁</li>
</ul>
</li>
<li>访问方式不同：<ul>
<li>读锁（共享锁）</li>
<li>写锁（互斥锁）</li>
</ul>
</li>
</ul>
<h4 id="104">10.4、文件读过程代码分析<a class="headerlink" href="#104" title="Permanent link">&para;</a></h4>
<ul>
<li><code>sys_read()</code></li>
</ul>
<h4 id="105">10.5、读过程返回<a class="headerlink" href="#105" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>文件系统通过mpage_bio_submit提交一个I/O</strong>。这个I/O什么时候返回？通过什么机制通知上层？这涉及内核I/O过程的阻塞点设计。</li>
</ul>
<h4 id="106">10.6、文件写过程代码分析<a class="headerlink" href="#106" title="Permanent link">&para;</a></h4>
<ul>
<li><code>sys_write()</code></li>
</ul>
<h4 id="107">10.7、本章小结<a class="headerlink" href="#107" title="Permanent link">&para;</a></h4>
<ul>
<li>涉及文件中一些复杂参数的计算和page cache中页面缓存的状态处理。</li>
</ul>
<h3 id="chap11scsi-170182232">chap11、通用块层和scsi层   170（182/232）<a class="headerlink" href="#chap11scsi-170182232" title="Permanent link">&para;</a></h3>
<ul>
<li><em>lionel，这里面会涉及到一些I/O管理？</em></li>
</ul>
<ul>
<li>上接文件系统的VFS层，下接硬盘驱动。<strong>处理I/O的合并或者排序</strong></li>
</ul>
<h4 id="111">11.1、块设备队列<a class="headerlink" href="#111" title="Permanent link">&para;</a></h4>
<h5 id="1111scsi">11.1.1、scsi块设备队列处理函数<a class="headerlink" href="#1111scsi" title="Permanent link">&para;</a></h5>
<ul>
<li><code>scsi_alloc_queue()</code></li>
</ul>
<h5 id="1112">11.1.2、电梯算法和对象<a class="headerlink" href="#1112" title="Permanent link">&para;</a></h5>
<ul>
<li><code>struct elevator_type{}</code>
  11.2、硬盘HBA抽象层</li>
<li><code>struct scsi_host_template{}</code></li>
</ul>
<h4 id="113io">11.3、I/O的顺序控制<a class="headerlink" href="#113io" title="Permanent link">&para;</a></h4>
<h4 id="114io">11.4、I/O调度算法<a class="headerlink" href="#114io" title="Permanent link">&para;</a></h4>
<h5 id="1141noop">11.4.1、noop调度算法<a class="headerlink" href="#1141noop" title="Permanent link">&para;</a></h5>
<ul>
<li><code>noop_add_request()</code></li>
</ul>
<ul>
<li>
<p><code>noop_dispatch()</code></p>
<h5 id="1142deadline">11.4.2、deadline调度算法<a class="headerlink" href="#1142deadline" title="Permanent link">&para;</a></h5>
</li>
</ul>
<ul>
<li><code>struct deadline_data{}</code></li>
</ul>
<ul>
<li><code>deadline_add_request()</code></li>
</ul>
<h4 id="115io">11.5、I/O的处理过程<a class="headerlink" href="#115io" title="Permanent link">&para;</a></h4>
<h5 id="1151io">11.5.1、I/O插入队列的过程分析<a class="headerlink" href="#1151io" title="Permanent link">&para;</a></h5>
<h6 id="11511submit_bio">11.5.1.1、submit_bio函数<a class="headerlink" href="#11511submit_bio" title="Permanent link">&para;</a></h6>
<h6 id="11512generic_make_request">11.5.1.2、generic_make_request函数<a class="headerlink" href="#11512generic_make_request" title="Permanent link">&para;</a></h6>
<h6 id="11513__generic_make_request">11.5.1.3、<code>__generic_make_request</code>函数<a class="headerlink" href="#11513__generic_make_request" title="Permanent link">&para;</a></h6>
<h6 id="11514elv_merge">11.5.1.4、elv_merge函数<a class="headerlink" href="#11514elv_merge" title="Permanent link">&para;</a></h6>
<h6 id="11515__elv_add_request">11.5.1.5、<code>__elv_add_request</code>函数<a class="headerlink" href="#11515__elv_add_request" title="Permanent link">&para;</a></h6>
<h6 id="11516elv_insert">11.5.1.6、elv_insert函数<a class="headerlink" href="#11516elv_insert" title="Permanent link">&para;</a></h6>
<h5 id="1152io">11.5.2、I/O出队列的过程分析<a class="headerlink" href="#1152io" title="Permanent link">&para;</a></h5>
<h6 id="11521unplug">11.5.2.1、unplug函数<a class="headerlink" href="#11521unplug" title="Permanent link">&para;</a></h6>
<h6 id="11522scsi_request_fn">11.5.2.2、scsi_request_fn函数<a class="headerlink" href="#11522scsi_request_fn" title="Permanent link">&para;</a></h6>
<h6 id="11523elv_nex_request">11.5.2.3、elv_nex_request函数<a class="headerlink" href="#11523elv_nex_request" title="Permanent link">&para;</a></h6>
<h6 id="11524blk_do_ordered">11.5.2.4、blk_do_ordered函数<a class="headerlink" href="#11524blk_do_ordered" title="Permanent link">&para;</a></h6>
<h6 id="11525start_ordered">11.5.2.5、start_ordered函数<a class="headerlink" href="#11525start_ordered" title="Permanent link">&para;</a></h6>
<h6 id="11526scsi_dispatch_cmd">11.5.2.6、scsi_dispatch_cmd函数<a class="headerlink" href="#11526scsi_dispatch_cmd" title="Permanent link">&para;</a></h6>
<h5 id="1153io">11.5.3、I/O返回路径<a class="headerlink" href="#1153io" title="Permanent link">&para;</a></h5>
<h6 id="11531sd_rw_intr">11.5.3.1、sd_rw_intr函数<a class="headerlink" href="#11531sd_rw_intr" title="Permanent link">&para;</a></h6>
<h6 id="11532scsi_io_completion">11.5.3.2、scsi_io_completion函数<a class="headerlink" href="#11532scsi_io_completion" title="Permanent link">&para;</a></h6>
<h6 id="11533scsi_end_request">11.5.3.3、scsi_end_request函数<a class="headerlink" href="#11533scsi_end_request" title="Permanent link">&para;</a></h6>
<h4 id="116">11.6、本章小结<a class="headerlink" href="#116" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>通用块层、I/O调度算法和scsi层，共同构建了文件系统之下的I/O处理流程</strong>。</li>
</ul>
<h3 id="chap12-204216232">chap12、内核回写机制   204（216/232）<a class="headerlink" href="#chap12-204216232" title="Permanent link">&para;</a></h3>
<h4 id="121">12.1、内核的触发条件<a class="headerlink" href="#121" title="Permanent link">&para;</a></h4>
<ul>
<li>文件系统的写函数<code>generic_file_buffered_write()</code>要调用<code>balance_dirty_pages_ratelimited()</code></li>
<li>内核定时器触发</li>
<li>当系统申请内存失败，或者文件系统执行同步（sync）操作，或者内存管理模块试图释放更多内存的时候，都可能触发<strong>pdflush线程回写页面</strong>。</li>
</ul>
<h4 id="122">12.2、内核回写控制参数<a class="headerlink" href="#122" title="Permanent link">&para;</a></h4>
<h4 id="123">12.3、定时器触发回写<a class="headerlink" href="#123" title="Permanent link">&para;</a></h4>
<ul>
<li><code>start_kernel()</code>启动了一个定时器</li>
</ul>
<h5 id="1231">12.3.1、启动定时器<a class="headerlink" href="#1231" title="Permanent link">&para;</a></h5>
<ul>
<li>调用<code>page_writeback_init()</code>函数启动定时器</li>
</ul>
<h5 id="1232">12.3.2、执行回写操作<a class="headerlink" href="#1232" title="Permanent link">&para;</a></h5>
<ul>
<li><code>wb_kupdate()</code></li>
</ul>
<h5 id="1233">12.3.3、检查需要回写的页面<a class="headerlink" href="#1233" title="Permanent link">&para;</a></h5>
<ul>
<li><code>writeback_inodes()</code>扫描系统的超级块，检查需要回写的页面</li>
</ul>
<h5 id="1234inode">12.3.4、回写超级块内的inode<a class="headerlink" href="#1234inode" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p><code>sync_sb_inodes()</code></p>
<h5 id="12341">12.3.4.1、<a class="headerlink" href="#12341" title="Permanent link">&para;</a></h5>
<h5 id="12342">12.3.4.2、<a class="headerlink" href="#12342" title="Permanent link">&para;</a></h5>
<h5 id="12343">12.3.4.3、<a class="headerlink" href="#12343" title="Permanent link">&para;</a></h5>
<h5 id="12344">12.3.4.4、<a class="headerlink" href="#12344" title="Permanent link">&para;</a></h5>
</li>
</ul>
<h4 id="124">12.4、平衡写<a class="headerlink" href="#124" title="Permanent link">&para;</a></h4>
<ul>
<li><code>balance_dirty_pages_ratelimited()</code>检查脏页面是否到达限值，是否进行平衡写操作</li>
</ul>
<ul>
<li>
<p><code>balance_dirty_pages()</code></p>
<h5 id="1241">12.4.1、检查直接回写的条件<a class="headerlink" href="#1241" title="Permanent link">&para;</a></h5>
</li>
</ul>
<ul>
<li>
<p><code>balance_dirty_pages_ratelimited_nr()</code></p>
<h5 id="1242">12.4.2、回写系统脏页面的条件<a class="headerlink" href="#1242" title="Permanent link">&para;</a></h5>
<h5 id="1243">12.4.3、检查计算机模式<a class="headerlink" href="#1243" title="Permanent link">&para;</a></h5>
</li>
</ul>
<h4 id="125">12.5、本章小结<a class="headerlink" href="#125" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Linux内核的回写机制提供了一种缓写机制，真实的写并不是直接写入硬盘，而是在page cache中缓存，等待合适的时机才真正执行写入</strong>。</li>
</ul>
<h3 id="chap13ext2-217229232">chap13、一个真实文件系统ext2   217（229/232）<a class="headerlink" href="#chap13ext2-217229232" title="Permanent link">&para;</a></h3>
<h4 id="131ext2">13.1、ext2的硬盘布局<a class="headerlink" href="#131ext2" title="Permanent link">&para;</a></h4>
<h4 id="132ext2">13.2、ext2文件系统目录树<a class="headerlink" href="#132ext2" title="Permanent link">&para;</a></h4>
<ul>
<li><code>struct ext2_dir_entry_2{};</code></li>
<li><strong>根目录是一个固定的inode，它的inode号是2</strong>。</li>
</ul>
<h4 id="133ext2">13.3、ext2文件内容管理<a class="headerlink" href="#133ext2" title="Permanent link">&para;</a></h4>
<ul>
<li>ext2的inode信息可以存放15个块的地址，用户数据就存在这些块中。</li>
<li>15块中前12块是直接数据块，<strong>第13块是一级索引块，第14块是二级索引块，第15块是三级索引块</strong></li>
</ul>
<h4 id="134ext2">13.4、ext2文件系统读写<a class="headerlink" href="#134ext2" title="Permanent link">&para;</a></h4>
<ul>
<li>通过文件系统的目录树，可以获得文件所在目录的上级目录。</li>
<li>读上级目录的内容，就可以获得文件的inode号和文件名称。</li>
<li>根据文件的inode号，可以获得文件的inode信息，也就获得了文件的类型、创建修改时间、文件大小等信息，完成打开文件的过程。</li>
</ul>
<h4 id="135">13.5、本章小结<a class="headerlink" href="#135" title="Permanent link">&para;</a></h4>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../10network/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" class="btn btn-neutral float-left" title="《Linux高性能服务器编程》"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/" class="btn btn-neutral float-right" title="《文件系统技术内幕》">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../../10network/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
