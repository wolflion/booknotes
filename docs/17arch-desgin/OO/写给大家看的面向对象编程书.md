## 《写给大家看的面向对象编程书》

### chap1、面向对象概念介绍

+ 遗留系统（legacy system）

+ **对象包装器**，把一个结构化模块，把它包装在一个对象中。

#### 1.1、过程式程序设计与OO程序设计

+ **对象到底是什么？** object，可以定义为**同时包含**数据和行为的一个实体。
  + **属性**和**行为**
  + 过程式中，**属性和行为**是分开的
  + 过程式中，**数据通常与过程分离**，有时数据是全局的

#### 1.2、从过程式开发转向面向对象开发

##### 1.2.1、过程式程序设计

+ **将系统的数据与处理这些数据的操作相分离**

##### 1.2.2、OO程序设计

+ 数据和处理这些数据的操作（代码）都封装在对象中

#### 1.3、对象到底是什么

+ 对象是OO程序的构建模块

##### 1.3.1、对象数据

+ 存储在一个对象中的数据表示**对象的状态**，也叫**属性**

##### 1.3.2、对象行为

+ 对象的行为就是**对象能够做什么**
+ *xml怎么影响的，这部分没看*    8（21/280）

#### 1.4　类到底是什么

+ 类是对象的蓝图。

##### 1.4.1　类是对象模板

##### 1.4.2　属性

##### 1.4.3　方法

##### 1.4.4　消息

+ **对象之间的通信机制**，当对象A调用对象B的一个方法时，**对象A就是在向对象B发送一个消息**。

#### 1.5　使用UML完成类图建模

#### 1.6　封装和数据隐藏

+ **只应公开其他对象与之交互所必需的接口**
+ **数据隐藏**是**封装**的一个主要部分

##### 1.6.1　接口

+ **定义了对象间通信的基本途径**
+ 计算一个数据的平方，接口包括两部分：
  + 如何实例化一个Square对象
  + 如何向对象发送一个值，并得到该值的平方
+ **类的接口**【是公共方法】和**方法的接口**【如何调用这个方法】

##### 1.6.2　实现

+ 只有公共属性和方法被认为是接口。
+ **与一个对象的交互只能通过类接口**

##### 1.6.3　接口/实现范型的一个实际例子

+ 15（28/280）*未看*

##### 1.6.4　接口/实现范型的模型

+ 16（29/280）*未看*

#### 1.7　继承

##### 1.7.1　超类和子类

+ 超类（父类）包含继承自该类的所有子类共同的属性和行为。

##### 1.7.2　抽象　16

+ *没讲清楚，重点*，17（30/280）

##### 1.7.3　is-a关系　17

+ *没讲清楚，重点*， 18（31/280）

#### 1.8　多态

+ **覆盖**（overriding），将父类的一个实现替换为其子类的一个实现
+ 19（32/280）
+ **抽象类**

#### 1.9　组合

+ 对象是由其他对象构建或组合（composition）而成的。

##### 1.9.1　抽象

+ 继承（被认为是is-a的关系，猫是一只动物）
+ 组合（汽车与发动机，不是is-a的关系，是has-a的关系）

##### 1.9.2　has-a关系

#### 1.10　小结

+ 封装
+ 继承
+ 多态
+ 组合

#### 1.11　本章使用的示例代码

+ 23（36/280）

1.11.1　TestPerson示例　21
1.11.2　TestPerson示例　22
1.11.3　TestShape示例　23
1.11.4　TestShape示例　25

### chap2、如何以对象方式思考　27

+ 28（41/280）
+ **同一个问题往往可能有多种不同的处理方法**
+ 3个方面
  + 接口与实现的区别
  + 以更抽象的方式思考
  + 尽可能为用户提供最小接口

#### 2.1　了解接口与实现之间的区别

+ 发动机是实现的一部分，方向盘是接口的一部分
+ **类分2个部分设计--接口和实现**

##### 2.1.1　接口

+ **设计一个类时，最重要的是明确类的受众或用户**

##### 2.1.2　实现

+ **改变实现不需要同时改变用户的代码**

##### 2.1.3　接口/实现示例

+ 30（43/280），*未细看*

#### 2.2　设计接口时使用抽象思维

+ 35（48/280）

+ **可重用类的接口**往往更抽象而不是更具体。
+ 抽象接口与具体接口
+ 抽象与重用

#### 2.3　尽可能为用户提供最小接口　35

+ 36（49/280），*未看，设计准则？*
+ 简单规则
  + 只为用户提供他们确实需要的东西
  + 最好是当用户确实需要时才增加接口，而不要为用户提供他们不需要的接口
  + 公共接口定义用户能访问的信息
  + 从用户角度设计类，而不要从信息系统的角度进行设计
  + 确保设计类时与将真正使用这个类的人（不只是开发人员）反复考虑过需求和设计

##### 2.3.1　确定用户　35

##### 2.3.2　对象行为　36

##### 2.3.3　环境约束　36

##### 2.3.4　明确公共接口　36

##### 2.3.5　明确实现　37

#### 2.4　小结　37

2.5　参考书目　38

### chap3、高级面向对象概念

+ 40（53/280）

#### 3.1　构造函数

3.1.1　何时调用构造函数　39
3.1.2　构造函数中有什么　40
3.1.3　默认构造函数　40
3.1.4　使用多个构造函数　41
3.1.5　构造函数的设计　44
3.2　错误处理　44
3.2.1　忽略问题　45
3.2.2　检查问题并中止应用　45
3.2.3　检查问题并尝试恢复　45
3.2.4　抛出异常　45
3.3　作用域概念　47
3.3.1　局部属性　48
3.3.2　对象属性　49
3.3.3　类属性　50
3.4　操作符重载　51
3.5　多重继承　52
3.6　对象操作　53
3.7　小结　54
3.8　参考书目　54
3.9　本章使用的示例代码　54
3.9.1　TestNumber示例：C#.NET　54
3.9.2　TestNumber示例　55
第4章　类剖析　57
4.1　类名　57
4.2　注释　58
4.3　属性　59
4.4　构造函数　60
4.5　访问方法　62
4.6　公共接口方法　63
4.7　私有实现方法　64
4.8　小结　64
4.9　参考书目　64
4.10　本章使用的示例代码　65
4.10.1　TestCab示例：C#.NET　65
4.10.2　TestCab示例　66
第5章　类设计指导原则　68
5.1　真实世界系统建模　68
5.2　明确公共接口　69
5.2.1　最小公共接口　69
5.2.2　隐藏实现　69
5.3　设计健壮的构造函数(和析构函数)　70
5.4　在类中设计错误处理　70
5.4.1　对类建立文档以及使用注释　71
5.4.2　构建类要以合作为出发点　71
5.5　设计时充分考虑重用　72
5.6　设计时充分考虑到可扩展性　72
5.6.1　名字要有描述性　72
5.6.2　抽出不可移植的代码　72
5.6.3　提供一种复制和比较对象的方法　73
5.6.4　让作用域尽可能小　73
5.6.5　类应当对自己负责　74
5.7　设计时充分考虑可维护性　75
5.7.1　使用迭代　76
5.7.2　测试接口　76
5.8　使用对象持久性　78
5.9　小结　79
5.10　参考书目　79
5.11　本章使用的示例代码　79
5.11.1　TestMath示例：C#.NET　79
5.11.2　TestMath示例　80
第6章　利用对象实现设计　81
6.1　设计指导原则　81
6.1.1　完成适当的分析　84
6.1.2　建立工作陈述　84
6.1.3　收集需求　84
6.1.4　开发用户界面的原型　85
6.1.5　明确类　85
6.1.6　确定各个类的职责　85
6.1.7　确定类如何相互合作　85
6.1.8　创建类模型来描述系统　85
6.2　案例研究：blackjack示例　86
6.2.1　使用CRC卡　87
6.2.2　明确blackjack类　88
6.2.3　明确类的职责　90
6.2.4　UML用例：明确协作关系　95
6.2.5　第一轮CRC卡　98
6.2.6　UML类图：对象模型　99
6.2.7　建立用户界面原型　100
6.3　小结　101
6.4　参考书目　101
第7章　掌握继承和组合　102
7.1　重用对象　102
7.2　继承　103
7.2.1　一般化和特殊化　105
7.2.2　设计决策　105
7.3　组合　107
7.4　为什么封装在OO中如此重要　109
7.4.1　继承如何削弱封装　109
7.4.2　多态的一个详细例子　111
7.4.3　对象职责　111
7.5　小结　115
7.6　参考书目　115
7.7　本章使用的示例代码　115
7.7.1　TestShape示例：C#.NET　115
7.7.2　TestShape示例　117
第8章　框架与重用：使用接口和抽象类实现设计　119
8.1　代码：重用还是不重用　119
8.2　什么是框架　119
8.3　什么是契约　121
8.3.1　抽象类　122
8.3.2　接口　124
8.3.3　集成　125
8.3.4　编译器的证明　127
8.3.5　建立契约　128
8.3.6　系统插入点　130
8.4　一个电子商务例子　130
8.4.1　电子商务问题　130
8.4.2　非重用的方法　131
8.4.3　一个电子商务解决方案　133
8.4.4　UML对象模型　133
8.5　小结　137
8.6　参考书目　137
8.7　本章使用的示例代码　138
8.7.1　TestShape示例：C#.NET　138
8.7.2　TestShape示例　140
第9章　构建对象　143
9.1　组合关系　143
9.2　分阶段构建　144
9.3　不同类型的组合　146
9.3.1　聚集　146
9.3.2　关联　146
9.3.3　结合使用关联和聚集　148
9.4　避免依赖性　148
9.5　基数　149
9.5.1　多个对象关联　151
9.5.2　可选关联　151
9.6　集成示例　152
9.7　小结　152
9.8　参考书目　153
第10章　用UML创建对象模型　154
10.1　什么是UML　154
10.2　类图的结构　155
10.3　属性和方法　156
10.3.1　属性　156
10.3.2　方法　157
10.4　访问指示　157
10.5　继承　158
10.6　接口　159
10.7　组合　160
10.7.1　聚集　160
10.7.2　关联　161
10.8　基数　161
10.9　小结　162
10.10　参考书目　163
第11章　对象和可移植数据：XML　164
11.1　可移植数据　164
11.2　XML　165
11.3　XML与HTML　166
11.4　XML和面向对象语言　166
11.5　两个公司间共享数据　167
11.6　用DTD验证文档　168
11.7　将DTD集成到XML文档　170
11.8　使用层叠样式表　175
11.9　小结　177
11.10　参考书目　177
第12章　持久对象：串行化和关系数据库　178
12.1　持久对象基础　178
12.2　将对象保存到平面文件　179
12.2.1　串行化文件　180
12.2.2　再谈实现和接口　182
12.2.3　方法如何保存　183
12.3　串行化过程中使用XML　183
12.4　写至关系数据库　186
12.5　加载驱动程序　189
12.5.1　建立连接　189
12.5.2　SQL语句　190
12.6　小结　192
12.7　参考书目　192
12.8　本章使用的示例代码　192
12.8.1　Person类示例：C#.NET　193
12.8.2　Person类示例　195
第13章　对象与因特网　197
13.1　分布式计算的演进　197
13.2　基于对象的脚本语言　197
13.3　JavaScript验证示例　200
13.4　Web页面中的对象　202
13.4.1　JavaScript对象　202
13.4.2　Web页面控件　204
13.4.3　声音播放器　205
13.4.4　电影播放器　205
13.4.5　Flash　206
13.5　分布式对象和企业　206
13.5.1　公共对象请求代理体系结构(CORBA)　207
13.5.2　Web服务定义　210
13.5.3　Web服务代码　213
13.5.4　Invoice.cs　214
13.5.5　Invoice.vb　215
13.6　小结　216
13.7　参考书目　216
第14章　对象和客户/服务器应用　217
14.1　客户/服务器方法　217
14.2　专有方法　217
14.2.1　串行化对象代码　218
14.2.2　客户代码　218
14.2.3　服务器代码　220
14.2.4　运行专有的客户/服务器示例　222
14.3　非专有方法　223
14.3.1　对象定义代码　223
14.3.2　客户代码　224
14.3.3　服务器代码　225
14.3.4　运行非专有的客户/服务器示例　227
14.4　小结　228
14.5　参考书目　228
14.6　本章使用的示例代码　228
14.6.1　客户/服务器示例：对象定义代码　228
14.6.2　客户/服务器示例：客户代码　229
14.6.3　客户/服务器示例：服务器代码　230
第15章　设计模式　232
15.1　为什么研究设计模式　232
15.2　Smalltalk的模型/视图/控制器　233
15.3　设计模式的不同类型　234
15.3.1　创建型模式　235
15.3.2　结构型模式　239
15.3.3　行为型模式　241
15.4　反模式　242
15.5　小结　243
15.6　参考书目　243
15.7　本章使用的示例代码　243
15.7.1　C#.NET　244
索引　250

### 最后

#### 履历

+ 2024-01-26，花了1个cubi把前2章过了一遍。