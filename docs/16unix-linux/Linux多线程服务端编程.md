## 《Linux多线程服务端编程》

### chap1、线程安全的对象生命期管理

### chap02、线程同步精要

#### 0、

+ 并发编程有两种基本模型
  + message passing
  + shared memory
+ 在分布式系统中，运行在多台机器上的多个进程的并行编程只有一种实用模型：message passing。
+ 《Real-World Concurrency》
+ 线程同步的四项原则，按重要性排列
  + 首先原则是尽量最低限度地共享对象，减少需要同步的场合。
  + 其实是使用高级的并发编程构件
  + 最后不得已必须使用底层同步原语（primitives）时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量
  + 除了使用atomic整数之外，不自己编写lock-free代码，也不要用“内核级”同步原语。

#### 2.1、互斥器（mutex）

##### 0、

+ **保护了临界区，任何一个时刻最多只能有一个线程在此mutex划出的临界区内活动**
+ 单独使用mutex时，我们主要为了保护共享数据，个人原则是：
  + 用RAII手法封装mutex的创建、销毁、加锁、解锁这四个操作
  + 只用非递归的mutex（即**不可重入的mutex**）
  + 不手工调lock()和unlock()函数，一切交给栈上的Guard对象的构造和析构函数负责
  + 在每次构造Guard对象的时候，思考一路上（调用栈上）已经持有的锁，防止因加锁顺序不同而导致死锁（deadlock）
+ 次要原则是：
  + 不使用跨进程的mutex，进程间通信只用TCP sockets
  + 加锁、解锁在同一个线程
  + 别忘了解锁
  + 不重复解锁
  + 必要的时候可以考虑用PTHREAD_MUTEX_ERRORCHECK来排错

##### 2.1.1、只使用非递归的mutex

##### 2.1.2、死锁

#### 2.2、条件变量（condition variable）

+ 对于wait端：
  + （1）必须与mutex一起使用，该布尔表达式读写需受此mutex保护
  + （2）在mutex已上锁的时候才能用wait
  + （3）把判断希尔条件和wait()放到while中
+ 对于signal/broadcast端：
+ 条件变量是非常底层的同步原语，很少直接使用
+ 倒计时（CountDownLatch）是一种常用且易用的同步手段

#### 2.3、不要用读写锁和信号量

#### 2.4、封装MutexLock、MutexLockGuard、Condition

#### 2.5、线程安全的Singleton实现

#### 2.6、Sleep(3)不是同步原语





### chap3、多线程服务器的适用场合与常用编程模型

#### 3.1、进程与线程

#### 3.2、单线程服务器的常见编程模型

+ UNP的chap6的IO模型、chap30的客户端/服务端设计范式.
+ **Reactor模式**（non-blocking IO+ IO multiplexing）
  + **一个事件循环（event loop），以事件驱动（event-driven）和事件回调的方式实现业务逻辑**。
+ 也有用的是**Proactor模式**

#### 3.3、多线程服务器的常见编程模型

##### 0、大概以下几种

+ 1、每个请求创建一个线程，使用阻塞式IO操作
+ 2、使用线程池，同样使用阻塞式IO操作
+ 3、使用non-blocking IO+ IO multiplexing
+ 4、Leader/Follower等高级模式

##### 3.3.1、one loop per thread

3.3.2、线程池

3.3.3、推荐模式

3.4、线程间通信只用TCP

3.5、多线程服务器的适用场合

3.6、“多线程服务器的适用场合”例释与答疑

### chap4、C++多线程系统编程精要

#### 4.1、基本线程原语的选用

+ 11个最基本的Pthreads函数是：
  + 2个：线程的创建和等待结束（join）
  + 4个：mutex的创建、销毁、加锁、解锁
  + 5个：条件变量的创建、销毁、等待、通知、广播（**除了mutex，一般不直接使用**）

4.2、C/C++系统库的线程安全性

#### 4.3、Linux上的线程标识

+ `pthread_t`不一定是数值（整数或指针），也可能是结构体
  + （1）因为不知其确切类型，无法打印输出pthread_t，也没法在日志中用它表示当前线程id
  + （2）无法比较pthread_t的大小或hash值，因此无法用它作关联容器的key

4.4、线程的创建与销毁的原则

##### 4.5.1、pthread_cancel与C++

4.5、善用`__thread`关键字

#### 4.6、多线程与IO

+ 规则：**一个线程可以操作多个文件描述符，但一个线程不能操作别的线程拥有的文件描述符**。
+ 有2个例外：
  + 对于磁盘文件，在必要的时候多个线程可以同时调用pread/pwrite来读写同一个文件
  + 对于UDP，由于协议本身保证消息的原子性，在恰当的条件下（比如消息之间彼此独立）可以多个线程同时读写同一个UDP文件描述符

4.7、用RAII包装文件描述符

4.8、RAII和fork()

#### 4.9、多线程与fork()

+ fork()一般不能在多线程程序中调用，fork()只克隆当前线程的thread of control，不克隆其它线程

#### 4.10、多线程与signal

+ **多线程时代，不要使用signal**

4.11、Linux新增系统调用的启示

### 最后

#### 履历

+ 2021-02-26看了下2-4章的内容，
+ 2023-02-25左右，自己整理了chap1-4的内容