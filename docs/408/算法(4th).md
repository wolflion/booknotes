## 《算法4th》

### chap2、排序  152（163/647）

#### 2.1、初级排序

##### 2.1.1、游戏规则

##### 2.1.2、选择排序

+ **重复的从待排元素中选出最大者或 最小者**
  + 我之前一般都是*存元素*，这里存的是下标

```cpp
void SelectSort(vector<int> nums){
    int len = nums.size();
    for(int i=0;i<len;i++){
        //将a[i]与a[i+1...len]中最小元素交换
        int min = i;//最小元素的索引
        for(int j=i+1;j<len;j++){
            if(less(a[j],a[min]))//这个less的写法，自己要会,lionel
                min=j;
        }
        exch(a,i,min);
    }
}
```



##### 2.1.3、插入排序

+ **为了腾空间，其它元素在插入之前都向右移动一位**

```cpp
void InsertSort(vector<int> nums){
    //按升序排列
    int lne = nums.size();
    for(int i=0;i<len;i++){
        //nums[i]插入到a[i-1],a[i-2],a[i-3]...之中
        for(int j=i;j>0&&less(a[j],a[j-1]);j--)
            exch(a,j,j-1);//lionel,我没看到哪个是往右移的，这也是种交换啊，难道是逐个交换？
    }
}
```



+ **部分有序**的场景

##### 2.1.4、插入排序的可视化

##### 2.1.5、比较两种排序算法

+ 用`time()`函数

##### 2.1.6、希尔排序

+ **基于插入排序的快速排序**
+ 使数组中任意间隔为h的元素都是有序的，**插入排序中移动元素的距离由1改为h即可**
+ 问题：**如何选择递增子序列？**

#### 2.2、归并排序

+ **两个有序的数组归并成一个更大的数组**，NlogN，需要额外的空间

##### 2.2.1、原地归并的抽象方法

+ 创建一个数组，将原数组从小到大放入。

##### 2.2.2、自顶向下的归并排序

+ *没理解*

##### 2.2.3、自底向上的归并排序

+ *没理解*

##### 2.2.4、排序算法的复杂度

#### 2.3、快速排序

+ Nlog2N（2为底）

##### 2.3.1、基本算法

+ **是一种分治排序算法**，2个子数组有序那么整个数组自然就有序了

###### 2.3.1.1、原地切分

###### 2.3.1.2、别越界

###### 2.3.1.3、保持随机性

###### 2.3.1.4、终止递归

##### 2.3.2、性能特点

##### 2.3.3、算法改进

#### 2.4、优先队列

##### 2.4.1、API

##### 2.4.2、初级实现

##### 2.4.3、堆的定义

+ 当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为**堆有序**

##### 2.4.4、堆的算法

###### 2.4.4.1、由下至上的堆有序变化（上浮）

###### 2.4.4.2、由上至下的堆有序变化（下沉）

###### 2.4.4.3、多叉堆

##### 2.4.5、堆排序

###### 2.4.5.1、堆的构造

#### 2.5、应用

##### 2.5.1、将各种数据排序

##### 2.5.2、我应该使用哪种排序算法

##### 2.5.3、问题的归纳

##### 2.5.4、排序应用一览

### chap3、查找  227（238/647）

#### 3.1、符号表

3.2、二叉查表树

3.3、平衡查找树

3.4、散列表

3.5、应用

### chap4、图 329（/647）

#### 4.1、无向图

#### 4.2、有向图

#### 4.3、最小生成树

#### 4.4、最短路径

### chap5、字符串  451（/647）