## 《Linux内核设计与实现》

### chap5、系统调用
#### 5.1、与内核通信
+ 系统调用在用户空间进程和硬件设备之间添加了一个中间层。**中间层**的3个作用：
#### 5.2、API、POSIX和C库
+ POSIX是个标准
+ C库：实现了Unix系统的主要API，包括标准C库函数和系统调用接口
+ 接口设计格言：**提供机制而不是策略**，*这个没懂，lionel*
#### 5.3、系统调用
##### 0、
+ 系统调用在出现错误的时候C库会把错误码写入errno全局变量。通过调用`perror`库函数，把该变量翻译成用户可以理解的错误字符串。
+ `SYSCALL_DEFINE0`-这个在2.6.18里没找到啊，直接在`/include/linux/syscalls.h`中定义了`asmlinkage long sys_getpid(void);`，实现怎么在time.c了呢？
	+ asmlinkage是个**编译指令**，通知编译器仅从栈中提取该函数的参数
	+ 返回值是long的原因，兼容32位和64位
	+ 系统调用的命名规则是`sys_`开头
##### 5.3.1、系统调用号
+ **进程不会提及系统调用的名称**，通过系统调用号来关联，**一旦分配就不会再有任何变更**
+ 所有已经注册过的系统调用的列表，存储在sys_call_table中。*2.6里搜了一下在arch/x86_64/kernel/syscall.c*
+ *问题1：何时删除系统调用号呢？ 问题2：系统调用号存在哪？*
+ 其它
	+ `sys_ni_syscall()`
##### 5.3.2、系统调用的性能
#### 5.4、系统调用处理程序
##### 0、
+ 通知内核的机制是靠**软中断**实现的：通过引发一个异常
+ x86系统上预定义的软中断是**中断号128，`int $0x80`指令**，名称叫`system_call()`
+ entry_64.S中用汇编编写
+ sysenter的指令
##### 5.4.1、指定恰当的系统调用
+ 在x86上，**系统调用号是通过eax寄存器传递给内核的**。*eax寄存器是啥？lionel，问题1，什么时候传给eax寄存器的，用什么方式传的？*
+ *表项是64位存放的，所以要乘4，不太懂啥意思，lionel*
##### 5.4.2、参数传递
+ x86-32系统上，**ebx，ecx，edx，esi和edi按照顺序存放前5个参数**。
#### 5.5、系统调用的实现
##### 5.5.1、实现系统调用
+ *通过思考这个过程，去想一下，日常的接口怎么设计？lionel*
##### 5.5.2、参数验证
+ `copy_from_user()`和`copy_to_user()`
+ 书上以`kernel/sys.c`中的`sys_reboot()`为例，说了些要注意的权限问题
+ `CAP_SYS_BOOT`，权限的定义在`/include/linux/capability.h`中，*以CAP开头，是因为capability.h的命名*
#### 5.6、系统调用上下文
##### 0、
+ *问题，为何可以休眠，是比较重要的呢*
##### 5.6.1、绑定一个系统调用的最后步骤
+ 注册
	+ 1、在系统调用表的最后加入一个表项，`entry.S`
	+ 2、支持各种体系结构，系统调用号都必须定义于`<asm/unistd.h>`
	+ 3、**系统调用必须被编译进内核映像（不能被编译成模块）**，放在`kernel/`下的一个相关文件就可以了，比如sys.c
##### 5.6.2、从用户空间访问系统调用
+ `_syscalln`，n的范围是0-6，表示**需要传递给系统调用的参数个数**。
+ *lionel，这个没具体看，想实践一下，怎么编进内核，怎么写了跟内核交互，系统调用*
##### 5.6.3、为什么不通过系统调用的方式实现
+ 系统调用有好处（创建容易且使用方便，性能高），但有问题：
+ 替代方法：（*不太懂*）
	+ 实现一个设备节点，并对此实现`read()`和`write()`
		+ 像信号量这样的某些接口
		+ 把增加的信息作为一个文件放在sysfs的合适位置

#### 5.7、小结

### chap6、内核数据结构

#### 6.1、链表
##### 0、
##### 6.1.1、单向链表和双向链表
##### 6.1.2、环形链表
##### 6.1.3、沿链表移动
+ **只能是线性移动**
##### 6.1.4、Linux内核中的实现
+ 0、
	+ **linux内核，将链表节点塞入数据结构，不是将数据结构塞入链表**。
+ 1、链表数据结构
	+ linux/list.h
+ 2、定义一个链表
+ 3、链表头
##### 6.1.5、操作链表
+ 0、
+ 1、向链表中增加一个节点
	+ `list_add()`
+ 2、从链表中删除一个节点
	+ `list_del()`
+ 3、移动和合并链表节点
	+ `list_move()`
	+ `list_move_tail()`
	+ `list_empty()`
##### 6.1.6、遍历链表
+ 0、
+ 1、
+ 2、
+ 3、反向遍历链表
	+ `list_for_each_entry_reverse()` 
+ 4、遍历的同时删除
	+ `list_for_each_entry_safe()`
+ 5、其它链表方法
#### 6.2、队列
##### 0、
+ `linux/kfifo.h`
##### 6.2.1、kfifo
+ kfifo对象维护了两个偏移量：入口偏移和出口偏移（**下一次出队列时的位置**）
+ enqueue
+ dequeue
##### 6.2.2、创建队列
+ 动态创建`kfifo_alloc()`
+ 静态创建
##### 6.2.3、推入队列数据
+ `kfifo_in()`
##### 6.2.4、摘取队列数据
+ `kfifo_out()`
##### 6.2.5、获取队列数据
+ `kfifo_size()`
##### 6.2.6、重置和撤销队列
+ `kfifo_reset()`
##### 6.2.7、队列使用举例
+ *未看，lionel*
#### 6.3、映射
##### 0、
##### 6.3.1、初始化一个idr
##### 6.3.2、分配一个新的UID
+ 第一步，告诉idr你需要分配新的UID，允许其在必要时调整后备树的大小
+ 第二步，才是真正请求新的UID
##### 6.3.3、查找UID
+ `idr_find`
##### 6.3.4、删除UID
+ `idr_move`
##### 6.3.5、撤销idr
+ `idr_destroy`
#### 6.4、二叉树
##### 6.4.1、二叉搜索树（BST）
##### 6.4.2、自平衡二叉搜索树
+ 1、红黑树
+ 2、rbtree
	+ linux/rbtree.h
	+ lib/rbtree.c
#### 6.5、数据结构以及选择
+ 遍历数据，就使用链表
+ 如果需要存储大量数据，并且检索迅速，那么红黑树最好
#### 6.6、算法复杂度
##### 6.6.1、算法
##### 6.6.2、大O符号
##### 6.6.3、大xita符号
##### 6.6.4、时间复杂度
#### 6.7、小结

### chap9、内核同步介绍
#### 9.1、临界区和竞争条件
##### 0、
+ 临界区
+ 竞争条件race coditions
##### 9.1.1、为什么我们需要保护
##### 9.1.2、单个变量
#### 9.2、加锁
##### 0、
+ *lionel，没太看懂啊*
##### 9.2.1、造成并发执行的原因
+ 内核中有类似可能造成并发执行的原因。它们是
	+ 中断
	+ 软中断和tasklet
	+ 内核抢占
	+ 睡眠及与用户空间的同步
	+ 对称多处理
##### 9.2.2、了解要保护些什么
#### 9.3、死锁
#### 9.4、争用和扩展性
#### 9.5、小结