<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>《C++泛型STL原理和应用》 - lionel的技术笔记</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u300aC++\u6cdb\u578bSTL\u539f\u7406\u548c\u5e94\u7528\u300b";
        var mkdocs_page_input_path = "21STL\\C++\u6cdb\u578bSTL\u539f\u7406\u548c\u5e94\u7528.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> lionel的技术笔记
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../01daily/">daily</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../02ds/">ds</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../03cpp/">cpp</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../21tool/">cpp</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">C++</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/effectiveC%2B%2B/">《Effective C++》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">《深度探索C++对象模型》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../EffectiveSTL/">《Effective STL》</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">《C++泛型STL原理和应用》</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#chap1c-">chap1、C++泛型技术基础--模板</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#11">1.1 泛型和模板</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#111">1.1.1 泛型的概念</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#112-c">1.1.2 C++模板及其定义</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#113">1.1.3 几点说明和小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#12">1.2 关于模板参数</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#121">1.2.1 模板参数的种类</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#122">1.2.2 模板形参和实参的结合</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#13">1.3 特化模板和模板具现规则</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#131">1.3.1 特化(特列化)模板</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#132">1.3.2 模板的具现</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#14">1.4 右值引用和模板</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#141">1.4.1 右值引用</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#142-1-">1.4.2 右值引用的应用1--转移语义</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#143-2-move">1.4.3 右值引用的应用2--转移函数move()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#144-3-">1.4.4 右值引用的应用3--参数完美转发模板()</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap2c-">chap2、C++泛型机制的基石--数据类型表</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#21">2.1 类模板的公有数据类型成员</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#211">2.1.1 类的数据类型成员</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#212-typedef">2.1.2 再谈typedef</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#22">2.2 内嵌式数据类型表及数据类型衍生</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#23">2.3 数据类型表</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#231">2.3.1 数据类型表的概念</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#232">2.3.2 数据类型表的应用</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#24">2.4 特化数据类型表</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#25-stltraits">2.5 STL中的Traits表</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap3stlc">chap3、STL及其使用的其他C++技术</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#31-stl">3.1 初识STL</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#311stlc">3.1.1、STL是C++标准库中的模板类库</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#312stl">3.1.2、STL应用程序示例</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#32-stlc">3.2 STL常用的C++技术</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#321">3.2.1 运算符重载</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#322">3.2.2 函数对象（仿函数）</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#323-lambda">3.2.3 Lambda表达式</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#33">3.3 智能指针</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#331">3.3.1 智能指针的基本原理</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#332-c11">3.3.2 C++11支持的智能指针</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap4stl">chap4、模拟STL三大件</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#41">4.1、容器</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#411vectormyvector">4.1.1、向量vector的仿真MyVector</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#412listmylist">4.1.2、列表list的仿真MyList</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#42">4.2、迭代器</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#421">4.2.1、使用裸指针作为迭代器</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#422">4.2.2、迭代器是指针的类封装</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#423">4.2.3、迭代器的代码隔离作用</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#424stl">4.2.4、STL迭代器的种类</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#425">4.2.5、迭代器的种类标记</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#426stl">4.2.6、STL对迭代器的管理</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#43">4.3、通用算法</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap5">chap5、容器及其应用</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#51-vector">5.1 向量vector</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1vector">1、vector对象的定义及初始化</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#52list">5.2、列表list</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#53deque">5.3、双向队列deque</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#54stl">5.4、STL关联式容器</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1stlpair">1、关联式数据与STL二元组类模板pair</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2stl">2、STL对关联数据的组织与存储</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#55map">5.5、map容器</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#551map">5.5.1、map容器的定义</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#552map">5.5.2、map的数据插入</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#553map">5.5.3、map容器的其他常用成员方法</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#554multimap">5.5.4、multimap容器</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#56set">5.6、set容器</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#57hashhast">5.7、hash表基础及hast容器</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#571hash">5.7.1、hash表基础</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#572hash">5.7.2、hash容器</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap6">chap6、通用算法</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#61">6.1、通用算法的参数</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#611">6.1.1、算法的迭代器参数</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#612">6.1.2、辅助参数</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#613">6.1.3、谓词参数</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#62">6.2、算法时间复杂度</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#63">6.3、常用通用算法</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#631">6.3.1、查找和搜索算法</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#632">6.3.2、变异算法</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#633">6.3.3、排序算法</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#634">6.3.4、算术算法与关系算法</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#635">6.3.5、排列组合与集合算法</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap7stl">chap7、适配器模式在STL基础部件上的应用</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#71">7.1、适配器</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#72stl">7.2、STL容器适配器</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#721stack">7.2.1、stack适配器</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#722queue">7.2.2、queue适配器</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#723priority_queue">7.2.3、priority_queue适配器</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#73">7.3、迭代器适配器</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#731">7.3.1、插入迭代器</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#732">7.3.2、反向迭代器</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#733io">7.3.3、IO流迭代器</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#74">7.4、函数对象适配器</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#741">7.4.1、函数对象的适配</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#742">7.4.2、函数对象配接器</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap8stl">chap8、STL容器内存空间分配器</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#81">8.1、内存空间配置器及其设计基础</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#811">8.1.1、什么是内存空间配置器</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#812">8.1.2、内存空间配置器设计基础</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#82stl">8.2、STL空间配置器接口</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#821stl">8.2.1、STL空间配置器接口及最简单的空间配置器</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#822stl">8.2.2、典型STL容器空间的配置</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#83">8.3、内存池的概念及方法</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#831">8.3.1、内存池的规划</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#832">8.3.2、内存池的设计</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_1">附录</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#aexplicit">A、关于关键字explicit</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_2">勘误</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">《STL源码剖析》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../22C%2B%2Bmodern/%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8C%2B%2B11/">《深入应用C++11》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">基础知识</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">《操作系统导论》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">《大话设计模式》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90_C%2B%2B4th/">《数据结构与算法分析_C++4th》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E7%AE%97%E6%B3%95%284th%29/">《算法4th》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%BC%A0%E5%86%9B/">《算法设计与分析-张军》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E5%A4%A9%E8%A1%8C-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《天行-算法设计与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网络编程</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">《TCP/IP网络编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">《Linux高性能服务器编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71/">《TCPIP详解卷1》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90/">《Linux内核网络栈源代码情景分析》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C/">《深入理解Linux网络》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">文件系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/Linux%E5%86%85%E6%A0%B8%E6%8E%A2%E7%A7%98/">《Linux内核探秘》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《文件系统技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">《存储技术原理分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">存储</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../12storage/ceph%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《ceph设计原理与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">视频</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/FFmpeg%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">《FFmpeg入门到精通》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">《WebRTC权威指南》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AE%9E%E6%97%B6%E4%BA%92%E5%8A%A8%E6%8A%80%E6%9C%AF/">《WebRTC音视频实时互动技术》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/%E6%96%B0%E4%B8%80%E4%BB%A3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%A0%81%E6%A0%87%E5%87%86-H.264_AVC/">《新一代视频压缩码标准-H.264_AVC》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">内核</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《Linux内核设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/">《深入Linux设备驱动程序内核机制》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">《深入理解Linux虚拟内存管理》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《深入理解Linux网络技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90-tcpip%E5%AE%9E%E7%8E%B0/">《Linux内核源代码剖析-TCP/IP实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/">《深入理解Linux内核》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">工具</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/">《Wireshark网络分析实战》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%283rd%29/">《Linux命令行与shell脚本编程大全(3rd)》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%883rd%EF%BC%89/">《python程序设计（3rd）》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">刷题</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../91leetcode/%E5%89%91%E6%8C%87offer2nd/">《剑指offer2nd》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../91leetcode/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/">《剑指offer专项突破》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网课</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/01Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/">《Linux高并发网络编程开发》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/%E4%BE%AF%E6%8D%B7/%E4%BE%AF%E6%8D%B7C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8660%E8%AE%B2/">《侯捷C++内存管理60讲》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/11NJU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">《NJU算法设计与分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">英语专</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../60English/00794%E7%BB%BC%E5%90%88%E8%8B%B1%E8%AF%AD%E4%B8%80%E4%B8%8A/">《综合英语(一)上》</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">lionel的技术笔记</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>C++ &raquo;</li>
      <li>《C++泛型STL原理和应用》</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h2 id="cstl">《C++泛型STL原理和应用》<a class="headerlink" href="#cstl" title="Permanent link">&para;</a></h2>
<ul>
<li>书上<a href="https://gitee.com/fewolflion/BookNote/tree/master/01lioneloutput/60BookCode/C++%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8">代码</a></li>
<li>chap1、模板<ul>
<li>主要是概念类，自己搞清楚就行，理解一下<strong>特化</strong>，<em>auto与decltype，右值，转移语义，完美转发forward，要配合c++11再看下</em></li>
</ul>
</li>
<li>chap2、<ul>
<li>数据类型表、类型萃取机，不太熟悉，<em>简单的说，就是把所有类型都定义一遍，这样，类外就可以访问？lionel</em></li>
</ul>
</li>
<li>chap3、<ul>
<li><strong>运算符重载是基础</strong>，衍生了仿函数，lambda表达式，智能指针</li>
</ul>
</li>
<li>chap4、模拟STL三大件<ul>
<li>容器、迭代器、算法</li>
</ul>
</li>
</ul>
<h3 id="chap1c-">chap1、C++泛型技术基础--模板<a class="headerlink" href="#chap1c-" title="Permanent link">&para;</a></h3>
<ul>
<li>20201017</li>
</ul>
<h4 id="11">1.1 泛型和模板<a class="headerlink" href="#11" title="Permanent link">&para;</a></h4>
<h5 id="111">1.1.1 泛型的概念<a class="headerlink" href="#111" title="Permanent link">&para;</a></h5>
<ul>
<li>泛型（generic type）：就是一种通用类型。</li>
<li><code>template &lt;typenamet T&gt; T max( T x, T y) {}</code>  //这里T是类型<strong>占位符</strong>。</li>
<li>使用了类型占位符的代码称为<strong>“模板“</strong>，根据模板和具体类型生成的代码叫<strong>程序实体</strong>，产生程序实体的过程叫<strong>模板的具现</strong>。</li>
</ul>
<h5 id="112-c">1.1.2 C++模板及其定义<a class="headerlink" href="#112-c" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>模板</strong>：除了需要声明类型占位符之外，其它内容应与目标实体代码完全相同。 声明一个模板时，需在实体代码前面，加一条说明语句。<em>前面是template关键字。</em><ul>
<li>函数模板，1-1.cpp<ul>
<li><code>template&lt;typename T, typename R, typename S&gt;  T max(R x, S y){}</code>，<strong>早期关键字用class，现在用typename</strong>，调用的话是 <code>long max&lt;int, double&gt;(x,y);</code>，<em>都不确定是不是这么写了</em></li>
</ul>
</li>
<li>类模板，1-2.cpp<ul>
<li>在声明语句前加 <code>template&lt;typename T&gt;</code>  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="113">1.1.3 几点说明和小结<a class="headerlink" href="#113" title="Permanent link">&para;</a></h5>
<ul>
<li><code>template&lt;typename T&gt;</code> 早期也写成 <code>template&lt;class T&gt;</code>，但不支持这么写</li>
<li>C++11和14中，给关键字 <strong>auto</strong> 增加了新的语义，同时增加了 <strong>decltype表达式</strong> <ul>
<li>auto关键字是为自动推导数据类型所设 <code>auto i=100;</code></li>
<li>之前auto只对系统的内置数据推荐有效，现在利用<em>编译器的类型记忆能力</em>，可以记住自定义的类型。</li>
<li>变量类型难以确定的问题主要出现在函数的返回值上，因此函数的返回值类型的位置常常会出现auto关键字，称为 <strong>auto返回值占位</strong></li>
<li><code>auto Multiply(T t, U u)-&gt;decltype(t*u) {return t*u;}</code></li>
</ul>
</li>
<li>把auto看做数据类型的话，auto其实也可以算一种泛型，不过它无须关键字typename声明。</li>
<li>decltype表达式（用在声明和实现时），实现函数返回值类型的自动推导，<code>auto Multiply(T t V v)-&gt;decltype(t*v) {return t*v;}</code></li>
<li>C++新标准引入了<strong>变量模板</strong>的概念。<code>pi&lt;T&gt;</code> 【作者没有介绍更多，可以翻看C++11】</li>
</ul>
<h4 id="12">1.2 关于模板参数<a class="headerlink" href="#12" title="Permanent link">&para;</a></h4>
<ul>
<li>预编译期间进行传递并被编译的</li>
</ul>
<h5 id="121">1.2.1 模板参数的种类<a class="headerlink" href="#121" title="Permanent link">&para;</a></h5>
<ul>
<li>类型参数<ul>
<li>以类模板作为函数实参的例子 <code>MyTest&lt;Test1&lt;int&gt;&gt;TT;</code>，<strong>用关键字typename声明的参数</strong></li>
</ul>
</li>
<li>非类型参数，1-3.cpp<ul>
<li><code>template &lt;typename T，/*类型参数*/ int b/*非类型参数*/&gt;</code>，<strong>非类型参数可以定义时赋值，int b = 10</strong><ul>
<li>是常量，不能被修改</li>
<li>只能是int、枚举、指针、引用类型</li>
</ul>
</li>
</ul>
</li>
<li>模板定义型参数，1-4.cpp<ul>
<li>C++也允许以类模板的定义作为类模板参数<ul>
<li><strong>需要的目的：</strong> 除了强调这个参数的实参必须为类模板之外，还强调这个类模板所具有的参数个数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="122">1.2.2 模板形参和实参的结合<a class="headerlink" href="#122" title="Permanent link">&para;</a></h5>
<ul>
<li>函数模板实参的隐式提供<ul>
<li><code>add&lt;int&gt;(45,46);</code> 直接变成 <code>add(45,46);</code>，<strong>隐式实例化</strong>，显式的话可以<code>add&lt;double&gt;(45,10.3);</code>返回double类型</li>
</ul>
</li>
<li>指针实参<ul>
<li>在C++中，指针被看作一种数据类型。</li>
<li>见具体的代码； 【<em>作者没有描述，我还没太懂这部分</em>】</li>
</ul>
</li>
<li><em>函数模板实参的隐式提供</em></li>
<li>修饰字const和&amp;的使用<ul>
<li>见具体的代码示例； 【<em>没见过具体的应用场景</em>】</li>
</ul>
</li>
</ul>
<h4 id="13">1.3 特化模板和模板具现规则<a class="headerlink" href="#13" title="Permanent link">&para;</a></h4>
<h5 id="131">1.3.1 特化(特列化)模板<a class="headerlink" href="#131" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p><strong>特化(特列化)模板</strong>：为有特殊算法要求的数据类型另行编写模板</p>
<ul>
<li>通用模板：门票10块</li>
<li>特化模板：学生和老人半价</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>1、函数模板中的特化模板</p>
<ul>
<li>在实体代码前加以下声明 <code>tmplate&lt;&gt;</code></li>
</ul>
<pre class="highlight"><code class="language-cpp">tmplate&lt;&gt; //只是在原来实体代码前写一个模板声明
char* mymax(char* t1, char* t2) {
    return (strcmp(t1,t2)&lt;0)?t2:t1;
}</code></pre>
<ul>
<li>1-5.cpp，测试上述mymax函数模板并运行之</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>2、类模板的特化和偏特化</p>
<ul>
<li><strong>偏特化：</strong>只特化参数中的某一个或某几个</li>
<li>1-6.cpp，含有一个偏特化模板</li>
<li>偏特化模板的写法 <code>template&lt;typename T2&gt; struct Test&lt;int,T2&gt;{}</code></li>
<li>全特化模板的写法 <code>template&lt;&gt; struct Test&lt;int,float&gt;{}</code></li>
</ul>
</li>
</ul>
<h5 id="132">1.3.2 模板的具现<a class="headerlink" href="#132" title="Permanent link">&para;</a></h5>
<ul>
<li>因为有了以上泛型模块的共存，编译器就需要选择一个生成实体模块代码，就有了规则。</li>
<li>具体的优先顺序<ul>
<li>特化模板（函数或类）</li>
<li>偏特化模板（函数或类）</li>
<li>普通模板（函数或类）</li>
<li>系统</li>
</ul>
</li>
</ul>
<h4 id="14">1.4 右值引用和模板<a class="headerlink" href="#14" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>转移语义</strong>是C11推出的新概念和新技术。</li>
</ul>
<h5 id="141">1.4.1 右值引用<a class="headerlink" href="#141" title="Permanent link">&para;</a></h5>
<ul>
<li>临时对象具有了将资源转移到另一个对象，免去深拷贝的麻烦</li>
</ul>
<ul>
<li><strong>右值：</strong> 只能出现在赋值运算符右边。<em>仅能代表数据；匿名，无固定地址的对象。</em></li>
<li><strong>左值：</strong> 既可以出现在赋值运算符左边，又可以出现在赋值运算符右边。<em>有名字，有固定地址的表达式</em>，<strong>代表一块存储空间</strong></li>
<li>右值引用，1-8.cpp<ul>
<li>C11之前有两种表示方式 <code>T&amp; 别名 = lvalue;//引用</code> 和 <code>const T&amp; 别名 = lvalue;//常引用</code></li>
<li>C11之后仅定义一种：<code>const T&amp; 别名 = rvalue;</code><ul>
<li><em>强行为右值命名一个变量名，目的就是为延长右值生命期。</em> </li>
<li><strong>右值的非常量引用</strong> <code>T&amp;&amp; 名称=rvalue;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="142-1-">1.4.2 右值引用的应用1--转移语义<a class="headerlink" href="#142-1-" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>深拷贝</strong></li>
<li><strong>浅拷贝</strong></li>
</ul>
<h5 id="143-2-move">1.4.3 右值引用的应用2--转移函数move()<a class="headerlink" href="#143-2-move" title="Permanent link">&para;</a></h5>
<ul>
<li>右值引用有好处后，左值也想利用，move的原型 <code>T&amp;&amp; move(T&amp; val);</code></li>
</ul>
<h5 id="144-3-">1.4.4 右值引用的应用3--参数完美转发模板()<a class="headerlink" href="#144-3-" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>参数转发</strong></li>
<li>1 完美转发问题的提出及解决思路</li>
<li>2 模板参数类型推导规则--引用符折叠规则</li>
<li>3 参数类型正确转发的保证--forward()函数模板<ul>
<li><code>static_cast()</code>：这个转换只对参数为右值时有用。</li>
<li>C++11将<code>static_cast()</code>封装成函数模板std::forward，于是<code>Func(forwad&lt;T&gt;(a));</code></li>
</ul>
</li>
</ul>
<h3 id="chap2c-">chap2、C++泛型机制的基石--数据类型表<a class="headerlink" href="#chap2c-" title="Permanent link">&para;</a></h3>
<ul>
<li>20201017</li>
</ul>
<h4 id="21">2.1 类模板的公有数据类型成员<a class="headerlink" href="#21" title="Permanent link">&para;</a></h4>
<ul>
<li>原属模板私有的数据类型向外公开，使其成为一种“全局”类型。</li>
</ul>
<h5 id="211">2.1.1 类的数据类型成员<a class="headerlink" href="#211" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>类的数据类型成员</strong> ：在一个类中使用<code>typedef</code>定义一个已知数据类型的别名。 同时也称为 嵌入式类型(nested type)。</li>
</ul>
<ul>
<li>在C++中，这种在类模板中定义的数据类型也称为nested type，嵌入式，可以给相应访问属性</li>
</ul>
<ul>
<li>例2-1 定义了数据类型成员的类模板示例代码</li>
</ul>
<ul>
<li>前面要加<code>typename</code>关键字，为了与 类静态成员 写法相区分。</li>
</ul>
<ul>
<li><code>typedef long double LDBL;</code>，<strong>LDBL就是数据类型成员，简称类型成员</strong>。</li>
</ul>
<ul>
<li>类模板中定义的数据类型，也称为<strong>nested type（嵌入式类型）</strong>，既然是类中定义的，就有<code>public</code>这样的属性。</li>
</ul>
<ul>
<li>加一个<code>typename</code>以示，与<strong>引用类静态成员区别</strong></li>
</ul>
<ul>
<li>
<p><strong>C++规定，凡属于类型的名称前面还必须在类型名前面冠以关键字typename</strong></p>
<pre class="highlight"><code class="language-cpp">template &lt;typename T1, typename T2&gt;
class MyTraits{
public:
    typedef T1 my_Type1;
};
int main(){
    typename MyTraits&lt;int,double&gt;::my_Type1 a=100; //多一个typename，以示区别
    cout&lt;&lt;a&lt;&lt;endl;
    return 0;
}</code></pre>
</li>
</ul>
<h5 id="212-typedef">2.1.2 再谈typedef<a class="headerlink" href="#212-typedef" title="Permanent link">&para;</a></h5>
<ul>
<li>别名的好处<ul>
<li>增加可读性；</li>
<li>复杂名称起一个简单别名</li>
<li>编写平台无关的代码；   </li>
</ul>
</li>
</ul>
<h4 id="22">2.2 内嵌式数据类型表及数据类型衍生<a class="headerlink" href="#22" title="Permanent link">&para;</a></h4>
<ul>
<li>数据类型衍生：就是<code>T &amp;</code>和<code>T *</code></li>
<li>内嵌式数据类型：<strong>放在类前面</strong></li>
</ul>
<ul>
<li><strong>内嵌式数据类型表</strong>：一个类模板会把typedef定义的所有公有数据类型集中形成一个数据类型表，并放在类模板中靠前的位置。这个数据类型表存在于类模板内部。</li>
</ul>
<ul>
<li>例2-2 编写程序，演示内嵌数据类型表以及数据类型的外部引用。</li>
</ul>
<ul>
<li><em>不是太特别理解，lionel</em></li>
</ul>
<ul>
<li>
<p>```cpp
  template <typename T>
  class map{
  public:
      typedef T value_type;
      typedef T&amp; reference;
      typedef T* pointer;
  };</p>
<p>map<int>::value_type a=100;
```</p>
</li>
</ul>
<ul>
<li>相当于是<code>map&lt;int&gt;::</code><strong>这种别名的方式</strong>提供了value、reference、pointer的形式。</li>
</ul>
<ul>
<li>这种内嵌式数据类型表具有自模板传入类型衍生出其他相关类型的能力，所以也叫<strong>类型萃取机</strong>或<strong>类型榨取机</strong>。</li>
</ul>
<h4 id="23">2.3 数据类型表<a class="headerlink" href="#23" title="Permanent link">&para;</a></h4>
<h5 id="231">2.3.1 数据类型表的概念<a class="headerlink" href="#231" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>数据类型表</strong>：一个类模板中，其全部成员都是公有数据类型，那么相对于嵌入式数据类型表，这个类模板就叫做独立数据类型表，简称<strong>数据类型表</strong>。数据类型表是一种<strong>类模板</strong></li>
<li>例2-3</li>
<li>例2-4</li>
</ul>
<h5 id="232">2.3.2 数据类型表的应用<a class="headerlink" href="#232" title="Permanent link">&para;</a></h5>
<ul>
<li><em>要理解代码才行</em></li>
<li>2-5.cpp</li>
</ul>
<pre class="highlight"><code class="language-cpp">void T function(typename T::value_type x, typename T::reference y, typename T::pointer z) {}</code></pre>
<h4 id="24">2.4 特化数据类型表<a class="headerlink" href="#24" title="Permanent link">&para;</a></h4>
<ul>
<li>特化数据类型表作用<ul>
<li>实现同一业务逻辑不同接口的统一。 </li>
</ul>
</li>
<li>2-6.cpp，<em>没懂</em></li>
</ul>
<pre class="highlight"><code class="language-cpp">class Test1{
public:
    char Compute(int x, int y{
        return x;}
};

class Test2{
public:
    double Compute(int x, int y{
        return x;}
};

template&lt;typename Arg1, typename Arg2, typename Ret&gt;
class Test{
public:
    Ret Compute(Arg1 x, Arg2 y{
        return x;}
};//需要提供3个实参

class Test1; //为使用特化模板而定义的类名
class Test2;                
//统一接口
template &lt;typename T&gt;
class TypeTbl{};

//特化1
template&lt;&gt;
class TypeTbl&lt;Test1&gt; {
public:
    typedef char ret_type;
    typedef int par1_type;
    typedef double par2_type;
};

//特化2
template&lt;&gt;
class TypeTbl&lt;Test2&gt; {
public:
    typedef double ret_type;
    typedef double par1_type;
    typedef double par2_type;
};

template&lt;typename T&gt;
class Test {
public:
    typename TypeTbl&lt;T&gt;::ret_type Compute(
        typename TypeTbl&lt;T&gt;::par1_type x,
        typename TypeTbl&lt;T&gt;::par1_type y
    ) {
        return x;
    }
};

int main(){
    Test&lt;Test1&gt; t1;
    cout&lt;&lt;t1.Compute(62,88.5)&lt;&lt;endl;
    Test&lt;Test1&gt; t2;
    cout&lt;&lt;t2.Compute(2.26,66)&lt;&lt;endl;
    return 0;
}</code></pre>
<h4 id="25-stltraits">2.5 STL中的Traits表<a class="headerlink" href="#25-stltraits" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>迭代器是类模板，并在模板中包含内嵌数据类型表</strong></li>
</ul>
<ul>
<li><strong>Traits</strong>实质上是特化数据类型表在STL中的一个具体应用，也是数据类型表，但因为它构思巧妙，称Traits技巧。<ul>
<li>应用背景</li>
<li>使用特化模板实现指针的数据类型表</li>
<li>汇总同类类模板的内嵌数据类型表形成统一接口</li>
</ul>
</li>
<li>1、应用背景<ul>
<li>迭代器</li>
</ul>
</li>
<li>2、使用特化模板实现指针的数据类型表<ul>
<li>2-7.cpp</li>
</ul>
</li>
<li>3、汇总同类类模板的内嵌数据类型表形成统一接口<ul>
<li>2-8.cpp</li>
</ul>
</li>
</ul>
<h3 id="chap3stlc">chap3、STL及其使用的其他C++技术<a class="headerlink" href="#chap3stlc" title="Permanent link">&para;</a></h3>
<ul>
<li>20201017-20201018</li>
</ul>
<h4 id="31-stl">3.1 初识STL<a class="headerlink" href="#31-stl" title="Permanent link">&para;</a></h4>
<h5 id="311stlc">3.1.1、STL是C++标准库中的模板类库<a class="headerlink" href="#311stlc" title="Permanent link">&para;</a></h5>
<h5 id="312stl">3.1.2、STL应用程序示例<a class="headerlink" href="#312stl" title="Permanent link">&para;</a></h5>
<ul>
<li>例3-1：编写一个数组，里面存放10个随机产生的整型数，把其中的数据从大到小和从小到大排序，最后输出它们。<ul>
<li>对于这个例子，用到了STL的三大组件：<em>容器、迭代器、通用算法</em>。</li>
</ul>
</li>
</ul>
<h4 id="32-stlc">3.2 STL常用的C++技术<a class="headerlink" href="#32-stlc" title="Permanent link">&para;</a></h4>
<h5 id="321">3.2.1 运算符重载<a class="headerlink" href="#321" title="Permanent link">&para;</a></h5>
<ul>
<li>例3-2：定义一个复数类，并以友元函数方式为其重载一个全局加法运算符+，使它可以实现复数的加法运算。</li>
<li>例3-3：把例3-2中双目运算符+重载为类的成员函数。</li>
<li>例3-4：</li>
<li>例3-5： </li>
</ul>
<h5 id="322">3.2.2 函数对象（仿函数）<a class="headerlink" href="#322" title="Permanent link">&para;</a></h5>
<ul>
<li><code>sort(intVector.begin(), intVector.end(),greater&lt;int&gt;());</code></li>
<li>函数指针只代表1个函数，函数对象可以携带其它数据成员以及函数成员</li>
</ul>
<ul>
<li><a href="https://gitee.com/fewolflion/BookNote/blob/master/01lioneloutput/60BookCode/C++%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/chap3STL%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%B6%E4%BB%96C++%E6%8A%80%E6%9C%AF/E3-06.cpp">例3-6 函数对象作为函数参数的示例程序</a></li>
</ul>
<h5 id="323-lambda">3.2.3 Lambda表达式<a class="headerlink" href="#323-lambda" title="Permanent link">&para;</a></h5>
<ul>
<li>无名/匿名仿函数</li>
<li><a href="https://gitee.com/fewolflion/BookNote/blob/master/01lioneloutput/60BookCode/C++%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/chap3STL%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%B6%E4%BB%96C++%E6%8A%80%E6%9C%AF/E3-07.cpp">例3-7 lambda表达式与具有相同功能的仿函数的比较</a>。<strong>Lambda表达式</strong>又叫 <em>无名仿函数（或匿名仿函数）</em><ul>
<li><code>[](int x){cout &lt;&lt; 2*x &lt;&lt; endl;} // 相当于在声明function类的同时，又定义了定义该对象</code><ul>
<li><code>[]</code>，仿函数中运算符<code>()</code>的重载函数名，也叫<strong>lambda表达式前导符</strong></li>
<li><code>[]</code>里面“捕获列表”，<code>[]</code>，不捕获，<code>[=]</code>，值传递捕获，<code>[&amp;]</code>，引用捕获</li>
<li><code>int x</code>中的int，是个<strong>返回值类型</strong></li>
<li>void和auto关键字可以省略</li>
<li><strong>mutable关键字</strong></li>
</ul>
</li>
<li><code>[](int x){cout &lt;&lt; 2*x &lt;&lt; endl;}(10) //则是对象调用。</code></li>
</ul>
</li>
<li><a href="https://gitee.com/fewolflion/BookNote/blob/master/01lioneloutput/60BookCode/C++%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/chap3STL%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%B6%E4%BB%96C++%E6%8A%80%E6%9C%AF/E3-08.cpp">例3-8 多种lambda表达式调用示例程序</a>  </li>
<li><a href="https://gitee.com/fewolflion/BookNote/blob/master/01lioneloutput/60BookCode/C++%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/chap3STL%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%B6%E4%BB%96C++%E6%8A%80%E6%9C%AF/E3-09.cpp">例3-9 当用户输入一个15~20的数据时，输出2倍，否则输出本身</a></li>
<li>例3-10 两个可以修改捕获变量的lambda表达式的示例程序。<ul>
<li>示例1：演示了引用捕获的程序代码</li>
<li>示例2：演示了关键字mutable的应用</li>
</ul>
</li>
<li>例3-11 把lambda表达式应用于STL通用算法的一个程序示例</li>
<li><em>mutable与exception关键字，同时自己记住各种使用场景，lionel</em></li>
</ul>
<h4 id="33">3.3 智能指针<a class="headerlink" href="#33" title="Permanent link">&para;</a></h4>
<ul>
<li>把资源（内存）与指针对象的生命周期绑定起来，创建对象时立即为其分配资源，对象销毁时则立即释放资源</li>
</ul>
<h5 id="331">3.3.1 智能指针的基本原理<a class="headerlink" href="#331" title="Permanent link">&para;</a></h5>
<ul>
<li>1、指针对象与资源的绑定<ul>
<li><strong>RAII（Resource Acquisition is Initialization）</strong>，是把裸指针（原始指针）和与它相关的操作封装成一个类，在创建对象时调用构造函数，对象销毁时调用析构函数。重载了<code>opertaor-&gt;</code>和<code>operator *</code></li>
<li><a href="https://gitee.com/fewolflion/BookNote/blob/master/01lioneloutput/60BookCode/C++%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/chap3STL%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%B6%E4%BB%96C++%E6%8A%80%E6%9C%AF/E3-12.cpp">例3-12 编写一年智能指针示例程序</a></li>
</ul>
</li>
<li>2、可共享资源的智能指针<ul>
<li>多个指针指向同一个资源（计数器）</li>
<li>类中以友元类的方式指定了资源使用者的所属类SharePtr</li>
<li>第一次创建时，用裸指针进行初始化，计数器置1，以后每创建一个副本，再加1</li>
<li>创建时加1，销毁时减1，直到0为止。</li>
<li><a href="https://gitee.com/fewolflion/BookNote/blob/master/01lioneloutput/60BookCode/C++%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/chap3STL%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%B6%E4%BB%96C++%E6%8A%80%E6%9C%AF/E3-13.cpp">例3-13 编写一个演示程序</a></li>
</ul>
</li>
</ul>
<h5 id="332-c11">3.3.2 C++11支持的智能指针<a class="headerlink" href="#332-c11" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>C++98里的<code>auto_ptr</code>废弃了</strong>，不能放在容器中</li>
</ul>
<ul>
<li>1、unique_ptr<ul>
<li><strong>无法复制构造/复制赋值，可以移动构造/移动赋值</strong></li>
<li>0</li>
<li>unique_ptr用在如下场合<ul>
<li>利用动态指针的RAII特性，保证程序出现异常时能确保动态资源的释放</li>
<li>返回函数内创建的动态资源</li>
<li>可放在STL容器中</li>
<li>管理动态数组</li>
<li>自定义资源释放操作</li>
</ul>
</li>
</ul>
</li>
<li>2、shared_ptr<ul>
<li>2种方式创建shared_ptr<ul>
<li>通过make_shared辅助函数创建shared_ptr，<code>auto s_s = make_shared&lt;string&gt;("hello");</code></li>
<li>通过构造函数构建shared_ptr，</li>
</ul>
</li>
<li>使用<ul>
<li>在if语句中作为转移条件</li>
<li>定制资源销毁操作deleter</li>
</ul>
</li>
</ul>
</li>
<li>3、weak_ptr<ul>
<li>weak_ptr配合shared_ptr工作</li>
<li>没有重载operator-&gt;和operator<em>操作符，</em><em>不能直接通过weak_ptr使用对象</em>*</li>
<li><strong>两个类互为对方指针的资源类型，出现了所谓的“循环”引用</strong>，会造成计数器的计数失控，于是产生了<strong>可以共享资源，但不参与计数的weak_ptr来解决这种循环引用</strong></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;

struct B; //类前置声明
struct A{
    ~A(){
        cout&lt;&lt;"~A()"&lt;&lt;endl;
    }
    shared_ptr&lt;B&gt;b;
}

struct B{
    ~B(){
        cout&lt;&lt;"~B()"&lt;&lt;endl;
    }
    shared_ptr&lt;A&gt;a;  //循环引用，不可用
    //改成这样
    weak_ptr&lt;A&gt;a;//在先声明的B中用weak_ptr打破循环引用
}

int main(){
    shared_ptr&lt;A&gt; ap(new A);
    shared_ptr&lt;B&gt; bp(new B);
    ap-&gt;b = bp;
    bp-&gt;a = ap;
    return 0;
}</code></pre>
<h3 id="chap4stl">chap4、模拟STL三大件<a class="headerlink" href="#chap4stl" title="Permanent link">&para;</a></h3>
<ul>
<li>20201019</li>
</ul>
<h4 id="41">4.1、容器<a class="headerlink" href="#41" title="Permanent link">&para;</a></h4>
<h5 id="411vectormyvector">4.1.1、向量vector的仿真MyVector<a class="headerlink" href="#411vectormyvector" title="Permanent link">&para;</a></h5>
<ul>
<li>向量是单端开口的容器，其核心的数据存储装置（原始容器）是一个数组，<strong>开口位置在数组尾部</strong></li>
</ul>
<ul>
<li>例4-1.cpp</li>
</ul>
<h5 id="412listmylist">4.1.2、列表list的仿真MyList<a class="headerlink" href="#412listmylist" title="Permanent link">&para;</a></h5>
<ul>
<li>以链表为数据存储核心的容器，<strong>首尾双端开口容器</strong>，双向链表</li>
<li>例4-2.cpp</li>
</ul>
<h4 id="42">4.2、迭代器<a class="headerlink" href="#42" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>中介装置</strong>把容器与算法分离，这样的<strong>智能指针</strong>就叫<strong>迭代器</strong></li>
</ul>
<h5 id="421">4.2.1、使用裸指针作为迭代器<a class="headerlink" href="#421" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>以存储空间连续的数组为其存储结构的容器</strong></li>
<li><a href="https://gitee.com/fewolflion/BookNote/blob/master/01lioneloutput/60BookCode/C++%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/chap04%E6%A8%A1%E6%8B%9FSTL%E4%B8%89%E5%A4%A7%E4%BB%B6/04_03.cpp">例4-3.cpp，程序中定义一个<code>MyVector&lt;int&gt;</code>的对象v1，使用裸指针作为对象v1的迭代器并遍历v1</a><ul>
<li>与4-1的区别</li>
<li><code>typedef Ty* viter;</code>，以及<code>MyVector&lt;int&gt;::viter iter;</code> <em>这两个的转化过程，要好限理解一下，lionel</em></li>
</ul>
</li>
</ul>
<h5 id="422">4.2.2、迭代器是指针的类封装<a class="headerlink" href="#422" title="Permanent link">&para;</a></h5>
<ul>
<li>如果存储空间不连续，就需要<strong>加以改造（重载*，++，==，!=运算符）</strong></li>
<li>例4-4.cpp，为MyList容器设计迭代器MyList_iterator并编写程序进行测试</li>
</ul>
<h5 id="423">4.2.3、迭代器的代码隔离作用<a class="headerlink" href="#423" title="Permanent link">&para;</a></h5>
<ul>
<li>使用者无需知道</li>
<li>重载*，++，==，!=运算符（操作list）</li>
<li>例4-5.cpp，程序，使用上述查找函数find()分别在MyVector和MyList容器查找数据100</li>
</ul>
<h5 id="424stl">4.2.4、STL迭代器的种类<a class="headerlink" href="#424stl" title="Permanent link">&para;</a></h5>
<ul>
<li>0</li>
<li>1、输入迭代器（输入流，<strong>有以下功能</strong>）<ul>
<li>可复制，取出值，并自动指向下一个，判断是否最后一个，*，++，++(int)，!=，==</li>
</ul>
</li>
<li>2、输出迭代器<ul>
<li>除了同1外，还通过<code>operator*</code>对容器数据元素进行修改</li>
</ul>
</li>
<li>3、前向迭代器<ul>
<li>输入和输出迭代器的结合体，<code>operator*</code>既可以访问元素，也可以修改元素</li>
</ul>
</li>
<li>4、双向迭代器<ul>
<li>在前向迭代器的功能上，<strong>允许向后移动</strong>，支持<code>operator--</code>和<code>operator--(int)</code></li>
</ul>
</li>
<li>5、随机存取迭代器<ul>
<li>双向支持随机</li>
</ul>
</li>
</ul>
<h5 id="425">4.2.5、迭代器的种类标记<a class="headerlink" href="#425" title="Permanent link">&para;</a></h5>
<ul>
<li>0</li>
<li>输入迭代器，<code>struct input_iterator_tag{};</code></li>
<li>输出</li>
<li>前向</li>
<li>双向</li>
<li>随机，<code>struct random_access_iterator_tag:public bidirectional_iterator_tag {};</code></li>
<li>例4-6.cpp</li>
<li>例4-7.cpp</li>
</ul>
<h5 id="426stl">4.2.6、STL对迭代器的管理<a class="headerlink" href="#426stl" title="Permanent link">&para;</a></h5>
<ul>
<li>1、迭代器类模板的数据类型表</li>
<li>2、迭代器的类型总表traits</li>
<li>例4-8.cpp</li>
</ul>
<h4 id="43">4.3、通用算法<a class="headerlink" href="#43" title="Permanent link">&para;</a></h4>
<ul>
<li>例4-9.cpp</li>
<li>例4-10.cpp，使用例4-3中MyVector容器和上面设计的MySort()算法编写一个测试程序</li>
</ul>
<h3 id="chap5">chap5、容器及其应用<a class="headerlink" href="#chap5" title="Permanent link">&para;</a></h3>
<ul>
<li>20201104</li>
</ul>
<h4 id="51-vector">5.1 向量vector<a class="headerlink" href="#51-vector" title="Permanent link">&para;</a></h4>
<ul>
<li>占用连续内存，随机访问，下标和<code>at()</code>操作，<strong>尾部开口的设计</strong>，<code>push_back()</code>和<code>pop_back()</code>，重载了<code>operator=</code>，<strong>尾部操作效率最高</strong>（<em>也只有尾部能操作吧</em>）</li>
</ul>
<h5 id="1vector">1、vector对象的定义及初始化<a class="headerlink" href="#1vector" title="Permanent link">&para;</a></h5>
<ul>
<li>vector常用构造函数<ul>
<li><code>vector();</code></li>
<li><code>vector(vector&amp;&amp; _Right);</code></li>
<li><code>vector(size_type Count);</code></li>
<li><code>vector(size_type _Count, const Type&amp; val);</code></li>
<li><code>template&lt;class InputIterator&gt; vector(InputIterator _First,InputIterator _Last); // 以迭代器_First和_Last之间的元素初始化该向量</code></li>
</ul>
</li>
<li>例5-1 测试vector中的构造函数</li>
<li>读向量容器元素的操作<ul>
<li><code>reference front();  const_reference front() const;</code> 返回第一个元素</li>
<li><code>reference back();  const_reference back() const;</code> 返回最后一个元素</li>
</ul>
</li>
<li>各种用于改变向量容器中数据的成员函数<ul>
<li><code>clear()</code></li>
<li><code>erase(position)</code></li>
<li><code>insert()</code></li>
<li><code>push_back(elem)</code></li>
<li><code>pop_back()</code></li>
<li><code>resize(num)</code></li>
<li><code>resize(num,elem)</code></li>
</ul>
</li>
<li>例5-2 编写一个程序</li>
<li>表5-4：计算向量容器大小的操作<ul>
<li><code>bool empty() const;</code></li>
<li><code>size_type max_size() const;</code></li>
</ul>
</li>
<li>例5-3 编程程序，测试“表5-4：计算向量容器大小的操作”的成员函数，了解其功能</li>
<li>新特性<ul>
<li>初始化<code>vector&lt;int&gt; v1{1,2,3};</code>，支持这种写法</li>
<li>for遍历，引用传递<code>for(auto &amp;i :v1) i*=i;</code> ，平方操作后再返回</li>
</ul>
</li>
<li>例5-4 编写一个在vector上使用C++11新规则的程序。</li>
<li><a href="http://www.cplusplus.com/reference/vector/">cplusplus-vector</a></li>
<li><a href="http://www.cnblogs.com/wang7/archive/2012/04/27/2474138.html">C++ vector用法</a>  <em>不过，这个开始看还行，现在来看，差不多都会了，算法部分接触得少。</em></li>
</ul>
<h4 id="52list">5.2、列表list<a class="headerlink" href="#52list" title="Permanent link">&para;</a></h4>
<ul>
<li>核心是<strong>双向链表</strong>，<strong>头和尾插入和删除</strong>，<code>push_back()</code>还有<code>push_front()</code>，当然对有应的<code>pop_()</code>，<strong>不支持随机操作和<code>at()</code>操作，只能从到尾或从尾到头顺序地操作</strong></li>
<li>表5-5：使用list构造函数</li>
<li>表5-6：数据元素插入和删除<ul>
<li><code>assign()</code></li>
</ul>
</li>
<li>例5-5.cpp，在程序中观察push_front()、push_back()以及assign()函数的功能</li>
<li>表5-7，可以返回list关键迭代器的函数</li>
<li>表5-8，可以提供list状态的函数</li>
</ul>
<h4 id="53deque">5.3、双向队列deque<a class="headerlink" href="#53deque" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>双向开口</strong>，尾和头部操作的函数，<code>push_back()</code>还有<code>push_front()</code>，当然对有应的<code>pop_()</code>，<strong>类似于链表</strong>【分多个段，每个段内连续】</li>
<li>维护了一个<strong>map的指针数组</strong>，来维护段首地址，这样从map访问deque空间就是连续的，<em>lionel，具体的实现，还得看下代码</em></li>
<li>deque的特点<ul>
<li>支持随机访问（即支持下标<code>()</code>和<code>at()</code>），但性能没有vector好</li>
<li>可以在</li>
<li>两端</li>
<li>元素存取和迭代器操作会稍微慢一些，因为deque的内部结构会多一个间接过程</li>
<li>使用内存比vector和list合理</li>
</ul>
</li>
<li>表5-9：deque的常用构造函数</li>
<li>deque有以下两点与vector不同<ul>
<li>deque不提供容量操作<code>capacity()</code>和<code>reverse()</code></li>
<li>deque直接提供函数完成首尾元素的插入和删除</li>
</ul>
</li>
<li>需要注意的是<ul>
<li>除了<code>at()</code>函数，其它成员函数都不会检查索引或迭代器是否有效</li>
<li>元素的插入和删除可能会导致内存重新分配</li>
</ul>
</li>
<li>例5-6.cpp，测试deque的成员函数，并理解其特点</li>
</ul>
<h4 id="54stl">5.4、STL关联式容器<a class="headerlink" href="#54stl" title="Permanent link">&para;</a></h4>
<ul>
<li>带有键值的数据叫做关联式容器</li>
<li>数据本身并无顺序，那么容器的各数据元素存储单元就必须具有固定的顺序，为<strong>序列式容器</strong>，如果数据本身有序，则容器没有必要一定有序</li>
<li>原本无固定顺序的数据叫<strong>可序数据</strong>，具有固定顺序的数据叫<strong>已序数据</strong></li>
</ul>
<h5 id="1stlpair">1、关联式数据与STL二元组类模板pair<a class="headerlink" href="#1stlpair" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>关联数据</strong>，多个互相有关联的数据组合成的一个数组组，pair没有指定键值、实值</li>
</ul>
<ul>
<li>utility.h中的<code>pair()</code>，<strong>类模板</strong>，称为<strong>二元组</strong><ul>
<li>也可用<code>make_pair()</code>创建</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">pair&lt;string,int&gt; pr2("heaven",7);
pair&lt;string,int&gt; *prp = new pair&lt;string,int&gt;("yards",0);
//也可用`make_pair()`创建
typedef struct pair&lt;int,float&gt; PAIR_IF;
PAIR_IF pair1 = make_pair(18,3.14f);</code></pre>
<h5 id="2stl">2、STL对关联数据的组织与存储<a class="headerlink" href="#2stl" title="Permanent link">&para;</a></h5>
<ul>
<li>二分查找树，<em>后面没有完全再看看</em></li>
<li>平衡二叉树<ul>
<li>AVL树</li>
<li>红黑树</li>
</ul>
</li>
<li><em>还是需要把DS再看一下，复习下tree的章节，lionel</em></li>
</ul>
<h4 id="55map">5.5、map容器<a class="headerlink" href="#55map" title="Permanent link">&para;</a></h4>
<ul>
<li>以红黑树形式，<strong>pair形式出现的键-值对，叫做映射（map），set中的数据既是键值也是实值，叫做集合（set）</strong></li>
</ul>
<h5 id="551map">5.5.1、map容器的定义<a class="headerlink" href="#551map" title="Permanent link">&para;</a></h5>
<ul>
<li><em>还能带分配器，是啥意思，是不是之前的纸质笔记，写得有问题，lionel</em></li>
</ul>
<ul>
<li>例5-7.cpp，使用map的默认构造函数创建一个map对象，然后使用insert()函数向其中插入11个pair数据</li>
<li>例5-8.cpp</li>
<li>例5-9.cpp，使用不同的构造函数常见map容器</li>
</ul>
<h5 id="552map">5.5.2、map的数据插入<a class="headerlink" href="#552map" title="Permanent link">&para;</a></h5>
<ul>
<li>1、用insert函数插入pair数据<ul>
<li>例5-10.cpp</li>
</ul>
</li>
<li>2、insert()方法中指定数据类型的数据如下插入法<ul>
<li>例5-11.cpp</li>
<li><strong>当以重复键使用insert()方法插入数据时，只有第一次插入为有效操作，其后的所有都为无效操作，但编译器不报错</strong></li>
<li>例5-12.cpp，使用insert()的方法返回值判断插入操作的有效性</li>
</ul>
</li>
<li>3、以下标方式使用键值插入数据<ul>
<li>例5-13.cpp，以下标形式向map对象插入数据</li>
<li><strong>下标方式可以重复的键值输入数据，后面的输入将覆盖前面的实值</strong></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">map&lt;int,string&gt;mapStudent;
mapStudent[1]="student_one";</code></pre>
<h5 id="553map">5.5.3、map容器的其他常用成员方法<a class="headerlink" href="#553map" title="Permanent link">&para;</a></h5>
<ul>
<li>1、size()方法</li>
<li>2、count()和find()方法<ul>
<li>例5-14.cpp</li>
</ul>
</li>
<li>3、lower_bound()和upper_bound()方法<ul>
<li>例5-15.cpp</li>
</ul>
</li>
<li>4、erase()方法<ul>
<li>例5-16.cpp</li>
</ul>
</li>
</ul>
<h5 id="554multimap">5.5.4、multimap容器<a class="headerlink" href="#554multimap" title="Permanent link">&para;</a></h5>
<ul>
<li>例5-17.cpp，multimap容器应用示例程序</li>
</ul>
<h4 id="56set">5.6、set容器<a class="headerlink" href="#56set" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>set用来保存只有键值而没有实值这类数据的容器</strong>，也是红黑树，只不过各节点的数据是单一值而不是pair。</li>
<li>元素插入时会默认排序，**默认为<code>less&lt;&gt;</code>排序规则</li>
<li>例5-18.cpp，set容器应用示例程序</li>
</ul>
<h4 id="57hashhast">5.7、hash表基础及hast容器<a class="headerlink" href="#57hashhast" title="Permanent link">&para;</a></h4>
<h5 id="571hash">5.7.1、hash表基础<a class="headerlink" href="#571hash" title="Permanent link">&para;</a></h5>
<h5 id="572hash">5.7.2、hash容器<a class="headerlink" href="#572hash" title="Permanent link">&para;</a></h5>
<ul>
<li>C++11才纳入标准</li>
</ul>
<ul>
<li>例5-19.cpp，unordered_map的应用示例</li>
</ul>
<h3 id="chap6">chap6、通用算法<a class="headerlink" href="#chap6" title="Permanent link">&para;</a></h3>
<ul>
<li>20201104</li>
</ul>
<ul>
<li>模板技术解决了算法的<strong>类型通用</strong>，迭代器解决了算法的<strong>容器通用</strong></li>
</ul>
<h4 id="61">6.1、通用算法的参数<a class="headerlink" href="#61" title="Permanent link">&para;</a></h4>
<ul>
<li>STL通过两个措施保证了算法的通用性<ul>
<li>一是它把算法都设计成<strong>函数模板</strong>，从而依靠类型占位符保证了算法通用于各种参数类型</li>
<li>二是它用可以屏蔽容器结构与数据差异的<strong>迭代器</strong>来指定算法的操作数，从而保证算法通用于各类容器</li>
</ul>
</li>
<li>STL通用算法的3种参数<ul>
<li>算法的迭代器参数</li>
<li>辅助参数</li>
<li>谓词参数</li>
</ul>
</li>
</ul>
<h5 id="611">6.1.1、算法的迭代器参数<a class="headerlink" href="#611" title="Permanent link">&para;</a></h5>
<ul>
<li>两个迭代器指定一个区间</li>
<li>1、单区域操作数的迭代器参数<ul>
<li><code>sort(Vect.begin(),Vect.end());</code></li>
</ul>
</li>
<li>2、双区域操作数的迭代器参数<ul>
<li><code>result = find_first_of(Vect1.begin(), Vect1.end(),(Vect1.begin()+3),(Vect1.end()-2));</code></li>
<li>swap_ranger()注意事项</li>
</ul>
</li>
<li>3、迭代器类型对通用算法的限制及容器特有方法<ul>
<li>将迭代器从强到弱规范出5个种类（等级）的迭代器类型<ul>
<li>随机迭代器（random access）</li>
<li>双向迭代器（bidirectional）</li>
<li>前向迭代器（forward）</li>
<li>输入迭代器（input）</li>
<li>输出迭代器（output）</li>
</ul>
</li>
<li><em>本节，没太看懂全部啊，lionel</em></li>
</ul>
</li>
</ul>
<h5 id="612">6.1.2、辅助参数<a class="headerlink" href="#612" title="Permanent link">&para;</a></h5>
<ul>
<li>格式<ul>
<li><code>alg(__first,__last,__params);</code>，<strong>一般find()就这样</strong>，<code>result = find(Vect.begin(),Vect.end(),num_to_find);</code></li>
</ul>
</li>
</ul>
<h5 id="613">6.1.3、谓词参数<a class="headerlink" href="#613" title="Permanent link">&para;</a></h5>
<ul>
<li>STL算法可以<strong>函数、函数对象、lambda表达式</strong>作为参数，目的是，<strong>为了向算法传递用户自己的功能代码，从而便于实现通用算法的个性化和多样化</strong></li>
</ul>
<ul>
<li>1、什么是谓词及谓词参数<ul>
<li><strong>谓词</strong>就是一个功能模块代码</li>
<li><em>sort，重载预设的谓词，greater()</em></li>
</ul>
</li>
<li>2、谓词的实质是回调函数<ul>
<li><strong>调用</strong>：用户程序使用系统程序</li>
<li><strong>回调</strong>：系统程序使用用户程序</li>
<li><strong>回调函数</strong>：用户提供的为系统程序所调用的程序段</li>
<li>例6-1.cpp</li>
</ul>
</li>
<li>3、STL对谓词的规范<ul>
<li>一元、二元谓词<ul>
<li><code>struct unary_function{}</code></li>
<li><code>struct binary_function{}</code></li>
</ul>
</li>
<li>例6-2.cpp，按照unary_function格式定义谓词is_negative的程序示例</li>
<li><em>这里面有个疑问的，lionel</em>，<code>remove_if(Vect.begin(),Vect.end(),is_negative);</code>，<em>为什么后面的，不需要<code>()</code>了</em></li>
<li>常用的STL预设二元谓词模板<ul>
<li>less<T></li>
<li>less_equal<T></li>
<li>equal<T></li>
<li>not_equal<T></li>
<li>greater_equal<T></li>
<li>greater<T></li>
<li>not2<B></li>
</ul>
</li>
<li>上面的问题，就是<strong>谓词，与谓词函数的区别</strong>，目前啥区别，暂时不知道<ul>
<li><em>想到了，本身传的是函数名</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="62">6.2、算法时间复杂度<a class="headerlink" href="#62" title="Permanent link">&para;</a></h4>
<h4 id="63">6.3、常用通用算法<a class="headerlink" href="#63" title="Permanent link">&para;</a></h4>
<h5 id="631">6.3.1、查找和搜索算法<a class="headerlink" href="#631" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>不改变容器中数据</strong>，非变异算法</li>
<li>1、adjacent_find算法<ul>
<li>6-3.cpp</li>
</ul>
</li>
<li>2、binary_search算法</li>
<li>3、count和count_if<ul>
<li><strong>因为参数类型只是占位符，无法重载，后面加_if，表示需要谓词</strong></li>
<li>例6-5.cpp</li>
<li>例6-6.cpp，算法count_if()示例</li>
</ul>
</li>
<li>6-11.cpp</li>
</ul>
<h5 id="632">6.3.2、变异算法<a class="headerlink" href="#632" title="Permanent link">&para;</a></h5>
<ul>
<li>6-12.cpp</li>
<li>7、unique和unique_copy算法</li>
<li>8、fill和fill_n（向指定序列中填充指定数据，只不过指定被操作序列的方式不同）<ul>
<li>6-24.cpp</li>
</ul>
</li>
<li>9、generate和generate_n算法<ul>
<li>generate，使用谓词指定数据发生器产生的数据算法前两个参数容器指定的范围进行数据填充</li>
<li>generate_n，与上一样，<strong>不过，它使用操作区域，首迭代器和长度来指示数据填充区的范围</strong></li>
<li>6-25.cpp，</li>
</ul>
</li>
<li>10、transform算法，（使用参数中提供的谓词对指定序列进行变换，并将其结果复制到指定空间）<ul>
<li>6-26.cpp，</li>
</ul>
</li>
</ul>
<h5 id="633">6.3.3、排序算法<a class="headerlink" href="#633" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>带谓词，不带的区别</strong></li>
<li>1、merge和inplace_merge算法<ul>
<li>6_27.cpp</li>
<li>6_28.cpp，<strong>带有谓词</strong></li>
<li>6_29.cpp，inplace_merge，<strong>内部归并算法</strong>（对一个容器内部的两个方向相同的已序序列进行排序）</li>
</ul>
</li>
<li>2、</li>
<li>3、</li>
<li>4、</li>
<li>5、</li>
<li>6、reverse算法【容器中指定区域数据顺序进行反转】<ul>
<li>6-36.cpp，<code>reverse(Vect.begin(),Vect.end());</code></li>
</ul>
</li>
<li>7、rotate算法【被操作的序列的前半部分与后半部分交换】<ul>
<li>6_37.cpp，<code>rotate(Vect.begin(),Vect.begin()+8,Vect.end());</code> //Vect.begin()+8，表示 分界迭代器</li>
</ul>
</li>
</ul>
<h5 id="634">6.3.4、算术算法与关系算法<a class="headerlink" href="#634" title="Permanent link">&para;</a></h5>
<ul>
<li>1、accumulate算法【有<strong>附加参数</strong>，<strong>还可以带谓词</strong>】<ul>
<li>6-38.cpp，<code>accumulate(fVect.begin(),fVect.end(),0.0f);//0.0是附加参数</code></li>
</ul>
</li>
<li>2、partial_sum算法【指定序列求部分和<strong>并将结果组成新的序列</strong>】</li>
<li>3、</li>
<li>4、</li>
<li>5、</li>
<li>6、</li>
<li>7、max和min算法<ul>
<li>6_44.cpp</li>
<li><em>这两个也可以用谓词不，lionel</em></li>
</ul>
</li>
</ul>
<h5 id="635">6.3.5、排列组合与集合算法<a class="headerlink" href="#635" title="Permanent link">&para;</a></h5>
<ul>
<li>1、next_premutation和prev_permutation算法</li>
<li>2、set_union算法<ul>
<li>6_46.cpp</li>
<li><strong>集合算法</strong>中还有，set_intersection，set_difference，set_symmetric_difference</li>
</ul>
</li>
</ul>
<h3 id="chap7stl">chap7、适配器模式在STL基础部件上的应用<a class="headerlink" href="#chap7stl" title="Permanent link">&para;</a></h3>
<ul>
<li>20201031</li>
</ul>
<h4 id="71">7.1、适配器<a class="headerlink" href="#71" title="Permanent link">&para;</a></h4>
<ul>
<li>例子<ul>
<li>1、不提供基础功能，基础功能来自另一个对象，例如B的基础功能，全来自A</li>
<li>2、通过转换基础功能对外接口的形式向用户提供服务</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">class A {f1();f2();};
class B {A *a; g() {a-&gt;f1();a-&gt;f2();}};//模块B借助模块A，叫做B适配器</code></pre>
<h4 id="72stl">7.2、STL容器适配器<a class="headerlink" href="#72stl" title="Permanent link">&para;</a></h4>
<ul>
<li>stack、queue单向队列，priority_queue，优先权队列</li>
</ul>
<h5 id="721stack">7.2.1、stack适配器<a class="headerlink" href="#721stack" title="Permanent link">&para;</a></h5>
<ul>
<li>使用默认deque</li>
<li>使用vector或list</li>
<li>7-1.cpp：使用STL提供的stack适配器并用默认的deque构成栈</li>
</ul>
<pre class="highlight"><code class="language-cpp">deque&lt;int&gt; mydeque(3, 100); //创建具有3个元素 初始值100的队列
stack&lt;int&gt; Mystack2(mydeque); //创建一个栈用mydeque对其初始化   【这是适配器的精华？】lionel，核心是这个，那原因呢？</code></pre>
<ul>
<li>7-2.cpp：使用非默认的容器（list或vector）作为基础容器构造stack并测试它</li>
</ul>
<pre class="highlight"><code class="language-cpp">//使用list或vector作为栈的容器
stack&lt;int, list&lt;int&gt;&gt;a;  //这个用法，不太会呢？lionel，一般只放一个int或啥的
stack&lt;int, vector&lt;int&gt;&gt;b;</code></pre>
<h5 id="722queue">7.2.2、queue适配器<a class="headerlink" href="#722queue" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>双向</strong>，使用<strong>双端开口</strong>的list或deque作为核心，默认deque</li>
<li>7-3.cpp：对STL提供的queue适配器进行测试<ul>
<li><code>queue&lt;int&gt; b;</code><strong>表示其使用的是默认的基本容器</strong></li>
</ul>
</li>
</ul>
<h5 id="723priority_queue">7.2.3、priority_queue适配器<a class="headerlink" href="#723priority_queue" title="Permanent link">&para;</a></h5>
<ul>
<li><em>本节，未读</em></li>
<li>7-4.cpp：编写一个堆排序程序</li>
<li>7-5.cpp：测试priority_queue的构造函数</li>
<li>7-6.cpp：调用了优先权队列其他成员方法的程序示例</li>
</ul>
<h4 id="73">7.3、迭代器适配器<a class="headerlink" href="#73" title="Permanent link">&para;</a></h4>
<ul>
<li>迭代器适配器，在<strong>其类中封装了一个容器对象</strong>，但被适配的对象不是容器，而是<strong>附属容器的那个迭代器</strong>，因此，适配的结果就不再是容器适配器，而是迭代器适配器</li>
<li>迭代器适配器（3种）<ul>
<li>插入迭代器</li>
<li>反向遍历迭代器</li>
<li>IO流迭代器</li>
</ul>
</li>
</ul>
<h5 id="731">7.3.1、插入迭代器<a class="headerlink" href="#731" title="Permanent link">&para;</a></h5>
<ul>
<li>通常<strong>作为参数</strong>向算法说明向哪个容器以及在该容器的哪个位置插入数据。比如<code>copy算法</code></li>
</ul>
<ul>
<li>反向插入，back_insert</li>
</ul>
<ul>
<li>
<p>1、insert_iterator</p>
<ul>
<li>插入迭代器，<strong>其实隐含了一个容器</strong></li>
</ul>
<pre class="highlight"><code class="language-cpp">insert_iterator{
    _Container&amp; __x, typename __Container::iterator __i):Container(&amp;__x),iter(__i) ()
}</code></pre>
<ul>
<li>7-7.cpp：vector容器Vect，把3之后的数据插入到list容器Lst中的数据</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">vector&lt;int&gt; Vect{ 1,2,3,4,5,6,7,8,9,10 };  //lionel,初始化的方式
//定义插入迭代器insert_it并使其指向被插入容器的待插入位置
insert_iterator&lt;vector&lt;int&gt;&gt;  insert_it(Vect, Vect.begin() + 3);
//将源数据对象中的数据插入迭代器指示的位置
copy(Lst.begin(), Lst.end(), insert_it);</code></pre>
<ul>
<li>2、front_insert_iterator和back_insert_iterator<ul>
<li><strong>默认的插入迭代器</strong>，插入位置为目标的头部或尾部</li>
<li><strong>只有当容器提供push_front操作时，才能使用front_inserter</strong></li>
<li>7-8.cpp：使用front_insert_iterator和back_insert_iterator迭代器实现数据的插入</li>
</ul>
</li>
</ul>
<h5 id="732">7.3.2、反向迭代器<a class="headerlink" href="#732" title="Permanent link">&para;</a></h5>
<ul>
<li>reverse_iterator</li>
<li>定义的格式，<code>vector&lt;int&gt;::reverse_iterator rpos(Vect.end());</code></li>
<li>7-9.cpp：观察正向和反向迭代器之间的关系</li>
<li>7-10.cpp：使用了rbegin()和rend()操作的反向迭代器应用程序示例</li>
</ul>
<h5 id="733io">7.3.3、IO流迭代器<a class="headerlink" href="#733io" title="Permanent link">&para;</a></h5>
<ul>
<li>1、输出流迭代器适配器ostream_iterator<ul>
<li>7-11.cpp</li>
</ul>
</li>
<li>2、输入流迭代器适配器istream_iterator<ul>
<li>7-12.cpp</li>
<li>7-13.cpp，从标准设备中输入一些内容，然后用这些数据对一个向量容器进行初始化，然后显示初始化结果</li>
</ul>
</li>
</ul>
<ul>
<li>输入流，instream</li>
<li>输出流，ostream</li>
<li>输入缓冲，istreambuf_</li>
<li>输出缓冲，ostreambuf_</li>
</ul>
<h4 id="74">7.4、函数对象适配器<a class="headerlink" href="#74" title="Permanent link">&para;</a></h4>
<h5 id="741">7.4.1、函数对象的适配<a class="headerlink" href="#741" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>函数对象的适配器仍然是一个函数对象</strong></li>
</ul>
<ul>
<li>7-14.cpp，在算法remove_if中验证一元函数对象greater_l的正确性</li>
<li>7-15.cpp，在算法remove_if中验证第二参数绑定适配器binder2nd的正确性</li>
</ul>
<h5 id="742">7.4.2、函数对象配接器<a class="headerlink" href="#742" title="Permanent link">&para;</a></h5>
<ul>
<li>例7-16.cpp，在算法remove_if中验证配接器bind2nd的功能</li>
<li>1、简单配接器<ul>
<li>表7-4，简单配接器</li>
<li>例7-17.cpp，在算法remove_if中验证配接器bind2nd的功能</li>
<li>例7-18.cpp，在算法sort中验证配接器not2的功能</li>
</ul>
</li>
<li>2、对成员函数进行配接的函数配接器<ul>
<li>表7-5，对成员函数进行配接的函数配接器<ul>
<li><code>mem_fun_ref(op)</code>，调用op，op是某对象的一个const成员函数</li>
</ul>
</li>
<li>例7-19，验证配接器mem_fun_ref(op)和mem_fun(op)的功能<ul>
<li><code>for_each(coll.begin(),coll.end(),mem_fun_ref(&amp;testCls::print));</code></li>
</ul>
</li>
</ul>
</li>
<li>3、针对一般函数（非成员函数）而设计的函数配接器<ul>
<li>表7-6，针对一般函数（非成员函数）而设计的函数配接器</li>
<li>例7-20，验证配接器mem_fun_ref(op)和mem_fun(op)的功能</li>
</ul>
</li>
<li>4、用户自定义函数对象配接器<ul>
<li>例7-21，定义一个用户函数对象并在transform算法中利用配接器将其作为谓词使用</li>
</ul>
</li>
</ul>
<h3 id="chap8stl">chap8、STL容器内存空间分配器<a class="headerlink" href="#chap8stl" title="Permanent link">&para;</a></h3>
<ul>
<li>20201031</li>
</ul>
<h4 id="81">8.1、内存空间配置器及其设计基础<a class="headerlink" href="#81" title="Permanent link">&para;</a></h4>
<h5 id="811">8.1.1、什么是内存空间配置器<a class="headerlink" href="#811" title="Permanent link">&para;</a></h5>
<ul>
<li>内存的静态分配，动态分配</li>
</ul>
<ul>
<li>封装了动态请求内存空间的代码，以函数的形式向容器提供了内存空间的请求与释放，不用new本身，而用<code>operator new()</code>和<code>spacement new()</code></li>
</ul>
<h5 id="812">8.1.2、内存空间配置器设计基础<a class="headerlink" href="#812" title="Permanent link">&para;</a></h5>
<ul>
<li>1、容器内存空间的结构及配置器设计思路<ul>
<li>连续的数组，vector</li>
<li>非连续的链表，list</li>
<li>多个连续空间组成的链表模式，deque</li>
</ul>
</li>
<li>2、内存空间配置器设计技术<ul>
<li>例8-1.cpp</li>
</ul>
</li>
</ul>
<h4 id="82stl">8.2、STL空间配置器接口<a class="headerlink" href="#82stl" title="Permanent link">&para;</a></h4>
<ul>
<li>处于容器与OS内存管理系统之间</li>
</ul>
<h5 id="821stl">8.2.1、STL空间配置器接口及最简单的空间配置器<a class="headerlink" href="#821stl" title="Permanent link">&para;</a></h5>
<ul>
<li>1、STL空间配置器接口内容<ul>
<li><strong>接口</strong>：就一个程序部件提供给用户的那些函数</li>
</ul>
</li>
<li>2、</li>
<li>3、内部不同数据类型数据的空间配置器</li>
</ul>
<h5 id="822stl">8.2.2、典型STL容器空间的配置<a class="headerlink" href="#822stl" title="Permanent link">&para;</a></h5>
<ul>
<li>例8-2.cpp，使用向量容器对上述容器内存空间配置器进行测试，在测试中编写必要的测试代码以显示配置器的工作过程</li>
<li>例8-3.cpp，修改8-2.cpp，请使用list容器来测试上述内存空间配置器</li>
</ul>
<h4 id="83">8.3、内存池的概念及方法<a class="headerlink" href="#83" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>内存池</strong>就是应用程序从系统那里批发来的内存空间。防止内存碎片、用内存块组成内存池（形成链表）</li>
</ul>
<h5 id="831">8.3.1、内存池的规划<a class="headerlink" href="#831" title="Permanent link">&para;</a></h5>
<h5 id="832">8.3.2、内存池的设计<a class="headerlink" href="#832" title="Permanent link">&para;</a></h5>
<ul>
<li>1、MemoryBlock的设计</li>
<li>2、MemoryPool的设计<ul>
<li>例8-5.cpp</li>
</ul>
</li>
</ul>
<h3 id="_1">附录<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<h4 id="aexplicit">A、关于关键字explicit<a class="headerlink" href="#aexplicit" title="Permanent link">&para;</a></h4>
<ul>
<li>类的单参数构造函数能实现一个隐式转换，<strong>加上explicit，就禁止转换</strong>，<code>explicit Test(int x){a = x;}</code>，本来是支持<code>Test a=10;//现在就不行</code>，只能使用<code>Test a1(10);</code></li>
</ul>
<h3 id="_2">勘误<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<ul>
<li>264页，代码中有2处<code>cout &lt;&lt; a.front() &lt;&lt; " " &lt;&lt; a.back() &lt;&lt; endl;</code>，第2行的输出应该改成<code>cout &lt;&lt; b.front() &lt;&lt; " " &lt;&lt; b.back() &lt;&lt; endl;</code></li>
</ul>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../EffectiveSTL/" class="btn btn-neutral float-left" title="《Effective STL》"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="btn btn-neutral float-right" title="《STL源码剖析》">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../EffectiveSTL/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
