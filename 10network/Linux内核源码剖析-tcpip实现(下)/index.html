<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Linux内核源码剖析 tcpip实现(下) - lionel的技术笔记</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Linux\u5185\u6838\u6e90\u7801\u5256\u6790 tcpip\u5b9e\u73b0(\u4e0b)";
        var mkdocs_page_input_path = "10network\\Linux\u5185\u6838\u6e90\u7801\u5256\u6790-tcpip\u5b9e\u73b0(\u4e0b).md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> lionel的技术笔记
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../01daily/">daily</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../02ds/">ds</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../03cpp/">cpp</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../21tool/">tool</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">C++</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/effectiveC%2B%2B/">《Effective C++》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">《深度探索C++对象模型》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/EffectiveSTL/">《Effective STL》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/C%2B%2B%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/">《C++泛型STL原理和应用》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">《STL源码剖析》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../22C%2B%2Bmodern/%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8C%2B%2B11/">《深入应用C++11》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">基础知识</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">《操作系统导论》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">《大话设计模式》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90_C%2B%2B4th/">《数据结构与算法分析_C++4th》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E7%AE%97%E6%B3%95%284th%29/">《算法4th》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%BC%A0%E5%86%9B/">《算法设计与分析-张军》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E5%A4%A9%E8%A1%8C-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《天行-算法设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B-%E6%9D%8E%E6%98%A5%E8%91%86/">《数据结构教程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%96%B0%E7%BC%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E4%B8%8E%E8%A7%A3%E6%9E%90/">《新编数据结构习题与解析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网络编程</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../TCPIP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">《TCP/IP网络编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">《Linux高性能服务器编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71/">《TCPIP详解卷1》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90/">《Linux内核网络栈源代码情景分析》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C/">《深入理解Linux网络》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">机器&深度学习</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../30machineLearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/">《机器学习线性代数基础》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../31deepLearning/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%9A%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《深度学习入门：基于Python的理论与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">文件系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/Linux%E5%86%85%E6%A0%B8%E6%8E%A2%E7%A7%98/">《Linux内核探秘》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《文件系统技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">《存储技术原理分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">存储</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../12storage/ceph%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《ceph设计原理与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">视频</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/FFmpeg%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">《FFmpeg入门到精通》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">《WebRTC权威指南》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AE%9E%E6%97%B6%E4%BA%92%E5%8A%A8%E6%8A%80%E6%9C%AF/">《WebRTC音视频实时互动技术》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/%E6%96%B0%E4%B8%80%E4%BB%A3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%A0%81%E6%A0%87%E5%87%86-H.264_AVC/">《新一代视频压缩码标准-H.264_AVC》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">内核</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《Linux内核设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/">《深入Linux设备驱动程序内核机制》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">《深入理解Linux虚拟内存管理》</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../13kernel/深入理解Linux网络技术内幕.md">《深入理解Linux网络技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../13kernel/Linux内核源代码剖析-tcpip实现.md">《Linux内核源代码剖析-TCP/IP实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/">《深入理解Linux内核》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">工具</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/">《Wireshark网络分析实战》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%283rd%29/">《Linux命令行与shell脚本编程大全(3rd)》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%883rd%EF%BC%89/">《python程序设计（3rd）》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/python/Python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/">《Python编程从入门到实践》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">刷题</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../91leetcode/%E5%89%91%E6%8C%87offer2nd/">《剑指offer2nd》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../91leetcode/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/">《剑指offer专项突破》</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../96output/OD基础题.md">OD基础题</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../96output/OD进阶题.md">OD进阶题</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网课</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/01Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/">《Linux高并发网络编程开发》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/%E4%BE%AF%E6%8D%B7/%E4%BE%AF%E6%8D%B7C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8660%E8%AE%B2/">《侯捷C++内存管理60讲》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/11NJU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">《NJU算法设计与分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">英语专</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../60English/00794%E7%BB%BC%E5%90%88%E8%8B%B1%E8%AF%AD%E4%B8%80%E4%B8%8A/">《综合英语(一)上》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../95selfStudy/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/">《概率率与数理统计》</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">lionel的技术笔记</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
      <li>Linux内核源码剖析 tcpip实现(下)</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h2 id="linux-tcpip">《Linux内核源码剖析-TCP/IP实现》（下）<a class="headerlink" href="#linux-tcpip" title="Permanent link">&para;</a></h2>
<ul>
<li>2.6.20代码</li>
<li>https://lxr.missinglinkelectronics.com/</li>
<li>下册（20-33章）</li>
<li>https://elixir.bootlin.com/linux/latest/source 【这是最新版的】</li>
</ul>
<h3 id="readme">ReadMe<a class="headerlink" href="#readme" title="Permanent link">&para;</a></h3>
<h4 id="01">0.1、下册讲的内容<a class="headerlink" href="#01" title="Permanent link">&para;</a></h4>
<h5 id="011">0.1.1、我自己想的<a class="headerlink" href="#011" title="Permanent link">&para;</a></h5>
<ul>
<li>从四层的角度来说，下册讲了<strong>网络层（25-32TCP，33UDP）、socket层（22-24）</strong>，还有就是<strong>IP中的路由（20-21，还有上册的19）</strong></li>
<li>从用户态的角度来说（<em>这个算自己的扩展</em>）也就几方面内容<ul>
<li>posix api</li>
<li>阻塞IO（socket都是阻塞的）</li>
<li>非阻塞IO（<em>如何做到非阻塞</em>）</li>
<li>IO多路复习（select、poll、epoll各自表示啥，有啥差异）</li>
</ul>
</li>
<li>ref1中的<strong>Socket Layer</strong>讲到的数据结构，<strong>要把这个层次关系搞懂</strong>，<em>有了这个图后，再去理解（传输控制块）和（套接口层），就相对更直观些</em><ul>
<li>socket</li>
<li>sock</li>
<li>inet_sock、raw_sock、inet_connection_sock</li>
<li>tcp_sock、udp_sock</li>
</ul>
</li>
<li>ref1中的<strong>路由系统</strong>，<em>这部分，感觉没太对上</em><ul>
<li>更多是对chap21、路由策略</li>
</ul>
</li>
<li>ref3中的路由<strong>只是讲代码，没有理清逻辑来</strong></li>
</ul>
<h5 id="ref">ref<a class="headerlink" href="#ref" title="Permanent link">&para;</a></h5>
<ul>
<li>1、<a href="https://www.cnblogs.com/windyrainy/p/16663141.html">Linux Kernel TCP/IP Stack|Linux网络硬核系列</a> ，这个流程图画得特别好</li>
<li>2、<a href="https://cn.chinadaily.com.cn/a/202311/06/WS654875afa310d5acd876d713.html">挖掘潜力 拥抱挑战 第二届OpenHarmony技术大会OS内核及视窗分论坛召开</a>，<em>不太确定，魏勇军是不是搞网络相关了，看了eBPF</em><ul>
<li>https://blog.csdn.net/digi2020/article/details/127663340 <em>eBPF</em>（extended Berkeley Packet Filter）</li>
<li><a href="https://blog.csdn.net/ss810540895/article/details/129710256">eBPF介绍</a>，tcpdump就基于BPF实现的</li>
</ul>
</li>
<li>3、路由相关 <a href="https://blog.csdn.net/shanshanpt/article/details/19918171">Linux 内核网络协议栈 ----- Linux 内核路由机制（一） (2.6.25)</a>  <em>这只是讲代码，没有理出逻辑来</em><ul>
<li>二，https://blog.csdn.net/shanshanpt/article/details/20699543d</li>
</ul>
</li>
</ul>
<h4 id="02">0.2、各章的内容<a class="headerlink" href="#02" title="Permanent link">&para;</a></h4>
<h5 id="29tcp_inputctcp_outputctcp_congc">29、拥塞控制，<em>更多的实现，还是在tcp_input.c和tcp_output.c中，多拥塞，对应的是tcp_cong.c</em><a class="headerlink" href="#29tcp_inputctcp_outputctcp_congc" title="Permanent link">&para;</a></h5>
<h5 id="30tcp_outputc">30、输出，tcp_output.c<a class="headerlink" href="#30tcp_outputc" title="Permanent link">&para;</a></h5>
<h3 id="chap20-110529">chap20、路由缓存  1（10/529）<a class="headerlink" href="#chap20-110529" title="Permanent link">&para;</a></h3>
<ul>
<li>缓存的主要工作是存储使路由子系统能够找到报文目的地的信息，并通过一组函数向更高层提供该信息。</li>
</ul>
<ul>
<li>路由缓存涉及到的文件<ul>
<li>include/net/route.h，定义目的路由缓存项</li>
<li>include/net/flow.h，定义查询路由缓存的条件组合结构、宏和函数原型等</li>
<li>include/net/dst.h，定义目的路由缓存项的部分结构、宏、函数等</li>
<li>net/ipv4/route.c，实现路由缓存项的操作函数</li>
</ul>
</li>
</ul>
<h4 id="201">20.1、系统参数<a class="headerlink" href="#201" title="Permanent link">&para;</a></h4>
<ul>
<li>系统参数（有11个）<ul>
<li>flush，控制路由缓存的刷新</li>
</ul>
</li>
</ul>
<h4 id="202">20.2、路由缓存的组织结构<a class="headerlink" href="#202" title="Permanent link">&para;</a></h4>
<ul>
<li>路由缓存是用一张<strong>散列表</strong>来实现的，路由缓存散列表的类型是<strong>rt_hash_bucket结构</strong>，该结构只包含<strong>指向缓存元素链表的一个指针</strong>。缓存项的类型为rtable结构</li>
</ul>
<h5 id="2021rtable">20.2.1、rtable结构<a class="headerlink" href="#2021rtable" title="Permanent link">&para;</a></h5>
<ul>
<li>查看<code>/proc/net/rt_cache</code>文件，或者通过<code>ip route list cache</code>和<code>route -C</code>来列出路由缓存的内容</li>
</ul>
<h5 id="2022flowi">20.2.2、flowi结构<a class="headerlink" href="#2022flowi" title="Permanent link">&para;</a></h5>
<ul>
<li>根据诸如输入网络设备和输出网络设备、三层和四层协议报头中的参数等字段的组合对流量进行分类。</li>
</ul>
<h5 id="2023dst_entry">20.2.3、dst_entry结构<a class="headerlink" href="#2023dst_entry" title="Permanent link">&para;</a></h5>
<ul>
<li>dst_entry结构被用于存储缓存路由项中独立于协议的信息。</li>
</ul>
<h5 id="2024dst_ops">20.2.4、dst_ops结构<a class="headerlink" href="#2024dst_ops" title="Permanent link">&para;</a></h5>
<ul>
<li>dst_ops结构是使用路由缓存的三层协议与独立于协议的缓存之间的接口</li>
</ul>
<h4 id="203">20.3、初始化<a class="headerlink" href="#203" title="Permanent link">&para;</a></h4>
<ul>
<li>由<code>ip_rt_init()</code>进行初始化的   11（20/529）</li>
</ul>
<h4 id="204">20.4、创建路由缓存项<a class="headerlink" href="#204" title="Permanent link">&para;</a></h4>
<p>20.5、添加路由表项到缓存中</p>
<p>20.6、输入路由缓存查询</p>
<p>20.7、输出路由缓存查询</p>
<p>20.7.1、ip_route_output_key()</p>
<h4 id="208">20.8、垃圾回收<a class="headerlink" href="#208" title="Permanent link">&para;</a></h4>
<h4 id="209">20.9、刷新缓存<a class="headerlink" href="#209" title="Permanent link">&para;</a></h4>
<h5 id="131tsogso">1.3.1、TSO/GSO<a class="headerlink" href="#131tsogso" title="Permanent link">&para;</a></h5>
<h5 id="132io-at">1.3.2、I/O AT<a class="headerlink" href="#132io-at" title="Permanent link">&para;</a></h5>
<h5 id="141slab">1.4.1、slab分配器<a class="headerlink" href="#141slab" title="Permanent link">&para;</a></h5>
<h5 id="2097procflush">20.9.7、通过写/proc的flush文件<a class="headerlink" href="#2097procflush" title="Permanent link">&para;</a></h5>
<h4 id="2010icmp">20.10、ICMP重定向消息的处理<a class="headerlink" href="#2010icmp" title="Permanent link">&para;</a></h4>
<h4 id="2011icmp">20.11、ICMP目的不可达，需要分片<a class="headerlink" href="#2011icmp" title="Permanent link">&para;</a></h4>
<h3 id="chap21">chap21、路由策略<a class="headerlink" href="#chap21" title="Permanent link">&para;</a></h3>
<ul>
<li><em>感觉目录，是从上层往下层的，lionel</em></li>
</ul>
<p>2.1、引言</p>
<p>2.2、协议简介</p>
<p>2.3、网络架构</p>
<p>2.4、系统调用接口</p>
<p>2.5、协议无关接口</p>
<h4 id="216">21.6、路由策略的查找<a class="headerlink" href="#216" title="Permanent link">&para;</a></h4>
<h3 id="chap22-5665529">chap22、套接口层  56（65/529）<a class="headerlink" href="#chap22-5665529" title="Permanent link">&para;</a></h3>
<ul>
<li>套接口是啥<ul>
<li>1983年，4.2BSD引入</li>
<li><strong>通用的网络应用程序编程接口</strong></li>
</ul>
</li>
<li>套接口包含啥？<ul>
<li><em>本书好像没讲？</em></li>
</ul>
</li>
</ul>
<ul>
<li>套接口层的作用<ul>
<li><strong>为应用程序提供了一个访问网络和进程间通信的</strong>通用接口</li>
<li>位于<strong>应用程序和协议栈</strong>之间</li>
<li>对应用程序屏蔽了与协议相关实现的具体细节，将应用程序发送的与协议无关的请求映射到与协议相关的实现</li>
</ul>
</li>
<li>套接口层怎么与其上下层衔接<ul>
<li>应用程序中调用库函数，而库函数通过系统调用进入套接口层</li>
<li>Linux套接口层实现提供了一组<strong>专门的套接口系统调用</strong></li>
<li><strong>图22-1</strong>（套接口层将一般的请求转换为指定的协议操作）</li>
</ul>
</li>
<li>套接口的I/O操作以及套接口选项（23，24两章介绍的）</li>
<li>涉及文件<ul>
<li>include/linux/net.h，定义套接口层相关的结构、宏和函数原型</li>
<li>include/net/sock.h，定义基本的传输控制块结构、宏和函数原型</li>
<li>net/socket.c，实现套接口层的调用</li>
<li>net/ipv4/af_inet.c，网络层和传输层接口</li>
</ul>
</li>
</ul>
<h4 id="221socket">22.1、socket结构<a class="headerlink" href="#221socket" title="Permanent link">&para;</a></h4>
<ul>
<li><code>struct socket{};</code></li>
</ul>
<h4 id="222proto_ops">22.2、proto_ops结构<a class="headerlink" href="#222proto_ops" title="Permanent link">&para;</a></h4>
<ul>
<li>是一组与套接口系统调用相对应的传输层函数指针，可以看作是<strong>一张套接口系统调用到传输层函数的跳转表</strong></li>
<li>完成的是<strong>从与协议无关的套接口层到协议相关的传输层</strong>的转接，proto结构又将<strong>传输层映射到网络层</strong>，那么可想而知<strong>每个传输层的协议都需要定义一个特定的proto_ops结构实例和proto结构实例</strong>。</li>
</ul>
<h4 id="223">22.3、套接口文件系统<a class="headerlink" href="#223" title="Permanent link">&para;</a></h4>
<h5 id="2231">22.3.1、套接口文件系统类型<a class="headerlink" href="#2231" title="Permanent link">&para;</a></h5>
<ul>
<li>sockfs文件系统类型<code>sock_fs_type</code>，通过<code>get_sb()</code>和<code>alloc_inode()</code>和<code>destroy_inode()</code>分配和释放与套接口文件相关的i结点</li>
<li>通过<code>/proc/filesystem</code>文件查看操作系统支持的文件系统</li>
</ul>
<h5 id="2232">22.3.2、套接口文件系统超级块操作接口<a class="headerlink" href="#2232" title="Permanent link">&para;</a></h5>
<h5 id="2233inode">22.3.3、套接口文件的inode<a class="headerlink" href="#2233inode" title="Permanent link">&para;</a></h5>
<ul>
<li><code>struct socket_alloc{};</code>由socket结构和inode结构两部分组成</li>
</ul>
<h5 id="2234sock_alloc_inode">22.3.4、sock_alloc_inode()<a class="headerlink" href="#2234sock_alloc_inode" title="Permanent link">&para;</a></h5>
<h5 id="325sock_destroy_inode">3.2.5、sock_destroy_inode()<a class="headerlink" href="#325sock_destroy_inode" title="Permanent link">&para;</a></h5>
<h4 id="224">22.4、套接口文件<a class="headerlink" href="#224" title="Permanent link">&para;</a></h4>
<ul>
<li>创建套接口文件时，使file结构中的f_op指向了<code>socket_file_ops</code>，<strong>通过socket_file_ops可以看到套接口文件支持哪些系统调用</strong></li>
</ul>
<h5 id="2241">22.4.1、套接口文件与套接口的绑定<a class="headerlink" href="#2241" title="Permanent link">&para;</a></h5>
<ul>
<li>1、sock_map_fd()</li>
<li>2、sock_attach_fd()</li>
</ul>
<h5 id="2242">22.4.2、根据文件描述符获取套接口<a class="headerlink" href="#2242" title="Permanent link">&para;</a></h5>
<ul>
<li>1、sockfd_lookup_light()</li>
<li>2、sock_from_file()</li>
</ul>
<h4 id="225">22.5、进程、文件描述符和套接口<a class="headerlink" href="#225" title="Permanent link">&para;</a></h4>
<ul>
<li>在task_struct结构中，files指向file_struct结构，该结构的主要功能是管理fd_array指针数组指向的描述符，每个file结构描述一个打开的文件</li>
</ul>
<h4 id="226">22.6、套接口层的系统初始化<a class="headerlink" href="#226" title="Permanent link">&para;</a></h4>
<ul>
<li><code>sock_init()</code></li>
</ul>
<h4 id="227">22.7、套接口系统调用<a class="headerlink" href="#227" title="Permanent link">&para;</a></h4>
<ul>
<li>理解proto_ops结构和proto结构的差异和调用层次</li>
</ul>
<h5 id="2271">22.7.1、套接口系统调用入口<a class="headerlink" href="#2271" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>表22-5</strong>，套接口系统调用</li>
</ul>
<h5 id="2272socket">22.7.2、socket系统调用<a class="headerlink" href="#2272socket" title="Permanent link">&para;</a></h5>
<ul>
<li>1、sys_socket()</li>
<li>2、</li>
</ul>
<h5 id="2273bind">22.7.3、bind系统调用<a class="headerlink" href="#2273bind" title="Permanent link">&para;</a></h5>
<ul>
<li>1、sys_bind()</li>
</ul>
<h5 id="2274listen">22.7.4、listen系统调用<a class="headerlink" href="#2274listen" title="Permanent link">&para;</a></h5>
<h5 id="2275accept">22.7.5、accept系统调用<a class="headerlink" href="#2275accept" title="Permanent link">&para;</a></h5>
<h5 id="2276connect">22.7.6、connect系统调用<a class="headerlink" href="#2276connect" title="Permanent link">&para;</a></h5>
<h5 id="2277shutdown">22.7.7、shutdown系统调用<a class="headerlink" href="#2277shutdown" title="Permanent link">&para;</a></h5>
<ul>
<li>1、sys_shutdown</li>
<li>2、套接口层的实现</li>
</ul>
<h5 id="2278close">22.7.8、close系统调用<a class="headerlink" href="#2278close" title="Permanent link">&para;</a></h5>
<ul>
<li>1、关闭套接口</li>
<li>2、套接口层的实现</li>
</ul>
<h5 id="2279select">22.7.9、select系统调用的实现<a class="headerlink" href="#2279select" title="Permanent link">&para;</a></h5>
<h3 id="chap23io-91100529">chap23、套接口I/O  91（100/529）<a class="headerlink" href="#chap23io-91100529" title="Permanent link">&para;</a></h3>
<ul>
<li>套接口I/O涉及的文件<ul>
<li>include/linux/socket.h，定义套接口的结构、宏和函数原型</li>
<li>net/core/iovec.c，实现对I/O向量块的复制操作</li>
<li>net/socket.c，实现套接口层的调用</li>
</ul>
</li>
</ul>
<h4 id="231">23.1、输出/输入数据的组织<a class="headerlink" href="#231" title="Permanent link">&para;</a></h4>
<h5 id="2311msghdr">23.1.1、msghdr结构<a class="headerlink" href="#2311msghdr" title="Permanent link">&para;</a></h5>
<ul>
<li><code>struct msghdr{};</code></li>
</ul>
<h5 id="2312verify_iovec">23.1.2、verify_iovec()<a class="headerlink" href="#2312verify_iovec" title="Permanent link">&para;</a></h5>
<ul>
<li>发送和接收的数据的msghdr结构需要在用户态组织，<strong>而在内核中是不信任用户态的数据的</strong>，因此需要对用户态提供的msghdr结构进行校难。</li>
</ul>
<h5 id="2313">23.1.3、<a class="headerlink" href="#2313" title="Permanent link">&para;</a></h5>
<p>23.1.4、</p>
<p>23.1.5、</p>
<h5 id="2316csum_partial_copy_fromiovecend">23.1.6、csum_partial_copy_fromiovecend()<a class="headerlink" href="#2316csum_partial_copy_fromiovecend" title="Permanent link">&para;</a></h5>
<h4 id="232">23.2、输出系统调用<a class="headerlink" href="#232" title="Permanent link">&para;</a></h4>
<h5 id="2321sock_sendmsg">23.2.1、sock_sendmsg()<a class="headerlink" href="#2321sock_sendmsg" title="Permanent link">&para;</a></h5>
<h5 id="2322sendto">23.2.2、sendto系统调用<a class="headerlink" href="#2322sendto" title="Permanent link">&para;</a></h5>
<h5 id="2323send">23.2.3、send系统调用<a class="headerlink" href="#2323send" title="Permanent link">&para;</a></h5>
<h5 id="2324sendmsg">23.2.4、sendmsg系统调用<a class="headerlink" href="#2324sendmsg" title="Permanent link">&para;</a></h5>
<h4 id="233">23.3、输入系统调用<a class="headerlink" href="#233" title="Permanent link">&para;</a></h4>
<ul>
<li>图23-3，recvmsg系统调用过程</li>
</ul>
<h4 id="234">23.4、网络设备处理层初始化<a class="headerlink" href="#234" title="Permanent link">&para;</a></h4>
<h3 id="chap24-99108529">chap24、套接口选项  99（108/529）<a class="headerlink" href="#chap24-99108529" title="Permanent link">&para;</a></h3>
<ul>
<li>套接口选项的实现涉及的文件<ul>
<li>net/socket.c，实现套接口层的调用</li>
<li>net/ipv4/af_inet.c，网络层和传输层接口</li>
</ul>
</li>
</ul>
<h4 id="241setsockopt">24.1、setsockopt系统调用<a class="headerlink" href="#241setsockopt" title="Permanent link">&para;</a></h4>
<h4 id="242ioctl">24.2、ioctl系统调用<a class="headerlink" href="#242ioctl" title="Permanent link">&para;</a></h4>
<h5 id="2421ioctl">24.2.1、ioctl在文件系统内的调用过程<a class="headerlink" href="#2421ioctl" title="Permanent link">&para;</a></h5>
<h5 id="2422ioctl">24.2.2、套接口文件ioctl调用接口的实现<a class="headerlink" href="#2422ioctl" title="Permanent link">&para;</a></h5>
<h5 id="2423">24.2.3、套接口层的实现<a class="headerlink" href="#2423" title="Permanent link">&para;</a></h5>
<h4 id="243getsockname">24.3、getsockname系统调用<a class="headerlink" href="#243getsockname" title="Permanent link">&para;</a></h4>
<h4 id="244getpeername">24.4、getpeername系统调用<a class="headerlink" href="#244getpeername" title="Permanent link">&para;</a></h4>
<h3 id="chap25-111120529">chap25、传输控制块  111（120/529）<a class="headerlink" href="#chap25-111120529" title="Permanent link">&para;</a></h3>
<ul>
<li>根据协议族和传输层协议的特点，分层次地定义了多个结构用来组成传输控制块<ul>
<li>sock_common、<strong>传输控制块信息的最小集合</strong>，由sock和inet_timewait_sock结构前面相同部分单独构成</li>
<li>sock、比较通用的网络层描述块，构成传输控制块的基础，与具体的协议族无关</li>
<li>inet_sock、</li>
<li>inet_connection_sock、支持面向连接特性的描述块，</li>
<li>tcp_sock、request_sock、</li>
</ul>
</li>
</ul>
<ul>
<li>涉及的文件<ul>
<li>include/net/sock.h，定义基本的传输控制块结构、宏和函数原型</li>
<li>include/net/inet_sock.h，定义IPv4专用的传输控制块</li>
<li>net/core/sock.c，实现传输层通用的函数</li>
<li>net/socket.c，实现套接口层的调用</li>
</ul>
</li>
</ul>
<h4 id="251">25.1、系统参数<a class="headerlink" href="#251" title="Permanent link">&para;</a></h4>
<ul>
<li>optmem_max，每个传输控制块辅助缓冲区的上限，<code>sock_kmalloc()</code><ul>
<li><strong>辅助数据</strong>包括进行设置选项、设置过滤时分配的内存和组播设置</li>
</ul>
</li>
<li>rmem_default，传输控制块接收缓冲区大小的上限的默认值</li>
<li>rmem_max，传输控制块接收缓冲区大小的上限的最大值</li>
<li>vmem_default，传输控制块发送缓冲区大小的上限的默认值</li>
<li>vmem_max，传输控制块发送缓冲区大小的上限的最大值</li>
</ul>
<h4 id="252">25.2、传输描述块结构<a class="headerlink" href="#252" title="Permanent link">&para;</a></h4>
<h5 id="2521sock_common">25.2.1、sock_common结构<a class="headerlink" href="#2521sock_common" title="Permanent link">&para;</a></h5>
<h5 id="2522sock">25.2.2、sock结构<a class="headerlink" href="#2522sock" title="Permanent link">&para;</a></h5>
<h5 id="2523inet_sock">25.2.3、inet_sock结构<a class="headerlink" href="#2523inet_sock" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>是IPv4协议专用的传输控制块，是对sock结构的扩展</strong>，在传输控制块的基本属性已具备的基础上，进一步提供了IPv4协议专有的一些属性</li>
</ul>
<h4 id="253proto">25.3、proto结构<a class="headerlink" href="#253proto" title="Permanent link">&para;</a></h4>
<ul>
<li>proto结构为<strong>网络接口层</strong>，结构中的操作实现传输层的操作和从传输层到网络层调用的跳转，<strong>在proto结构中某些成员跟proto_ops结构中的成员对应</strong></li>
</ul>
<h5 id="2531ptoto">25.3.1、ptoto实例组织结构<a class="headerlink" href="#2531ptoto" title="Permanent link">&para;</a></h5>
<h5 id="2532proto_register">25.3.2、proto_register()<a class="headerlink" href="#2532proto_register" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>注册proto实例到proto_list链表中</strong></li>
</ul>
<h5 id="2533proto_unregister">25.3.3、proto_unregister()<a class="headerlink" href="#2533proto_unregister" title="Permanent link">&para;</a></h5>
<h4 id="254">25.4、传输控制块的内存管理<a class="headerlink" href="#254" title="Permanent link">&para;</a></h4>
<h5 id="2541">25.4.1、传输控制块的分配和释放<a class="headerlink" href="#2541" title="Permanent link">&para;</a></h5>
<ul>
<li>1、sk_alloc()<ul>
<li>在创建套接口时，TCP、UDP和原始IP会分配一个传输控制块</li>
</ul>
</li>
<li>2、sk_clone()</li>
<li>3、sk_free()</li>
<li>4、sock_put()</li>
</ul>
<h5 id="2542">25.4.2、普通的发送缓存区的分配<a class="headerlink" href="#2542" title="Permanent link">&para;</a></h5>
<ul>
<li>1、sock_alloc_send_skb()</li>
<li>2、sock_alloc_send_pskb()</li>
<li>3、sock_wait_for_wmem()</li>
</ul>
<h5 id="2543">25.4.3、发送缓存的分配与释放<a class="headerlink" href="#2543" title="Permanent link">&para;</a></h5>
<ul>
<li>1、sock_wmalloc()，<strong>分配发送缓存</strong></li>
<li>2、skb_set_owner_w()</li>
<li>3、sock_wfree()</li>
</ul>
<h5 id="2544">25.4.4、接收缓存的分配与释放<a class="headerlink" href="#2544" title="Permanent link">&para;</a></h5>
<ul>
<li>1、sk_stream_set_owner_r()和sk_stream_rfree()</li>
<li>2、</li>
</ul>
<h5 id="2545">25.4.5、辅助缓存的分配与释放<a class="headerlink" href="#2545" title="Permanent link">&para;</a></h5>
<ul>
<li>1、sock_kmalloc()，<strong>分配有关选项的缓存</strong></li>
<li>2、sock_kfree_s()，<strong>释放由sock_kmalloc()分配的缓存</strong></li>
</ul>
<h4 id="255io">25.5、异步IO机制<a class="headerlink" href="#255io" title="Permanent link">&para;</a></h4>
<h5 id="2551sk_wake_async">25.5.1、sk_wake_async()<a class="headerlink" href="#2551sk_wake_async" title="Permanent link">&para;</a></h5>
<h5 id="2558sock_fasync">25.5.8、sock_fasync()<a class="headerlink" href="#2558sock_fasync" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>实现了对套接口的异步通知队列增加和删除的更新操作</strong></li>
</ul>
<h4 id="256">25.6、网络设备的禁用<a class="headerlink" href="#256" title="Permanent link">&para;</a></h4>
<h5 id="2561socket_lock_t">25.6.1、socket_lock_t结构<a class="headerlink" href="#2561socket_lock_t" title="Permanent link">&para;</a></h5>
<ul>
<li>实现控制用户进程和下半部间同步锁和控制下半部间同步锁都是由<code>socket_lock_t</code>结构描述的。</li>
</ul>
<h5 id="2562">25.6.2、控制用户进程和下半部间同步锁<a class="headerlink" href="#2562" title="Permanent link">&para;</a></h5>
<ul>
<li>传输控制块通常在两种执行体中执行，<strong>进程上下文</strong>和<strong>软中断上下文</strong>，对传输控制块的访问完全是异步的，因此<strong>为了防止在访问传输控制块时产生冲突，加入了锁机制</strong>。</li>
<li>1、lock_sock()</li>
<li>2、release_sock()</li>
<li>3、sock_owned_by_user宏</li>
</ul>
<h5 id="2563">25.6.3、控制下半部间同步锁<a class="headerlink" href="#2563" title="Permanent link">&para;</a></h5>
<h3 id="chap26tcp-149158529">chap26、TCP：传输控制协议  149（158/529）<a class="headerlink" href="#chap26tcp-149158529" title="Permanent link">&para;</a></h3>
<ul>
<li>TCP的内容分为7章</li>
<li>图26-1，TCP函数调用关系</li>
<li>TCP传输控制块的管理、套接口选项、ioctl、差错处理以及缓存管理的文件<ul>
<li>include/linux/tcp.h</li>
<li>include/net/sock.h</li>
<li>include/net/inet_connection_sock.h</li>
<li>include/net/inet_hashtables.h，定义管理传输控制块的散列表</li>
<li>net/ipv4/af_inet.c，网络层和传输层接口</li>
<li>net/ipv4/tcp_ipv4.c，传输控制块与网络层之间的接口实现</li>
<li>net/ipv4/tcp.c，传输控制块与应用层之间的接口实现</li>
<li>net/core/strem.c，TCP中流内存管理的实现</li>
</ul>
</li>
</ul>
<h4 id="261">26.1、系统参数<a class="headerlink" href="#261" title="Permanent link">&para;</a></h4>
<ul>
<li>40、tcp_timestamps</li>
<li>46、tcp_workaround_signed_windows</li>
</ul>
<h4 id="262tcpinet_protosw">26.2、TCP的inet_protosw实例<a class="headerlink" href="#262tcpinet_protosw" title="Permanent link">&para;</a></h4>
<ul>
<li><code>struct inet_protosw inetsw_array[] ={.protocol = IPPROTO_TCP}</code></li>
</ul>
<h4 id="263tcpnet_protosw">26.3、TCP的net_protosw实例<a class="headerlink" href="#263tcpnet_protosw" title="Permanent link">&para;</a></h4>
<ul>
<li><code>struct net_protocol tcp_protocol ={.handler = tcp_v4_rcv,}</code></li>
</ul>
<h4 id="264tcp">26.4、TCP传输控制块<a class="headerlink" href="#264tcp" title="Permanent link">&para;</a></h4>
<ul>
<li>3种类型的TCP传输控制块<ul>
<li>tcp_request_sock</li>
<li>tcp_sock，<em>本章讲这个</em>，<strong>在连接建立之后终止之前使用，TCP状态为ESTABLISHED</strong></li>
<li>tcp_timewait_sock，<strong>在终止连接过程中使用</strong></li>
</ul>
</li>
</ul>
<h5 id="2641inet_connection_sock">26.4.1、inet_connection_sock结构<a class="headerlink" href="#2641inet_connection_sock" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>所有面向连接传输控制块</strong>，在<strong>inet_sock结构的基础上</strong>，增加了<strong>连接、确认和重传</strong></li>
</ul>
<h5 id="2642inet_connection_sock_af_ops">26.4.2、inet_connection_sock_af_ops结构<a class="headerlink" href="#2642inet_connection_sock_af_ops" title="Permanent link">&para;</a></h5>
<ul>
<li>封装了一组<strong>与传输层相关的操作集</strong>，TCP中的实例是<strong>ipv4_specific</strong></li>
</ul>
<h5 id="2643tcp_sock">26.4.3、tcp_sock结构<a class="headerlink" href="#2643tcp_sock" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>TCP协议的控制块</strong>，是在<strong>inet_connection_sock</strong>基础上，扩展了<strong>滑动窗口协议、拥塞控制算法</strong></li>
</ul>
<h5 id="2644tcp_options_received">26.4.4、tcp_options_received结构<a class="headerlink" href="#2644tcp_options_received" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>保存接收到的TCP选项信息</strong>，如时间戳、SACK等</li>
</ul>
<h5 id="2645tcp_skb_cb">26.4.5、tcp_skb_cb结构<a class="headerlink" href="#2645tcp_skb_cb" title="Permanent link">&para;</a></h5>
<ul>
<li>skb_buff结构的cb成员，<strong>TCP利用这个字段存储了一个tcp_skb_cb结构</strong></li>
</ul>
<h4 id="265tcpprotoproto_ops">26.5、TCP的proto结构和proto_ops结构的实例<a class="headerlink" href="#265tcpprotoproto_ops" title="Permanent link">&para;</a></h4>
<ul>
<li>TCP的传输层接口为tcp_prot，另一个是<code>inet_stream_ops</code>，<em>是不是作者字写错了</em></li>
</ul>
<h4 id="266tcp">26.6、TCP状态迁移图<a class="headerlink" href="#266tcp" title="Permanent link">&para;</a></h4>
<ul>
<li><em>跟用户态是一样的</em></li>
</ul>
<h4 id="267tcp">26.7、TCP首部<a class="headerlink" href="#267tcp" title="Permanent link">&para;</a></h4>
<h4 id="268tcp">26.8、TCP校验和<a class="headerlink" href="#268tcp" title="Permanent link">&para;</a></h4>
<ul>
<li>TCP的校验和<strong>覆盖TCP首部及TCP数据</strong>，IP首部中的校验和<strong>只覆盖IP的首部</strong>，不覆盖IP数据报中的任何数据</li>
<li>校验和规则，<strong>每16位字取反后相加</strong>，<strong>TCP段都包含一个12B的伪首部</strong></li>
</ul>
<h5 id="2681tcp">26.8.1、输入TCP段的校验和检测<a class="headerlink" href="#2681tcp" title="Permanent link">&para;</a></h5>
<h6 id="1tcp_v4_checksum_init">1、tcp_v4_checksum_init()<a class="headerlink" href="#1tcp_v4_checksum_init" title="Permanent link">&para;</a></h6>
<h6 id="2tcp_checksum_completetcp_checksum_complete_user">2、tcp_checksum_complete()和tcp_checksum_complete_user()<a class="headerlink" href="#2tcp_checksum_completetcp_checksum_complete_user" title="Permanent link">&para;</a></h6>
<h5 id="2682tcp">26.8.2、输出TCP段校验和的计算<a class="headerlink" href="#2682tcp" title="Permanent link">&para;</a></h5>
<ul>
<li>tcp_v4_send_check()</li>
</ul>
<h4 id="269tcp">26.9、TCP的初始化<a class="headerlink" href="#269tcp" title="Permanent link">&para;</a></h4>
<ul>
<li>tcp_init()由<strong>IPv4协议族的初始化函数inet_init()调用</strong></li>
</ul>
<h4 id="2610tcp">26.10、TCP传输控制块的管理<a class="headerlink" href="#2610tcp" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>TCP存在多个状态</strong></li>
</ul>
<h5 id="26101inet_hashinfo">26.10.1、inet_hashinfo结构<a class="headerlink" href="#26101inet_hashinfo" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>tcp_hashinfo对所有的散列表进行集中管理</strong></li>
</ul>
<h5 id="26102listentcp">26.10.2、管理除LISTEN状态之外的TCP传输控制块<a class="headerlink" href="#26102listentcp" title="Permanent link">&para;</a></h5>
<ul>
<li>tcp_v4_hash()</li>
</ul>
<h5 id="26103listentcp">26.10.3、管理LISTEN状态的TCP传输控制块<a class="headerlink" href="#26103listentcp" title="Permanent link">&para;</a></h5>
<h4 id="2611tcp">26.11、TCP层的套接口选项<a class="headerlink" href="#2611tcp" title="Permanent link">&para;</a></h4>
<ul>
<li>tcp_setsockopt()</li>
</ul>
<h4 id="2612tcpioctl">26.12、TCP的ioctl<a class="headerlink" href="#2612tcpioctl" title="Permanent link">&para;</a></h4>
<ul>
<li>TCP中的几个ioctl命令<ul>
<li>SIOCINQ</li>
<li>SIOCATMARK</li>
<li>SIOCOUTQ</li>
</ul>
</li>
</ul>
<h4 id="2613tcp">26.13、TCP传输控制块的初始化<a class="headerlink" href="#2613tcp" title="Permanent link">&para;</a></h4>
<ul>
<li>tcp_prot中，将<strong>init接口设置为tcp_v4_init_sock()</strong></li>
</ul>
<h4 id="2614tcp">26.14、TCP的差错处理<a class="headerlink" href="#2614tcp" title="Permanent link">&para;</a></h4>
<ul>
<li>tcp_v4_err()</li>
</ul>
<h4 id="2615tcp">26.15、TCP传输控制块层的缓存管理<a class="headerlink" href="#2615tcp" title="Permanent link">&para;</a></h4>
<h5 id="26151">26.15.1、缓存管理的算法<a class="headerlink" href="#26151" title="Permanent link">&para;</a></h5>
<h6 id="3">3、<a class="headerlink" href="#3" title="Permanent link">&para;</a></h6>
<h6 id="4">4、等待可用的缓存<a class="headerlink" href="#4" title="Permanent link">&para;</a></h6>
<h5 id="26152">26.15.2、发送缓存的管理<a class="headerlink" href="#26152" title="Permanent link">&para;</a></h5>
<h6 id="1skb">1、分配SKB<a class="headerlink" href="#1skb" title="Permanent link">&para;</a></h6>
<h6 id="2">2、确认发送缓存是否可用<a class="headerlink" href="#2" title="Permanent link">&para;</a></h6>
<h5 id="26153">26.15.3、接收缓存的管理<a class="headerlink" href="#26153" title="Permanent link">&para;</a></h5>
<h6 id="1">1、确认接收缓存是否可用<a class="headerlink" href="#1" title="Permanent link">&para;</a></h6>
<h6 id="2skb">2、释放SKB<a class="headerlink" href="#2skb" title="Permanent link">&para;</a></h6>
<h3 id="chap27tcp-196205529">chap27、TCP的定时器  196（205/529）<a class="headerlink" href="#chap27tcp-196205529" title="Permanent link">&para;</a></h3>
<ul>
<li><em>我的问题</em>，【还是需要理论基础】，<em>以下都是网上搜集，不代表真实性</em><ul>
<li><strong>TCP的控制，就靠TCP的定时器</strong></li>
</ul>
</li>
<li><em>我归纳的本章介绍</em><ul>
<li>7个定时器，<strong>每个里面，都分2个小节，一是相关的处理函数，二是激活</strong></li>
</ul>
</li>
<li>TCP为每条连接建立7个定时器，<strong>连接建立、重传、延时ACK、持续、保活、FIN_WAIT_2、TIME_WAIT</strong><ul>
<li><strong>一般内核只用4个就完成了7个功能</strong></li>
</ul>
</li>
<li>涉及的文件<ul>
<li>net/ipv4/tcp_time.c，TCP的定时器</li>
<li>net/ipv4/inet_connection_sock.c，基于连接的传输控制块实现</li>
<li>net/ipv4/tcp_output.c，TCP的输出</li>
<li>net/ipv4/tcp_input.c，TCP的输入</li>
</ul>
</li>
</ul>
<h4 id="271">27.1、初始化<a class="headerlink" href="#271" title="Permanent link">&para;</a></h4>
<ul>
<li>tcp_init_xmit_timers()</li>
</ul>
<h4 id="272">27.2、连接建立定时器<a class="headerlink" href="#272" title="Permanent link">&para;</a></h4>
<h5 id="2721">27.2.1、连接建立定时器处理函数<a class="headerlink" href="#2721" title="Permanent link">&para;</a></h5>
<h6 id="1_1">1、<a class="headerlink" href="#1_1" title="Permanent link">&para;</a></h6>
<h6 id="3inet_csk_reqsk_queue_prune">3、inet_csk_reqsk_queue_prune()<a class="headerlink" href="#3inet_csk_reqsk_queue_prune" title="Permanent link">&para;</a></h6>
<h5 id="2722">27.2.2、连接建立定时器的激活<a class="headerlink" href="#2722" title="Permanent link">&para;</a></h5>
<h4 id="273">27.3、重传定时器<a class="headerlink" href="#273" title="Permanent link">&para;</a></h4>
<h5 id="2731">27.3.1、重传定时器处理函数<a class="headerlink" href="#2731" title="Permanent link">&para;</a></h5>
<h6 id="1tcp_write_timer">1、tcp_write_timer()<a class="headerlink" href="#1tcp_write_timer" title="Permanent link">&para;</a></h6>
<h6 id="3tcp_write_timeout">3、tcp_write_timeout()<a class="headerlink" href="#3tcp_write_timeout" title="Permanent link">&para;</a></h6>
<h5 id="2732">27.3.2、重传定时器的激活<a class="headerlink" href="#2732" title="Permanent link">&para;</a></h5>
<h4 id="274ack">27.4、延时ACK定时器<a class="headerlink" href="#274ack" title="Permanent link">&para;</a></h4>
<h5 id="2741ack">27.4.1、延时ACK定时器处理函数<a class="headerlink" href="#2741ack" title="Permanent link">&para;</a></h5>
<h5 id="2742ack">27.4.2、延时ACK定时器的激活<a class="headerlink" href="#2742ack" title="Permanent link">&para;</a></h5>
<h4 id="275">27.5、持续定时器<a class="headerlink" href="#275" title="Permanent link">&para;</a></h4>
<h5 id="2751">27.5.1、持续定时器处理函数<a class="headerlink" href="#2751" title="Permanent link">&para;</a></h5>
<h5 id="2752">27.5.2、持续定时器的激活<a class="headerlink" href="#2752" title="Permanent link">&para;</a></h5>
<h4 id="276">27.6、保活定时器<a class="headerlink" href="#276" title="Permanent link">&para;</a></h4>
<h5 id="2761">27.6.1、保活定时器处理函数<a class="headerlink" href="#2761" title="Permanent link">&para;</a></h5>
<h5 id="2762">27.6.2、保活定时器的激活<a class="headerlink" href="#2762" title="Permanent link">&para;</a></h5>
<h4 id="277fin_wait_2">27.7、FIN_WAIT_2定时器<a class="headerlink" href="#277fin_wait_2" title="Permanent link">&para;</a></h4>
<h5 id="2771fin_wait_2">27.7.1、FIN_WAIT_2定时器处理函数<a class="headerlink" href="#2771fin_wait_2" title="Permanent link">&para;</a></h5>
<h5 id="2772fin_wait_2">27.7.2、FIN_WAIT_2定时器的激活<a class="headerlink" href="#2772fin_wait_2" title="Permanent link">&para;</a></h5>
<h4 id="278time_wait">27.8、TIME_WAIT定时器<a class="headerlink" href="#278time_wait" title="Permanent link">&para;</a></h4>
<h3 id="chap28tcp-217226529">chap28、TCP连接的建立   217（226/529）<a class="headerlink" href="#chap28tcp-217226529" title="Permanent link">&para;</a></h3>
<ul>
<li>自己搜的<ul>
<li>主动，被动、同时<ul>
<li><strong>主动</strong>打开，client向server发送SYN</li>
<li>被动打开，server等待client的答复</li>
<li>同时打开，client和server同时发送SYN</li>
</ul>
</li>
<li>TCP连接建立过程中有哪些系统调用<ul>
<li>socket</li>
<li>bind</li>
<li>listen</li>
<li>accept</li>
<li>connect</li>
</ul>
</li>
<li><strong>不管主动，被动，三次握手，都是client发SYN，server回SYN+ACK</strong></li>
<li>TCP接收队列、全连接、半连接<ul>
<li>接收队列，kernel中接收到但未被应用程序处理的TCP数据包的缓存区</li>
<li><strong>全连接</strong>，已3次握手，双向传输</li>
<li><strong>半连接</strong>，一方只完成了三次握手的前2步，<strong>单向传输</strong>，或者是网络中断，或者是对方拒绝连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>TCP连接建立的过程（侦听套接口的IP地址和端口的绑定，套接口的侦听和accept，客户端接口的IP地址和端口的绑定，以及被动打开、主动打开和同时打开的实现过程）</li>
<li>涉及的文件<ul>
<li>include/linux/tcp.h</li>
<li>include/net/request_sock.h</li>
<li>include/net/inet_sock.h</li>
<li>include/net/inet_connection_sock.h</li>
<li>net/ipv4/inet_connection_sock.c，基于连接的传输控制块实现</li>
<li>net/ipv4/af_inet.c，网络层和传输层接口</li>
</ul>
</li>
</ul>
<h4 id="281">28.1、服务端建立连接过程<a class="headerlink" href="#281" title="Permanent link">&para;</a></h4>
<ul>
<li>TCP连接的过程<ul>
<li>client发送一个SYN段，标识希望连接的服务器端口以及初始序号</li>
<li>server回复一个包含服务器初始序号以及对clientSYN段确认的SYN+ACK段作为应答</li>
<li>client发送确认序号为服务器初始序号加1的ACK段，对服务器SYN段进行确认</li>
</ul>
</li>
</ul>
<h4 id="282">28.2、网络输出软中断<a class="headerlink" href="#282" title="Permanent link">&para;</a></h4>
<h5 id="2821request_sock_queue">28.2.1、request_sock_queue结构<a class="headerlink" href="#2821request_sock_queue" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>存放三次握手的信息</strong></li>
</ul>
<h5 id="2822listen_sock">28.2.2、listen_sock结构<a class="headerlink" href="#2822listen_sock" title="Permanent link">&para;</a></h5>
<ul>
<li>存储<strong>连接请求块</strong>，在<strong>listen调用之后才会创建</strong>，request_sock_queue结构中<code>listen_opt</code>成员</li>
</ul>
<h5 id="2823tcp_request_sock">28.2.3、tcp_request_sock结构<a class="headerlink" href="#2823tcp_request_sock" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>保存双方的初始序号、双方的端口及IP地址、TCP选项，如是否支持窗口扩大因子、是否支持SACK等，并控制连接的建立</strong></li>
</ul>
<h6 id="1inet_request_sock">1、inet_request_sock结构<a class="headerlink" href="#1inet_request_sock" title="Permanent link">&para;</a></h6>
<h6 id="2request_sock">2、request_sock结构<a class="headerlink" href="#2request_sock" title="Permanent link">&para;</a></h6>
<h5 id="2824request_sock_ops">28.2.4、request_sock_ops结构<a class="headerlink" href="#2824request_sock_ops" title="Permanent link">&para;</a></h5>
<ul>
<li>TCP中指向的实例是<code>tcp_request_sock_ops</code></li>
</ul>
<h4 id="283bind">28.3、bind系统调用的实现<a class="headerlink" href="#283bind" title="Permanent link">&para;</a></h4>
<h5 id="2831bind">28.3.1、bind端口散列表<a class="headerlink" href="#2831bind" title="Permanent link">&para;</a></h5>
<h5 id="2832">28.3.2、传输接口层的实现<a class="headerlink" href="#2832" title="Permanent link">&para;</a></h5>
<ul>
<li><code>inet_csk_get_port()</code></li>
</ul>
<h4 id="284listen">28.4、listen系统调用的实现<a class="headerlink" href="#284listen" title="Permanent link">&para;</a></h4>
<h5 id="2841inet_listen">28.4.1、inet_listen()<a class="headerlink" href="#2841inet_listen" title="Permanent link">&para;</a></h5>
<h5 id="2842inet_csk_listen_start">28.4.2、实现侦听：inet_csk_listen_start()<a class="headerlink" href="#2842inet_csk_listen_start" title="Permanent link">&para;</a></h5>
<h4 id="285accept">28.5、accept系统调用的实现<a class="headerlink" href="#285accept" title="Permanent link">&para;</a></h4>
<h5 id="2851inet_accept">28.5.1、套接口层的实现：inet_accept()<a class="headerlink" href="#2851inet_accept" title="Permanent link">&para;</a></h5>
<h5 id="2852inet_csk_accept">28.5.2、传输接口层的实现：inet_csk_accept()<a class="headerlink" href="#2852inet_csk_accept" title="Permanent link">&para;</a></h5>
<h4 id="286">28.6、被动打开<a class="headerlink" href="#286" title="Permanent link">&para;</a></h4>
<h5 id="2861syn">28.6.1、第一次握手：发送SYN段<a class="headerlink" href="#2861syn" title="Permanent link">&para;</a></h5>
<h5 id="2862synack">28.6.2、第二次握手：接收SYN+ACK段<a class="headerlink" href="#2862synack" title="Permanent link">&para;</a></h5>
<h5 id="2863ack">28.6.3、第三次握手：发送ACK段<a class="headerlink" href="#2863ack" title="Permanent link">&para;</a></h5>
<h4 id="287connect">28.7、connect系统调用的实现<a class="headerlink" href="#287connect" title="Permanent link">&para;</a></h4>
<h5 id="2871inet_stream_connect">28.7.1、套接口层的实现：inet_stream_connect<a class="headerlink" href="#2871inet_stream_connect" title="Permanent link">&para;</a></h5>
<h5 id="2872">28.7.2、传输套接口层的实现<a class="headerlink" href="#2872" title="Permanent link">&para;</a></h5>
<h4 id="288">28.8、主动打开<a class="headerlink" href="#288" title="Permanent link">&para;</a></h4>
<h5 id="2881syn">28.8.1、第一次握手：发送SYN段<a class="headerlink" href="#2881syn" title="Permanent link">&para;</a></h5>
<h5 id="2882synack">28.8.2、第二次握手：接收SYN+ACK段<a class="headerlink" href="#2882synack" title="Permanent link">&para;</a></h5>
<h5 id="2883ack">28.8.3、第三次握手：发送ACK段<a class="headerlink" href="#2883ack" title="Permanent link">&para;</a></h5>
<h4 id="289">28.9、同时打开<a class="headerlink" href="#289" title="Permanent link">&para;</a></h4>
<h5 id="2891syn_sentsyn">28.9.1、SYN_SENT状态接收SYN段<a class="headerlink" href="#2891syn_sentsyn" title="Permanent link">&para;</a></h5>
<h5 id="2892syn_recvsynack">28.9.2、SYN_RECV状态接受SYN+ACK段<a class="headerlink" href="#2892syn_recvsynack" title="Permanent link">&para;</a></h5>
<h3 id="chap29tcp-281290529">chap29、TCP拥塞控制的实现  281（290/529）<a class="headerlink" href="#chap29tcp-281290529" title="Permanent link">&para;</a></h3>
<h4 id="291">29.1、拥塞控制引擎<a class="headerlink" href="#291" title="Permanent link">&para;</a></h4>
<ul>
<li>Linux通过比较拥塞窗口和<strong>SND.NXT和SND.UNA的差值</strong>来确定当前有多少仍在网络传输中并且未得到确认的段</li>
<li>Linux的TCP发送方支持以<strong>NewReno恢复和SACK恢复</strong>这两种算法来确定正在传递段的数目时，使用同一组概念和函数<ul>
<li>SACK选项</li>
</ul>
</li>
<li>涉及的文件<ul>
<li>include/linux/tcp.h，定义TCP段的格式、TCP传输控制块等结构、宏和函数原型</li>
<li>net/ipv4/tcp_input.c，TCP的输入</li>
<li>net/ipv4/tcp_output.c，TCP的输出</li>
<li>net/ipv4/tcp_timer.c，TCP定时器的实现</li>
<li>net/ipv4/tcp_cong.c，支持TCP多拥塞算法以及NewReno算法</li>
</ul>
</li>
</ul>
<h4 id="292">29.2、拥塞控制状态机<a class="headerlink" href="#292" title="Permanent link">&para;</a></h4>
<h5 id="2921open">29.2.1、Open状态<a class="headerlink" href="#2921open" title="Permanent link">&para;</a></h5>
<h5 id="2922disorder">29.2.2、Disorder状态<a class="headerlink" href="#2922disorder" title="Permanent link">&para;</a></h5>
<h5 id="2923cwr">29.2.3、CWR状态<a class="headerlink" href="#2923cwr" title="Permanent link">&para;</a></h5>
<h5 id="2924recovery">29.2.4、Recovery状态<a class="headerlink" href="#2924recovery" title="Permanent link">&para;</a></h5>
<h5 id="2925loss">29.2.5、Loss状态<a class="headerlink" href="#2925loss" title="Permanent link">&para;</a></h5>
<h4 id="293">29.3、拥塞窗口调整撤销<a class="headerlink" href="#293" title="Permanent link">&para;</a></h4>
<h5 id="2931">29.3.1、撤销拥塞窗口的检测<a class="headerlink" href="#2931" title="Permanent link">&para;</a></h5>
<h5 id="2932tcp_undo_cwr">29.3.2、tcp_undo_cwr()<a class="headerlink" href="#2932tcp_undo_cwr" title="Permanent link">&para;</a></h5>
<h5 id="2933disorder">29.3.3、从Disorder拥塞状态撤销<a class="headerlink" href="#2933disorder" title="Permanent link">&para;</a></h5>
<h5 id="2934recovery">29.3.4、从Recovery拥塞状态撤销<a class="headerlink" href="#2934recovery" title="Permanent link">&para;</a></h5>
<h5 id="2935loss">29.3.5、从Loss拥塞状态撤销<a class="headerlink" href="#2935loss" title="Permanent link">&para;</a></h5>
<h5 id="2936loss">29.3.6、从Loss拥塞状态撤销<a class="headerlink" href="#2936loss" title="Permanent link">&para;</a></h5>
<h4 id="294">29.4、显式拥塞通知<a class="headerlink" href="#294" title="Permanent link">&para;</a></h4>
<h5 id="2941ipecn">29.4.1、IP对ECN的支持<a class="headerlink" href="#2941ipecn" title="Permanent link">&para;</a></h5>
<h5 id="2942tcpecn">29.4.2、TCP对ECN的支持<a class="headerlink" href="#2942tcpecn" title="Permanent link">&para;</a></h5>
<h4 id="295">29.5、拥塞控制状态的处理与转换<a class="headerlink" href="#295" title="Permanent link">&para;</a></h4>
<h5 id="2951tcp_fastretrans_ale">29.5.1、拥塞控制状态的处理：tcp_fastretrans_ale<a class="headerlink" href="#2951tcp_fastretrans_ale" title="Permanent link">&para;</a></h5>
<h5 id="2952">29.5.2、拥塞避免<a class="headerlink" href="#2952" title="Permanent link">&para;</a></h5>
<h4 id="296tcp_cwnd_test">29.6、拥塞窗口的检测：tcp_cwnd_test()<a class="headerlink" href="#296tcp_cwnd_test" title="Permanent link">&para;</a></h4>
<h4 id="297f-rto">29.7、F-RTO算法<a class="headerlink" href="#297f-rto" title="Permanent link">&para;</a></h4>
<h5 id="2971f-rto">29.7.1、进入F-RTO算法处理阶段<a class="headerlink" href="#2971f-rto" title="Permanent link">&para;</a></h5>
<h5 id="2972f-rto">29.7.2、进行F-RTO算法处理<a class="headerlink" href="#2972f-rto" title="Permanent link">&para;</a></h5>
<h4 id="298">29.8、拥塞窗口的检验<a class="headerlink" href="#298" title="Permanent link">&para;</a></h4>
<h5 id="2981tcp_event_data_sent">29.8.1、tcp_event_data_sent()<a class="headerlink" href="#2981tcp_event_data_sent" title="Permanent link">&para;</a></h5>
<h5 id="2982tcp_cwnd_validate">29.8.2、tcp_cwnd_validate()<a class="headerlink" href="#2982tcp_cwnd_validate" title="Permanent link">&para;</a></h5>
<h4 id="299">29.9、支持多拥塞控制算法的机制<a class="headerlink" href="#299" title="Permanent link">&para;</a></h4>
<h5 id="2991">29.9.1、接口<a class="headerlink" href="#2991" title="Permanent link">&para;</a></h5>
<h5 id="2992tcp_register_congestion_">29.9.2、注册拥塞控制算法：tcp_register_congestion_<a class="headerlink" href="#2992tcp_register_congestion_" title="Permanent link">&para;</a></h5>
<h5 id="2993tcp_unregister_congestion_">29.9.3、注销拥塞控制算法：tcp_unregister_congestion_<a class="headerlink" href="#2993tcp_unregister_congestion_" title="Permanent link">&para;</a></h5>
<h5 id="2994tcp_set_congestion_">29.9.4、选取某种拥塞控制算法：tcp_set_congestion_<a class="headerlink" href="#2994tcp_set_congestion_" title="Permanent link">&para;</a></h5>
<h5 id="2995linux">29.9.5、Linux支持的拥塞控制算法<a class="headerlink" href="#2995linux" title="Permanent link">&para;</a></h5>
<h3 id="chap30tcp-314323529">chap30、TCP的输出  314（323/529）<a class="headerlink" href="#chap30tcp-314323529" title="Permanent link">&para;</a></h3>
<h4 id="301">30.1、引言<a class="headerlink" href="#301" title="Permanent link">&para;</a></h4>
<ul>
<li>TCP段是<strong>封装在IP数据报中传输的</strong>，而IP数据报的传输是不可靠的，必须跟踪他们，直到出现3种情况<ul>
<li>一是在规定时间内接收方确认已收到该段</li>
<li>二是发生超时，即规定时间内未接收到接收方的确定</li>
<li>三是确定数据包已丢失，在后两种情况下需从未接收到位置开始重新发送该数据报</li>
</ul>
</li>
<li>sock结构中的<strong>sk_write_queue和sk_send_head两字段之间的关系</strong></li>
<li>TCP输出引擎中，<strong>无论是首次发送TCP段、还是重传、或者建立TCP连接的SYN段</strong>，都会调用<code>tcp_transmit_skb()</code><ul>
<li>tcp_sendmsg()、<strong>将套接口缓存加入到传输控制块的发送队列sk_write_queue中</strong></li>
</ul>
</li>
<li><strong>发送前的克隆</strong></li>
<li>涉及的文件<ul>
<li>net/ipv4/tcp.c，传输控制块与应用层之间的接口实现</li>
<li>net/ipv4/tcp_ipv4.c，传输控制块与网络层之间的接口实现</li>
<li>net/ipv4/tcp_input.c</li>
<li>net/ipv4/tcp_output.c</li>
</ul>
</li>
</ul>
<h4 id="302mss">30.2、最大段长度（MSS）<a class="headerlink" href="#302mss" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>只在套接口层起作用</strong></li>
<li>inetsw_array数组包含了三个inet_protosw结构的实例：<strong>TCP，UDP和原始套接口</strong></li>
</ul>
<h4 id="303sendmsgtcp">30.3、sendmsg系统调用在TCP中的实现<a class="headerlink" href="#303sendmsgtcp" title="Permanent link">&para;</a></h4>
<h5 id="3031tcp">30.3.1、分割TCP段<a class="headerlink" href="#3031tcp" title="Permanent link">&para;</a></h5>
<h5 id="3032">30.3.2、套接口层的实现<a class="headerlink" href="#3032" title="Permanent link">&para;</a></h5>
<h5 id="3033">30.3.3、传输接口层的实现<a class="headerlink" href="#3033" title="Permanent link">&para;</a></h5>
<h4 id="304tcp">30.4、对TCP选项的处理<a class="headerlink" href="#304tcp" title="Permanent link">&para;</a></h4>
<h5 id="3041syn">30.4.1、构建SYN段的选项<a class="headerlink" href="#3041syn" title="Permanent link">&para;</a></h5>
<h5 id="3042syn">30.4.2、构建非SYN段的选项<a class="headerlink" href="#3042syn" title="Permanent link">&para;</a></h5>
<h4 id="305nagle">30.5、Nagle算法<a class="headerlink" href="#305nagle" title="Permanent link">&para;</a></h4>
<h4 id="306ack">30.6、ACK的接收<a class="headerlink" href="#306ack" title="Permanent link">&para;</a></h4>
<h5 id="3061tcp_ack">30.6.1、tcp_ack()<a class="headerlink" href="#3061tcp_ack" title="Permanent link">&para;</a></h5>
<h5 id="3062">30.6.2、发送窗口的更新<a class="headerlink" href="#3062" title="Permanent link">&para;</a></h5>
<h5 id="3063sack">30.6.3、根据SACK选项标记重传队列中段的记分牌<a class="headerlink" href="#3063sack" title="Permanent link">&para;</a></h5>
<h5 id="3064">30.6.4、重传队列中已经确认段的删除<a class="headerlink" href="#3064" title="Permanent link">&para;</a></h5>
<h4 id="307rto">30.7、往返时间测量和RTO的计算<a class="headerlink" href="#307rto" title="Permanent link">&para;</a></h4>
<h4 id="308mtu">30.8、路径MTU发现<a class="headerlink" href="#308mtu" title="Permanent link">&para;</a></h4>
<h5 id="3081mtu">30.8.1、路径MTU发现原理<a class="headerlink" href="#3081mtu" title="Permanent link">&para;</a></h5>
<h5 id="3082mtu">30.8.2、路径MTU发现时的黑洞<a class="headerlink" href="#3082mtu" title="Permanent link">&para;</a></h5>
<h5 id="3083">30.8.3、有关数据结构的初始化<a class="headerlink" href="#3083" title="Permanent link">&para;</a></h5>
<h5 id="3084mtutcp">30.8.4、创建路径MTU发现TCP段并发送<a class="headerlink" href="#3084mtutcp" title="Permanent link">&para;</a></h5>
<h5 id="3085mtu">30.8.5、路径MTU发现失败后处理<a class="headerlink" href="#3085mtu" title="Permanent link">&para;</a></h5>
<h5 id="3086icmp">30.8.6、处理需要分片ICMP目的不可达报文<a class="headerlink" href="#3086icmp" title="Permanent link">&para;</a></h5>
<h5 id="3087mss">30.8.7、更新当前有效的MSS<a class="headerlink" href="#3087mss" title="Permanent link">&para;</a></h5>
<h5 id="3088mtu">30.8.8、路径MTU发现成功后处理<a class="headerlink" href="#3088mtu" title="Permanent link">&para;</a></h5>
<h4 id="309tcp">30.9、TCP重传接口<a class="headerlink" href="#309tcp" title="Permanent link">&para;</a></h4>
<h3 id="chap31tcp-376385529">chap31、TCP的输入  376（385/529）<a class="headerlink" href="#chap31tcp-376385529" title="Permanent link">&para;</a></h3>
<h4 id="311">31.1、引言<a class="headerlink" href="#311" title="Permanent link">&para;</a></h4>
<ul>
<li>TCP传输控制块有3个有关接收的队列<ul>
<li>接收队列</li>
<li>prequeue队列</li>
<li>后备队列</li>
</ul>
</li>
<li>涉及到的文件<ul>
<li>include/linux/filter.h，定义套接口过滤的相关结构和宏</li>
<li>include/linux/tcp.h，</li>
<li>include/net/sock.h，定义基本的传输控制块结构、宏和函数原型</li>
<li>net/ipv4/tcp_input.c，TCP的输入</li>
<li>net/ipv4/tcp.c，传输控制块与应用层之间的接口实现</li>
<li>net/core/sock.c，实现传输层通用的函数</li>
<li>net/core/filter.c，套接口过滤的实现</li>
</ul>
</li>
</ul>
<h4 id="312tcp">31.2、TCP接收的总入口<a class="headerlink" href="#312tcp" title="Permanent link">&para;</a></h4>
<ul>
<li>从IP层到传输层，<code>tcp_v4_rcv()</code>是TCP的总入口<ul>
<li>1、对TCP段进行简单的校验</li>
<li>2、根据源地址、源端口、目的地址和目的端口查找到所属的传输控制块</li>
<li>3、调用<code>tcp_v4_do_rcv()</code><strong>将该TCP段接收到所属传输控制块的接收队列中</strong>，参数skb从IP层传递过来的数据报</li>
</ul>
</li>
</ul>
<h5 id="3121prequeue">31.2.1、接收到prequeue队列<a class="headerlink" href="#3121prequeue" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>未启用tcp_low_latency的情况下</strong></li>
</ul>
<h5 id="3222tcp">32.2.2、有效TCP段的处理<a class="headerlink" href="#3222tcp" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>除非处于FIN_WAIT_2或TIME_WAIT状态</strong>，否则都会调用<code>tcp_v4_do_rcv()</code></li>
</ul>
<h4 id="313">31.3、报文的过滤<a class="headerlink" href="#313" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>内核过滤</strong>，内核允许把过滤器直接挂接到<strong>PF_PACKET或P_INET类型套接口</strong>的处理例程中</li>
<li>TCP和UDP中过滤函数是<code>sk_filter()</code></li>
</ul>
<h5 id="3131">31.3.1、过滤器的数据结构<a class="headerlink" href="#3131" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>设置BPF过滤器是通过setsockopt调用来完成的</strong></li>
</ul>
<h6 id="1sock_fprog">1、sock_fprog结构<a class="headerlink" href="#1sock_fprog" title="Permanent link">&para;</a></h6>
<h6 id="2sock_filter">2、sock_filter结构<a class="headerlink" href="#2sock_filter" title="Permanent link">&para;</a></h6>
<h6 id="3sk_filter">3、sk_filter结构<a class="headerlink" href="#3sk_filter" title="Permanent link">&para;</a></h6>
<h5 id="3132">31.3.2、安装过滤器<a class="headerlink" href="#3132" title="Permanent link">&para;</a></h5>
<h5 id="3133">31.3.3、卸载过滤器<a class="headerlink" href="#3133" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>卸载过滤器，也是通过setsockopt系统调用进行的</strong></li>
</ul>
<h5 id="3134">31.3.4、过滤执行<a class="headerlink" href="#3134" title="Permanent link">&para;</a></h5>
<ul>
<li><code>sk_filter()</code>封装了套接口层的过滤器<code>sk_run_filter()</code></li>
</ul>
<h4 id="314established">31.4、ESTABLISHED状态的接收<a class="headerlink" href="#314established" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>tcp_rcv_established()是ESTABLISHED状态（已经建立连接）下的输入处理函数</strong>，为了高效处理接收到的段，对TCP段处理提供了两种路径：<ul>
<li>快速路径，处于预期、理想情形下的输入段</li>
<li>慢速路径，所有和预期、理想不对应的且需要进行进一步处理的段</li>
</ul>
</li>
</ul>
<h5 id="3141">31.4.1、首部预测<a class="headerlink" href="#3141" title="Permanent link">&para;</a></h5>
<h6 id="1_2">1、设置预测标志<a class="headerlink" href="#1_2" title="Permanent link">&para;</a></h6>
<p>11.5、IP层套接口选项</p>
<p>11.6、ipv4_devconf结构</p>
<p>11.7、套接口的错误队列</p>
<p>11.8、报文控制信息</p>
<p>11.9、对端信息块</p>
<h4 id="3110recvmsgtcp">31.10、recvmsg系统调用在TCP中的实现<a class="headerlink" href="#3110recvmsgtcp" title="Permanent link">&para;</a></h4>
<h5 id="31101">31.10.1、套接口层的实现<a class="headerlink" href="#31101" title="Permanent link">&para;</a></h5>
<h5 id="31102">31.10.2、传输接口层的实现<a class="headerlink" href="#31102" title="Permanent link">&para;</a></h5>
<h4 id="3111sk_backlog_rcv">31.11、sk_backlog_rcv接口<a class="headerlink" href="#3111sk_backlog_rcv" title="Permanent link">&para;</a></h4>
<h3 id="chap32tcp-442451529">chap32、TCP连接的终止 442（451/529）<a class="headerlink" href="#chap32tcp-442451529" title="Permanent link">&para;</a></h3>
<h4 id="321">32.1、连接终止过程<a class="headerlink" href="#321" title="Permanent link">&para;</a></h4>
<h5 id="3211">32.1.1、正常关闭<a class="headerlink" href="#3211" title="Permanent link">&para;</a></h5>
<h5 id="3212">32.1.2、同时关闭<a class="headerlink" href="#3212" title="Permanent link">&para;</a></h5>
<h4 id="332shutdown">33.2、shutdown传输接口层的实现<a class="headerlink" href="#332shutdown" title="Permanent link">&para;</a></h4>
<h5 id="3321tcp_shutdown">33.2.1、tcp_shutdown()<a class="headerlink" href="#3321tcp_shutdown" title="Permanent link">&para;</a></h5>
<ul>
<li>是TCP的shutdown系统调用的传输接口层实现，由套接口层的实现<code>inet_shutdown()</code>调用</li>
</ul>
<h5 id="3322tcp_send_fin">33.2.2、tcp_send_fin()<a class="headerlink" href="#3322tcp_send_fin" title="Permanent link">&para;</a></h5>
<ul>
<li>过程：<ul>
<li>由于发送FIN无需占用额外的负载</li>
</ul>
</li>
</ul>
<h4 id="323closetcp_close">32.3、close传输接口层的实现：tcp_close()<a class="headerlink" href="#323closetcp_close" title="Permanent link">&para;</a></h4>
<h4 id="324fin">32.4、被动关闭：FIN段的接收处理<a class="headerlink" href="#324fin" title="Permanent link">&para;</a></h4>
<h4 id="325">32.5、主动关闭<a class="headerlink" href="#325" title="Permanent link">&para;</a></h4>
<h5 id="3251timewait">32.5.1、timewait控制块的数据结构<a class="headerlink" href="#3251timewait" title="Permanent link">&para;</a></h5>
<ul>
<li>1、inet_timewait_death_row结构</li>
<li>2、inet_timewait_sock结构</li>
<li>3、tcp_timewait_sock结构</li>
</ul>
<h5 id="3252timewaittcp">32.5.2、timewait控制块取代TCP传输控制块<a class="headerlink" href="#3252timewaittcp" title="Permanent link">&para;</a></h5>
<h5 id="3253">32.5.3、<a class="headerlink" href="#3253" title="Permanent link">&para;</a></h5>
<h5 id="3254">32.5.4、<a class="headerlink" href="#3254" title="Permanent link">&para;</a></h5>
<h5 id="3255fin_wait2time_wait">32.5.5、FIN_WAIT2和TIME_WAIT状态处理<a class="headerlink" href="#3255fin_wait2time_wait" title="Permanent link">&para;</a></h5>
<ul>
<li>1、TCP输入入口</li>
<li>2、FIN_WAIT2和TIME_WAIT状态的输入处理</li>
</ul>
<h5 id="3256timewait2msl">32.5.6、timewait控制块的2MSL超时处理<a class="headerlink" href="#3256timewait2msl" title="Permanent link">&para;</a></h5>
<ul>
<li>1、2MSL等待超时时间较短的超时处理</li>
<li>2、2MSL等待超时时间较长的超时处理<ul>
<li>(1)、tw_timer定时器的例程</li>
<li>(2)、twkill_work工作队列例程</li>
</ul>
</li>
</ul>
<h3 id="chap33udp-473482529">chap33、UDP：用户数据报  473（482/529）<a class="headerlink" href="#chap33udp-473482529" title="Permanent link">&para;</a></h3>
<h4 id="331">33.1、引言<a class="headerlink" href="#331" title="Permanent link">&para;</a></h4>
<ul>
<li>UDP不提供可靠性</li>
<li>涉及的文件<ul>
<li>include/net/udplite.h，定义轻量级UDP专用的函数</li>
<li>include/linux/udp.h，定义UDP传输控制块</li>
<li>net/ipv4/udp.c</li>
<li>net/ipv4/udplite.c</li>
<li>net/core/sock.c，实现传输层通用的函数</li>
<li>net/ipv4/datagram.c，实现UDP的connect调用</li>
<li>net/ipv4/af_inet.c，网络层和传输层接口</li>
</ul>
</li>
</ul>
<h5 id="3311udp">33.1.1、UDP首部<a class="headerlink" href="#3311udp" title="Permanent link">&para;</a></h5>
<ul>
<li>端口号用来标识发送和接收进程</li>
</ul>
<h5 id="3312udp">33.1.2、UDP的输入与输出<a class="headerlink" href="#3312udp" title="Permanent link">&para;</a></h5>
<ul>
<li>发送，UDP层  udp_sendmsg-&gt;udp_push_pending_frame()<ul>
<li>另一个调用是 IP层的 <code>ip_append_data()</code></li>
</ul>
</li>
<li>接收，IP层是，<code>ip_local_deliver()</code><ul>
<li>UDP层，udp_rcv()-&gt;<code>_udp4_lib_rcv()</code>-&gt;udp_queue_rcv_skb()-&gt;sock_queue_rcv_skb()-&gt;skb_queue_tail()-&gt;<code>sk-&gt;sk_data_ready()</code></li>
</ul>
</li>
<li><code>struct sock</code>中的<strong>sk_receive_queue</strong>是接收队列</li>
</ul>
<h4 id="332udpinet_protosw">33.2、UDP的inet_protosw结构<a class="headerlink" href="#332udpinet_protosw" title="Permanent link">&para;</a></h4>
<ul>
<li><code>struct inet_protosw inetsw_array[] =</code><ul>
<li>传输层操作接口为<code>udp_prot</code></li>
<li>套接口层操作接口为<code>inet_dgram_ops</code></li>
</ul>
</li>
</ul>
<h4 id="333udp">33.3、UDP的传输控制块<a class="headerlink" href="#333udp" title="Permanent link">&para;</a></h4>
<ul>
<li><code>struct udp_sock{}</code>是对<code>inet_sock</code>结构的扩展</li>
</ul>
<h4 id="334udpprotoproto_ops">33.4、UDP的proto结构和proto_ops结构的实例<a class="headerlink" href="#334udpprotoproto_ops" title="Permanent link">&para;</a></h4>
<ul>
<li>传输层操作接口为<code>udp_prot</code></li>
<li>套接口层操作接口为<code>inet_dgram_ops</code></li>
<li><em>没有扩展</em></li>
</ul>
<h4 id="335udp">33.5、UDP的状态<a class="headerlink" href="#335udp" title="Permanent link">&para;</a></h4>
<ul>
<li>UDP的传输是没有状态的</li>
</ul>
<h4 id="336udp">33.6、UDP传输控制块的管理<a class="headerlink" href="#336udp" title="Permanent link">&para;</a></h4>
<ul>
<li>UDP并不是在hash接口中将其传输控制块添加到<strong>udp_hash散列表</strong>中的，而是<strong>在绑定端口后，才将其添加到散列表</strong>，关键字为端口号与散列表大小取模后的值。</li>
<li><code>udp_sock</code>，<code>socket结构</code>，<code>struct file结构</code></li>
</ul>
<h4 id="337bind">33.7、bind系统调用的实现<a class="headerlink" href="#337bind" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>UDP的绑定实际上完成两个功能</strong>：<ul>
<li>根据选取的合适端口号将传输控制块添加到udp_hash散列表中</li>
<li>并将端口号设置到传输控制块中</li>
</ul>
</li>
<li><code>inet_bind()</code><ul>
<li>原始IP，调用bind接口进行绑定</li>
<li>其他的包括TCP和UDP则调用<code>get_port()</code>进行绑定</li>
</ul>
</li>
<li>在UDP中实现传输接口层<code>get_port()</code>接口的函数是<code>udp_v4_get_port()</code>，<strong>真正绑定的是<code>__udp_lib_get_port()</code></strong></li>
</ul>
<h4 id="338udp">33.8、UDP套接口的关闭<a class="headerlink" href="#338udp" title="Permanent link">&para;</a></h4>
<ul>
<li>UDP的传输接口层的close接口为<code>udp_lib_close()</code>，通过对传输接口层的unhash接口的调用，把传输控制块从散列表中删除<ul>
<li><code>sk_common_release()</code></li>
</ul>
</li>
</ul>
<h4 id="339connect">33.9、connect系统调用的实现<a class="headerlink" href="#339connect" title="Permanent link">&para;</a></h4>
<ul>
<li><code>inet_dgram_connect()</code>为connect在UDP套接口层的实现</li>
</ul>
<h5 id="3391udp_disconnect">33.9.1、udp_disconnect()<a class="headerlink" href="#3391udp_disconnect" title="Permanent link">&para;</a></h5>
<ul>
<li>传输接口层UDP的disconnect接口的实现</li>
</ul>
<h5 id="3392ipv4_datagram_connect">33.9.2、ipv4_datagram_connect()<a class="headerlink" href="#3392ipv4_datagram_connect" title="Permanent link">&para;</a></h5>
<ul>
<li>传输接口层UDP的connect接口的实现</li>
</ul>
<h4 id="3310select">33.10、select系统调用的实现<a class="headerlink" href="#3310select" title="Permanent link">&para;</a></h4>
<ul>
<li><code>udp_poll()</code></li>
</ul>
<h4 id="3311udpioctl">33.11、UDP的ioctl<a class="headerlink" href="#3311udpioctl" title="Permanent link">&para;</a></h4>
<ul>
<li>SIOCOUTQ，返回标识该传输控制块为发送而分配的所有数据区的总大小</li>
<li>SIOCINQ，获取在接收队列缓存中第一个未读数据报的长度</li>
</ul>
<h4 id="3312udp_1">33.12、UDP的套接口选项<a class="headerlink" href="#3312udp_1" title="Permanent link">&para;</a></h4>
<ul>
<li>UDP套接口选项入口为<code>udp_setsockopt()</code><ul>
<li>如果是<code>SOL_UDP</code>和<code>SOL_UDPLITE</code>级别，调用<code>udp_lib_setsockopt()</code></li>
<li>否则通过IP接口调用<code>ip_setsockopt()</code></li>
</ul>
</li>
</ul>
<h4 id="3313udp">33.13、UDP校验和<a class="headerlink" href="#3313udp" title="Permanent link">&para;</a></h4>
<h5 id="33131udp">33.13.1、输入UDP数据报校验和的计算<a class="headerlink" href="#33131udp" title="Permanent link">&para;</a></h5>
<ul>
<li>1、udp4_csum_init()<ul>
<li>用于UDP数据报接收校验的初始化</li>
</ul>
</li>
<li>2、udp_lib_checksum_complete()<ul>
<li>基于伪首部累加和，完成全包校验和的检测</li>
</ul>
</li>
</ul>
<h5 id="33132udp">33.13.2、输出UDP数据报校验和的计算<a class="headerlink" href="#33132udp" title="Permanent link">&para;</a></h5>
<ul>
<li>1、udp4_hwcsum_outgoing()</li>
<li>2、csum_tcpudp_magic()和udp_csum_outgoing()<ul>
<li>udp_csum_outgoing()用在硬件不支持完成校验和的情况下</li>
</ul>
</li>
</ul>
<h4 id="3314udpsendmsg">33.14、UDP的输出：sendmsg系统调用<a class="headerlink" href="#3314udpsendmsg" title="Permanent link">&para;</a></h4>
<h5 id="33141udp_sendmsg">33.14.1、udp_sendmsg()<a class="headerlink" href="#33141udp_sendmsg" title="Permanent link">&para;</a></h5>
<ul>
<li>实现了UDP数据报的组织和发送</li>
</ul>
<h5 id="33142udp_push_pending_frames">33.14.2、udp_push_pending_frames()<a class="headerlink" href="#33142udp_push_pending_frames" title="Permanent link">&para;</a></h5>
<ul>
<li>将待发送数据打包成一个UDP数据报输出</li>
</ul>
<h4 id="3315udp">33.15、UDP的输入<a class="headerlink" href="#3315udp" title="Permanent link">&para;</a></h4>
<h5 id="33151udpudp_rcv">33.15.1、UDP接收的入口：udp_rcv()<a class="headerlink" href="#33151udpudp_rcv" title="Permanent link">&para;</a></h5>
<ul>
<li>UDP层的数据接收，对于套接口而言，就是<strong>接收队列的入队操作</strong>，在IP层，如果是发送到本地数据，则会交由<code>ip_local_deliver_finish()</code>处理</li>
</ul>
<h5 id="33152udp__udp4_lib_mcast_deliver">33.15.2、UDP组播数据报输入：__udp4_lib_mcast_deliver()<a class="headerlink" href="#33152udp__udp4_lib_mcast_deliver" title="Permanent link">&para;</a></h5>
<h5 id="33153udp_queue_rcv_skb">33.15.3、udp_queue_rcv_skb()<a class="headerlink" href="#33153udp_queue_rcv_skb" title="Permanent link">&para;</a></h5>
<ul>
<li>将UDP数据报添加到所属传输控制块的接收队列中的功能由udp_queue_rcv_skb()来实现</li>
</ul>
<h4 id="3316recvmsg">33.16、recvmsg系统调用的实现<a class="headerlink" href="#3316recvmsg" title="Permanent link">&para;</a></h4>
<ul>
<li>实现UDP的传输接口层的recvmsg接口函数为<code>udp_recvmsg()</code></li>
</ul>
<ul>
<li>udp_recvmsg()实现了主动从传输控制块的接收队列中读取数据到用户空间的缓冲区中。</li>
</ul>
<h4 id="3317udpudp_err">33.17、UDP的差错处理：udp_err()<a class="headerlink" href="#3317udpudp_err" title="Permanent link">&para;</a></h4>
<h4 id="3318udp">33.18、轻量级UDP<a class="headerlink" href="#3318udp" title="Permanent link">&para;</a></h4>
<ul>
<li>在UDP-Lite协议中，一个数据包到底需不需要对其负载进行校验，或者是校验多少位都是由用户控制的</li>
<li><code>s = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDPLITE);</code></li>
</ul>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
