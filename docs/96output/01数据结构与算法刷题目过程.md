## 数据结构与算法刷题目过程

### 0、

#### 0.1、一些摘抄

+ 每道类型的题，刷一道，不求多，但求精

#### 0.2、自己感悟

+ 1、知识是有衔接，A不会，就分解，把**具体哪不会的搞懂**
+ 2、学新知识点时，找到**最经典或简单的例子去消化那种思想**，然后再去套复杂场景，不然完全hold不住

### 1、数据结构1：二维数组、线性表、栈、队列、哈希表

+ *对应的是一些基础题，没有啥明显算法的*
+ 具体数据结构就不在这展示了，**主要是使用STL的库**

#### 1.1、二维数组

#### 1.2、线性表

#### 1.3、栈

#### 1.4、队列

#### 1.5、哈希表

+ 常用的操作：**插入、查找、遍历**
+ 自己的问题
  + 1、set与map有啥区别？*泛型那本书有解释过，但没完全明白*
  + 2、做题的时候，老是用map，较少用到set，*set的应用场景在哪？*

##### 1.5.1、map&unordered_map

+ 0、知识点
+ 题目
  + LC242、有效异位词
    + 看了下，自己做的，是先排序，然后逐个比较，人家的思路是*定义一个map，一个++，一个--*

##### 1.5.2、set&unordered_set

+ 0、知识点
  + set.insert()，*不记得了*
  + `set.find(x)!=set.end()`，`set.count(x)!=0`
  + 我一般用`for(auto c: set)`，还有一种用**迭代器**，`for(auto it = set.begin(); it!=set.end();it++)`
+ 题目
  + LC349、2个数组，计算它们的交集
    + https://blog.csdn.net/linping_/article/details/116031412  【作者这一系列，都蛮多的】
    + *它这个解法有点妙*，两个数组，一个存，一个找到后，再删，最后比较数量   【记错了，不是这个思路，lionel】

##### 1.5.3、进阶

+ LC3、无重复字符的最长子串
  + *完全不太会，看了下之前的记录，也没刷出来，初看还以为考KMP呢*

### 2、数据结构2：树

### 3、数据结构3：图

### 4、数据结构4：堆、优先级队列、并查集

+ 堆、优先级队列

#### 4.3、并查集

##### 4.3.1、思想&模板

+ 概念
+ 模板

##### 4.3.2、题目

+ OD
+ LC

##### 4.3.3、进阶（元素不是int型，怎么初始化father数组）

### 5、六大算法1：贪心

#### 5.1、思想

#### 5.2、组合问题中贪心

##### 5.2.1、题目

+ OD
  + 最少面试官数
+ LC

##### 5.2.2、坑&心得

+ 1、**读懂题意**（有时候题，出得不好，难get到）**找到贪心策略**，然后**自定义排序**即可

#### 5.3、图问题中的贪心（不会）

+ OD中出现过中dijkstra（我只是懂了dijkstra做选择或填空，写代码还不行）

### 6、六大算法2：动态规划

+ *还得再复习下*

#### 6.1、思想&入门题

##### 6.1.2、入门题：Fibonacci sequence

#### 6.2、一维dp

##### 6.2.1、题目

+ OD
  + 高效会议安排

+ LC
  + 

#### 6.3、二维dp

##### 6.3.1、题目

+ OD
  + 代表团坐车
    + *我还没完全懂呢*

### 7、六大算法3：回溯（DFS）

+ 回溯与DFS区别？
+ 除了背模板外，**真正的点，还在于如何去理解业务**，要在不同题目中去体会

#### 7.1、思想&入门题

##### 7.1.2、全排列

#### 7.2、图问题中的回溯：DFS

##### 7.2.1、邻接矩阵存储时的回溯，用的是递归（题目）

+ OD
  + 寻找最大价值矿堆
+ LC
  + 695
+ 模板
  + 1、初始化没有问题，**啥情况调用dfs，参数怎么组织** 
    + **用(x,y)一些是矩阵里的坐标**，层数就一个即可，*也是根据题目意思来*
    + *问题在于，这个调用层里，有没有业务逻辑要处理*
  + 2、dfs实现
    + 2.1、把矩阵的行、列大小取到，也可以是传值过来的
    + 2.2、用完后，用`vistited`标记一下
    + 2.3、在4个方向（根据题目意思）判断**不越界&&业务条件**，再调用dfs
      + 因为是递归，肯定要有变化的地方，**这时候，一般是x,y有变化**

```cpp
int dirs21[4][2] = { {1,0},{-1,0},{0,-1},{0,1} };

void dfs(vector<vector<int>>& input, int x, int y, int& island) {
	int row = input.size();
	int col = input[0].size();
	island += input[x][y];

	input[x][y] = 0; //修改一下，相当于visited[][]
	
	for (auto dir : dirs21) {
		int mx = x + dir[0];
		int my = y + dir[1];
		if (mx >= 0 && mx < row && my >= 0 && my < col && input[mx][my]) {
			dfs(input, mx, my, island);
		}
	}
}


void od_a21_impl(vector<vector<int>> &input) {
	int row = input.size();
	int col = input[0].size();

	int res = 0, island = 0;
	for (int i = 0; i < row; i++) {
		for (int j = 0; j < col; j++) {
			if (input[i][j]) {
				dfs(input, i, j, island);
				res = max(res, island);   //这一步，才是点睛之笔
				island = 0;
			}
		}
	}
	cout << res << endl;
}
```



### 8、六大算法4：分治

### 9、六大算法5：分支限界（BFS）

### 10、六大算法6：蛮力

### 11、杂散：KMP

#### 11.1、KMP

+ 除了**`getNext()`求next数组**是模板外，其它还是**业务**（看题目场景）

##### 11.1.1、思想

+ 靠B站[帮你把KMP算法学个通透！（理论篇）](https://www.bilibili.com/video/BV1PD4y1o7nd/?spm_id_from=333.337.search-card.all.click)，**代码随想录**入的门

##### 11.1.2、模板

+ 第1步，初始化：
  + i表示啥，**初始化为1**
  + j表示啥，
  + `next[0]`，怎么初始化
+ 第2步，不相等时，**用`while()`，因为不是一次回退**
+ 第3步，相等时，j++
+ 第4步，更新`next[i]`

```cpp
void getNext(int *next, string s) {
	next[0] = 0;
	int j = 0;
	for (int i = 1; i < s.size(); i++) {
		while (j > 0 && s[i] != s[j]) {  //这一步，要用while
			j = next[j - 1];
		}
		if (s[i] == s[j]) {  //lionel，next数组这个差不多了，这个地方写错了，把==写成了=
			j++;
		}
		next[i] = j;
	}
}
```



### 附录

#### 1、字符串操作

+ https://en.cppreference.com/w/c/string/byte
  + *现在cppreference里这个有点多*，主要是针对这个

+ 因为我在`strstr()`的参数上没写对，所以**想把这个当作基础内容**

##### 1.1、字符数组与字符串

##### 1.2、常用字符串操作

+ 1、初始化
+ 2、获取长度，*两者区别*
  + strlen()
  + sizeof()
+ 3、
+ strstr()

##### 1.3、字符串的进阶

###### 1.3.1、split功能实现

+ 1、传统的方法
+ 2、用正则表达式

#### 2、ACM输入

##### 2.1、知识点（cin、getline()、getchar()）

+ cin
  + 单独输入、批量输入，**是个缓冲区**，头文件是`<iostream>`，当**读入的字符串中间存在空格时，cin读不全整个字符串**
  + 1、可以连续从键盘输入
  + 2、以空格、tab、换行符为分隔符
  + 3、从第1个非空格字符开始读取，直到遇到分隔符结束读取
+ getline()
  + 头文件是`<string>`
  + **解决cin中存在空格读不全的问题**，getline()会读入一行，包含空格，**遇到换行符结束**
    + `string s;  getline(cin,s);//原来可以这么写`
+ getchar()
  + 从缓冲区读出一个字符，**经常用于判断是否换行**
  + `while(cin >> num){push.(num);  if(getchar()=='\n') break;//读到换行符，终止循环}`

##### 2.2、练习题

+ 1、用逗号隔开的场景

##### 2.、ref

+ [ACM模式输入输出攻略 | C++篇](https://blog.csdn.net/qq_46046431/article/details/129266738)