<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>《Linux内核探秘》 - lionel的技术笔记</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u300aLinux\u5185\u6838\u63a2\u79d8\u300b";
        var mkdocs_page_input_path = "11filesystem\\Linux\u5185\u6838\u63a2\u79d8.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> lionel的技术笔记
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../01daily/">daily</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">C++</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/effectiveC%2B%2B/">《Effective C++》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/EffectiveSTL/">《Effective STL》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">基础知识</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">《操作系统导论》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">《大话设计模式》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网络编程</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">《TCP/IP网络编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">《Linux高性能服务器编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71/">《TCPIP详解卷1》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">文件系统</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">《Linux内核探秘》</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#chap2-1224232">chap2、文件系统   12（24/232）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#21">2.1、文件系统的基本概念</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#211vfs">2.1.1、什么是VFS</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#212super_block">2.1.2、超级块super_block</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#213dentry">2.1.3、目录项dentry</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#214inode">2.1.4、索引节点inode</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#215">2.1.5、文件</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#22">2.2、文件系统的架构</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#221">2.2.1、超级块作用分析</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#222dentry">2.2.2、dentry作用分析</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#223inode">2.2.3、inode作用分析</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#224">2.2.4、文件作用分析</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#23">2.3、从代码层次深入分析文件系统</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#231aufs">2.3.1、一个最简单的文件系统aufs</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#232">2.3.2、文件系统如何管理目录和文件</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#233">2.3.3、文件系统的挂载过程</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#234">2.3.4、文件打开的代码分析</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#24">2.4、本章小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap10-143155232">chap10、文件系统读写   143（155/232）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#101page-cache">10.1、page cache机制</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1011buffer-iodirect-io">10.1.1、buffer I/O和direct I/O</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1012buffer-head">10.1.2、buffer head和块缓存</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1013page-cache">10.1.3、page cache的管理</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1014page-cache">10.1.4、page cache的状态</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#102">10.2、文件预读</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#103">10.3、文件锁</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#104">10.4、文件读过程代码分析</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#105">10.5、读过程返回</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#106">10.6、文件写过程代码分析</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#107">10.7、本章小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap11scsi-170182232">chap11、通用块层和scsi层   170（182/232）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#111">11.1、块设备队列</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1111scsi">11.1.1、scsi块设备队列处理函数</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1112">11.1.2、电梯算法和对象</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#112hba">11.2、硬盘HBA抽象层</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#113io">11.3、I/O的顺序控制</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#114io">11.4、I/O调度算法</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1141noop">11.4.1、noop调度算法</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1142deadline">11.4.2、deadline调度算法</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#115io">11.5、I/O的处理过程</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1151io">11.5.1、I/O插入队列的过程分析</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1152io">11.5.2、I/O出队列的过程分析</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1153io">11.5.3、I/O返回路径</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#116">11.6、本章小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap12-204216232">chap12、内核回写机制   204（216/232）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#121">12.1、内核的触发条件</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#122">12.2、内核回写控制参数</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#123">12.3、定时器触发回写</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1231">12.3.1、启动定时器</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1232">12.3.2、执行回写操作</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1233">12.3.3、检查需要回写的页面</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1234inode">12.3.4、回写超级块内的inode</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#12341">12.3.4.1、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#12342">12.3.4.2、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#12343">12.3.4.3、</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#12344">12.3.4.4、</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#124">12.4、平衡写</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1241">12.4.1、检查直接回写的条件</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1242">12.4.2、回写系统脏页面的条件</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1243">12.4.3、检查计算机模式</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#125">12.5、本章小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap13ext2-217229232">chap13、一个真实文件系统ext2   217（229/232）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#131ext2">13.1、ext2的硬盘布局</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#132ext2">13.2、ext2文件系统目录树</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#133ext2">13.3、ext2文件内容管理</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#134ext2">13.4、ext2文件系统读写</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#135">13.5、本章小结</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《文件系统技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">《存储技术原理分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">存储</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../12storage/ceph%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《ceph设计原理与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">视频</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/FFmpeg%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">《FFmpeg入门到精通》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AE%9E%E6%97%B6%E4%BA%92%E5%8A%A8%E6%8A%80%E6%9C%AF/">《WebRTC音视频实时互动技术》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/%E6%96%B0%E4%B8%80%E4%BB%A3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%A0%81%E6%A0%87%E5%87%86-H.264_AVC/">《新一代视频压缩码标准-H.264_AVC》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">内核</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《Linux内核设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/">《深入Linux设备驱动程序内核机制》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">《深入理解Linux虚拟内存管理》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《深入理解Linux网络技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/">《深入理解Linux内核》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">工具</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/">《Wireshark网络分析实战》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%283rd%29/">《Linux命令行与shell脚本编程大全(3rd)》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">刷题</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../91leetcode/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/">《剑指offer专项突破》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网课</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/01Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/">《Linux高并发网络编程开发》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/%E4%BE%AF%E6%8D%B7/%E4%BE%AF%E6%8D%B7C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8660%E8%AE%B2/">《侯捷C++内存管理60讲》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/11NJU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">《NJU算法设计与分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">英语专</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../60English/00794%E7%BB%BC%E5%90%88%E8%8B%B1%E8%AF%AD%E4%B8%80%E4%B8%8A/">《综合英语(一)上》</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">lionel的技术笔记</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>文件系统 &raquo;</li>
      <li>《Linux内核探秘》</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h2 id="linux">《Linux内核探秘》<a class="headerlink" href="#linux" title="Permanent link">&para;</a></h2>
<h3 id="chap2-1224232">chap2、文件系统   12（24/232）<a class="headerlink" href="#chap2-1224232" title="Permanent link">&para;</a></h3>
<h4 id="21">2.1、文件系统的基本概念<a class="headerlink" href="#21" title="Permanent link">&para;</a></h4>
<h5 id="211vfs">2.1.1、什么是VFS<a class="headerlink" href="#211vfs" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>VFS本身只存在于内存中</strong>，它需要将硬盘上的文件系统抽象到内存中，通过几个<strong>重要的结构</strong>（<code>dentry、inode、super_block</code>）</li>
</ul>
<h5 id="212super_block">2.1.2、超级块super_block<a class="headerlink" href="#212super_block" title="Permanent link">&para;</a></h5>
<ul>
<li>代表了<strong>整个文件系统本身</strong>，<ul>
<li>给出了文件系统的全局信息</li>
<li>包含一些函数指针</li>
</ul>
</li>
</ul>
<h5 id="213dentry">2.1.3、目录项dentry<a class="headerlink" href="#213dentry" title="Permanent link">&para;</a></h5>
<ul>
<li>目录项反映了文件系统的这种树状关系</li>
</ul>
<h5 id="214inode">2.1.4、索引节点inode<a class="headerlink" href="#214inode" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>inode代表一个文件</strong></li>
</ul>
<h5 id="215">2.1.5、文件<a class="headerlink" href="#215" title="Permanent link">&para;</a></h5>
<ul>
<li>文件对象的作用是<strong>描述进程和文件交互的关系</strong>。 【<strong>文件对象</strong>指的是内存中的文件】</li>
<li>进程打开一个文件，内核就动态创建一个文件对象。同一个文件，在不同的进程中有不同的文件对象。</li>
</ul>
<h4 id="22">2.2、文件系统的架构<a class="headerlink" href="#22" title="Permanent link">&para;</a></h4>
<h5 id="221">2.2.1、超级块作用分析<a class="headerlink" href="#221" title="Permanent link">&para;</a></h5>
<h5 id="222dentry">2.2.2、dentry作用分析<a class="headerlink" href="#222dentry" title="Permanent link">&para;</a></h5>
<h5 id="223inode">2.2.3、inode作用分析<a class="headerlink" href="#223inode" title="Permanent link">&para;</a></h5>
<ul>
<li>系统内核提供了一个hash链表数组<code>inode_hashtable</code></li>
<li>inode还有一个重要用作用是<strong>缓存文件的数据内容</strong>，通过成员<code>i_mapping</code>实现的。</li>
</ul>
<h5 id="224">2.2.4、文件作用分析<a class="headerlink" href="#224" title="Permanent link">&para;</a></h5>
<h4 id="23">2.3、从代码层次深入分析文件系统<a class="headerlink" href="#23" title="Permanent link">&para;</a></h4>
<h5 id="231aufs">2.3.1、一个最简单的文件系统aufs<a class="headerlink" href="#231aufs" title="Permanent link">&para;</a></h5>
<pre class="highlight"><code class="language-cpp">#include &lt;linux/moudle.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/pagemap.h&gt;
#include &lt;linux/mount.h&gt;
#include &lt;linut/init.h&gt;
#include &lt;linux/nami.h&gt;

#define AUFS_MAIGC 0x64668735
static struct vfsmount* aufs_mount;
static int aufs_mount_count;

static struct inode* aufs_get_inode(struct super_block* sb, int mode, dev_t dev)
{
    struct inode* inode = new_inode(sb);
    if (inode) {
        inode-&gt;i_mode = mode;
        inode-&gt;i_uid = current-&gt;fsuid;
        inode-&gt;i_gid = current-&gt;fsgid;
        inode-&gt;i_blksize = PAGE_CACHE_SIZE;
        inode-&gt;i_blocks = 0;
        inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;
        switch (mode &amp; S_IFMT) {
        default:
            int_special_inode(inode, mode, dev);
            break;
        case S_IFREG:
            printk("create a file \n");
            break;
        case S_IFDIR:
            inode-&gt;i_op = &amp;simple_dir_inode_operations;
            inode-&gt;i_fop = &amp;simple_dir_operations;
            printk("create a dir file \n");

            inode-&gt;i_nlink++;
            break;
        }
    }
    return inode;
}

//SMP-safe
static int aufs_mknod(struct inode* dir, struct dentry* dentry, int mode, dev_t dev)
{
    struct inode* inode;
    int error = -EPERM;

    if (dentry-&gt;d_inode)
        return -EEXIST;

    inode = aufs_get_inode(dir-&gt;i_sb, mode, dev);
    if (inode) {
        d_instantiate(dentry, inode);
        dget(dentry);
        error = 0;
    }
    return error;
}

static int aufs_mkdir(struct inode* dir, struct dentry* dentry, int mode)
{
    int res;
    res = aufs_mknode(dir, dentry, mode | S_IFDIR, 0);
    if (!res)
        dir-&gt;i_nlink++;
    return res;
}

static int aufs_create(struct inode* dir, struct dentry* dentry, int mode)
{
    return aufs_mknode(dir, entry, mode | S_IFREG, 0);
}

static int aufs_fill_super(struct super_block* sb, void* data, int silent)
{
    static struct tree_descr debug_files[] = { {""} };
    return simple_fill_super(sb, AUFS_MAIGC, debug_files);//lionel，也是系统提供的啊，还是fs目录下libfs.c中的
}

static struct super_block* aufs_get_sb(struct file_system_type* fs_type,
    int flags, const char* dev_name, void* data)
{
    return get_sb_single(fs_type, flags, data, aufs_fill_super);
}

static struct file_system_type au_fs_type = {
    .owner = THIS_MODULE,
.name = "aufs",
.get_sb = aufs_get_sb,
.kill_sb = kill_litter_super,
};

static int aufs_create_by_name(const char* name, mode_t mode,
    struct dentry* parent,
    struct dentry** dentry)
{
    int error = 0;
    /* If the parent is not specified, we create it in the root.
    * We need the root dentry to do this, which is in the super
    * block. A pointer to that is in the struct vfsmount that we
    * have around.
    */
    if (!parent) {
        if (aufs_mount &amp;&amp; aufs_mount-&gt;mnt_sb) {
            parent = aufs_mount-&gt;mnt_sb-&gt;s_root;
        }
    }
    if (!parent) {
        printk("Ah! can not find a parent!\n");
        return -EFAULT;
    }

    *dentry = NULL;
    mutex_lock(&amp;parent-&gt;d_inode-&gt;i_mutex);
    &amp;dentry = lookup_one_len(name, parent, strlen(name));
    if (!IS_ERR(dentry)) {
        if ((mode &amp; S_IFMT) == S_IFDIR)
            error = aufs_mkdir(parent-&gt;d_inode, *dentry, mode);
        else
            error = aufs_create(parent-&gt;d_inode, *dentry, mode);
    }
    else
        error = PTR_ERR(dentry);
    mutex_unlock(&amp;parent-&gt;d_inode-&gt;i_mutex);
    return error;
}

struct dentry* aufs_create_file(const char* name, mode_t mode,
    struct dentry* parent, void* data,
    struct file_operations* fops)
{
    struct dentry* dentry = NULL;
    int error;
    printk("aufs: creating file '%s'\n", name);
    error = aufs_create_by_name(name, mode, parent, &amp;dentry);
    if (error) {
        dentry = NULL;
        goto exit;
    }
    if (dentry-&gt;d_inode) {
        if (data)
            dentry-&gt;d_inode-&gt;u.generic_ip = data;
        if (fops)
            dentry-&gt;d_inode-&gt;i_fop = fops;
    }
exit:
    return dentry;
}

struct dentry* aufs_create_dir(const char* name, struct dentry* parent)
{
    return aufs_create_file(name, S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO, parent, NULL, NULL);
}

static int __init aufs_init(void)
{
    int retval;
    struct dentry* pslot;

    retval = register_filesystem(&amp;au_fs_type);

    if (!retval) {
        aufs_mount = kern_mount(&amp;au_fs_type);  //lionel，kern_mount()【这个在super.c中】与do_mount()【这个在fs里的namespace.c中】有关联不？
        if (IS_ERROR(aufs_mount)) {
            printk(KERN_ERR "aufs: could not mount!\n");
            unregister_filesystem(&amp;au_fs_type);
            return retval;
        }
    }

    pslot = aufs_create_dir("woman star", NULL);
    aufs_create_file("lbb", S_IFREG | S_IRUGO, pslot, NULL, NULL);
    aufs_create_file("fbb", S_IFREG | S_IRUGO, pslot, NULL, NULL);
    aufs_create_file("ljl", S_IFREG | S_IRUGO, pslot, NULL, NULL);

    pslot = aufs_create_dir("man star", NULL);
    aufs_create_file("ldh", S_IFREG | S_IRUGO, pslot, NULL, NULL);
    aufs_create_file("lcw", S_IFREG | S_IRUGO, pslot, NULL, NULL);
    aufs_create_file("jw", S_IFREG | S_IRUGO, pslot, NULL, NULL);

    return retval;
}

static void __exit aufs_exit(void)
{
    simple_release_fs(&amp;aufs_mount, &amp;aufs_mount_count);
    unregister_filesystem(&amp;au_fs_type);
}

module_init(aufs_init);
module_exit(aufs_exit);
MODULE_LICENSE("GPL");
MOUDLE_DESCRIPTION("This is a simple module");
MODULE_VERSION("Ver 0.1");


/*
* mkdir au
* mount -t aufs none /au
* ls
*/
</code></pre>
<h5 id="232">2.3.2、文件系统如何管理目录和文件<a class="headerlink" href="#232" title="Permanent link">&para;</a></h5>
<ul>
<li>代码三部分<ul>
<li>1）<code>register_filesystem</code>函数，把aufs文件系统登记到系统</li>
<li>2）调用<code>kern_mount</code>函数为文件系统申请必备的数据结构</li>
<li>3）最后在aufs文件系统内创建两目录，每个目录下面创建3个文件</li>
</ul>
</li>
</ul>
<h5 id="233">2.3.3、文件系统的挂载过程<a class="headerlink" href="#233" title="Permanent link">&para;</a></h5>
<h5 id="234">2.3.4、文件打开的代码分析<a class="headerlink" href="#234" title="Permanent link">&para;</a></h5>
<h4 id="24">2.4、本章小结<a class="headerlink" href="#24" title="Permanent link">&para;</a></h4>
<h3 id="chap10-143155232">chap10、文件系统读写   143（155/232）<a class="headerlink" href="#chap10-143155232" title="Permanent link">&para;</a></h3>
<h4 id="101page-cache">10.1、page cache机制<a class="headerlink" href="#101page-cache" title="Permanent link">&para;</a></h4>
<ul>
<li>其存储的数据在I/O完成后并不回收，而是一直保留在内存中，除非内存紧张，才开始回收。</li>
</ul>
<h5 id="1011buffer-iodirect-io">10.1.1、buffer I/O和direct I/O<a class="headerlink" href="#1011buffer-iodirect-io" title="Permanent link">&para;</a></h5>
<ul>
<li>buffer I/O，是内核缓存</li>
<li>direct I/O，是应用提供的内存</li>
<li><strong>应用提供的<code>read</code>和<code>write</code>接口，是同步I/O接口</strong>。</li>
</ul>
<h5 id="1012buffer-head">10.1.2、buffer head和块缓存<a class="headerlink" href="#1012buffer-head" title="Permanent link">&para;</a></h5>
<ul>
<li><code>struct buffer_head{}</code></li>
</ul>
<h5 id="1013page-cache">10.1.3、page cache的管理<a class="headerlink" href="#1013page-cache" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>通过数据结构address_space管理page cache</strong></li>
<li><code>add_to_page_cache()</code>，插入页面到page cache</li>
</ul>
<h5 id="1014page-cache">10.1.4、page cache的状态<a class="headerlink" href="#1014page-cache" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p>page cache的状态：</p>
<ul>
<li>PG_dirty：</li>
<li>块缓存</li>
<li>BH_Mapped</li>
</ul>
</li>
</ul>
<h4 id="102">10.2、文件预读<a class="headerlink" href="#102" title="Permanent link">&para;</a></h4>
<ul>
<li>readhead.c中<code>struct backing_dev_info{}</code></li>
</ul>
<h4 id="103">10.3、文件锁<a class="headerlink" href="#103" title="Permanent link">&para;</a></h4>
<ul>
<li>实现机制不同：<ul>
<li>建议锁</li>
<li>强制锁</li>
</ul>
</li>
<li>访问方式不同：<ul>
<li>读锁（共享锁）</li>
<li>写锁（互斥锁）</li>
</ul>
</li>
</ul>
<h4 id="104">10.4、文件读过程代码分析<a class="headerlink" href="#104" title="Permanent link">&para;</a></h4>
<ul>
<li><code>sys_read()</code></li>
<li>read_write.c中的<code>sys_read()</code><ul>
<li>根据fd，得到file结构；取得文件当前位置</li>
</ul>
</li>
<li>read_write.c中的<code>vfs_read()</code><ul>
<li>校验权限；看是否有自定义的read</li>
</ul>
</li>
<li>1.generic_file_read函数<ul>
<li><code>vfs_read()</code>-&gt;filemap.c中的<code>generic_file_read()</code>    <strong>解决文件同步和异步操作问题</strong>，<code>kiocb</code>结构</li>
<li><code>kiocb</code>结构定义在include/aio.h中，实现在aio.c中</li>
</ul>
</li>
<li>2.<code>__generic_file_aio_read</code>函数<ul>
<li>file_map.c中，函数比较长，分3部分<ul>
<li>第一部分：校验</li>
<li>第二部分：处理direct I/O</li>
<li>第三部分：使用了读描述符结构desc</li>
</ul>
</li>
</ul>
</li>
<li>3.do_generic_file_read函数<ul>
<li>file_map.c中，<strong>内核提供的通用读函数</strong></li>
</ul>
</li>
<li>4.do_generic_mapping_read函数<ul>
<li>file_map.c中，计算文件读操作涉及的页面参数，<strong>比较复杂</strong>，分7个部分：<ul>
<li>第一部分：</li>
<li>第三部分：处理页面状态是最新的情况</li>
<li>第七部分：更新文件的位置，修改文件的预读状态。</li>
</ul>
</li>
<li><strong>从硬盘读数据是通过文件系统提供的readpage函数实现的</strong>。</li>
<li>ext2文件系统提供的读页面函数是 inode.c中的<code>ext2_readpage()</code>，直接调用<code>mpage_readpage()</code><strong>内核提供的一个通用函数</strong>，它调用<code>do_mpage_readpage</code>将读请求转换为一个bio结构，如果bio有效，则提交bio给底层去执行读操作。</li>
</ul>
</li>
<li><strong>文件系统的读写请求，最终要转换成对块设备的读写请求</strong>，这涉及几个问题：
    + 文件对用户呈现了一个连续的读写接口，但是文件在真正物理设备硬盘上的存储可能并不是连续的，如果是不连续的，对文件的读写就不能用同一个I/O完成，而是需要拆分。
    + 内核通过<code>submit_bio</code>来提交一个I/O给底层。同时内核又提供了一个函数<code>submit_bh</code>来提交块。submit_bh最终也是通过submit_bio来实现，<strong>它只是多了将块地址转换为硬盘物理扇区地址的过程</strong>。</li>
<li>5.do_mpage_readpage函数<ul>
<li>也分了几个部分<ul>
<li>第六部分：confused分支代码</li>
</ul>
</li>
</ul>
</li>
<li>6.block_read_full_page函数<ul>
<li>前面与do_mpage_readpage前面部分流程类似</li>
<li>arr数组，保存了页面内的每一个文件块的物理块号</li>
</ul>
</li>
</ul>
<h4 id="105">10.5、读过程返回<a class="headerlink" href="#105" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>文件系统通过mpage_bio_submit提交一个I/O</strong>。这个I/O什么时候返回？通过什么机制通知上层？这涉及内核I/O过程的阻塞点设计。</li>
<li>mpage.c中的<code>mpage_bio_submit()</code>，调用<code>mpage_bio_read()</code>【在I/O完成后的中断过程中调用的】</li>
<li>mpage.c中的<code>mpage_end_io_read()</code>要遍历bio结构的每个向量，看相关页面是否获得最新的数据。</li>
</ul>
<h4 id="106">10.6、文件写过程代码分析<a class="headerlink" href="#106" title="Permanent link">&para;</a></h4>
<ul>
<li><code>sys_write()</code></li>
<li>1.generic_file_wirte函数<ul>
<li>filemap.c中的，buffer I/O读写对象是page cache，<strong>当用户希望真正写到硬盘时，文件就需要设置SYNC标志</strong>，调用<code>sync_page_range</code>把page cache的页面写入硬盘。</li>
</ul>
</li>
<li>2.generic_file_buffered_write函数
    + <code>__generic_file_io_write_nolock()</code>
    + 分为4部分
        + 第四部分：检查文件是否具有SYNC标志</li>
<li>3.获得文件块的物理块号
    + <code>prepare_write()</code>和<code>commit_write()</code>功能，对于ext2而言就是<code>ext2_prepare_write()</code>和<code>generic_commit_write()</code>
    + <code>ext2_prepare_write()</code>真正实现的是buffer.c中的<code>__block_preapre_write()</code>
        + 第一部分
        + 第二部分
        + 第三部分：检查前面的处理过程是否产生了读请求
    + <code>generic_commit_write()</code>作用是，逐个遍历所有文件块，检查块缓存是否最新。</li>
</ul>
<h4 id="107">10.7、本章小结<a class="headerlink" href="#107" title="Permanent link">&para;</a></h4>
<ul>
<li>涉及文件中一些复杂参数的计算和page cache中页面缓存的状态处理。</li>
</ul>
<h3 id="chap11scsi-170182232">chap11、通用块层和scsi层   170（182/232）<a class="headerlink" href="#chap11scsi-170182232" title="Permanent link">&para;</a></h3>
<ul>
<li><em>lionel，这里面会涉及到一些I/O管理？</em></li>
</ul>
<ul>
<li>上接文件系统的VFS层，下接硬盘驱动。<strong>处理I/O的合并或者排序</strong></li>
</ul>
<h4 id="111">11.1、块设备队列<a class="headerlink" href="#111" title="Permanent link">&para;</a></h4>
<h5 id="1111scsi">11.1.1、scsi块设备队列处理函数<a class="headerlink" href="#1111scsi" title="Permanent link">&para;</a></h5>
<ul>
<li><code>scsi_alloc_queue()</code></li>
<li>为scsi块设备创建队列结构时调用。</li>
<li>默认为scsi设备提供了出队列函数<code>scsi_request_fn()</code>和软中断完成函数<code>scsi_softirq_done()</code></li>
</ul>
<h5 id="1112">11.1.2、电梯算法和对象<a class="headerlink" href="#1112" title="Permanent link">&para;</a></h5>
<ul>
<li><code>struct elevator_type{}</code></li>
</ul>
<h4 id="112hba">11.2、硬盘HBA抽象层<a class="headerlink" href="#112hba" title="Permanent link">&para;</a></h4>
<ul>
<li><code>struct scsi_host_template{}</code></li>
</ul>
<ul>
<li><code>static struct elevator_type elevator_noop = {};</code></li>
</ul>
<h4 id="113io">11.3、I/O的顺序控制<a class="headerlink" href="#113io" title="Permanent link">&para;</a></h4>
<h4 id="114io">11.4、I/O调度算法<a class="headerlink" href="#114io" title="Permanent link">&para;</a></h4>
<h5 id="1141noop">11.4.1、noop调度算法<a class="headerlink" href="#1141noop" title="Permanent link">&para;</a></h5>
<ul>
<li><code>noop_add_request()</code></li>
</ul>
<ul>
<li><code>noop_dispatch()</code></li>
</ul>
<ul>
<li>noop，基本什么都没做，等同于一个先进先出的调度算法，本身没对I/O进行真正的排序。入队列函数决定了I/O是如何插入电梯队列的，<strong>加入noop的链表</strong>。</li>
</ul>
<ul>
<li>I/O调度算法的出队列函数决定了I/O是如何被挑选，然后由硬盘驱动执行。<p>+ <strong>I/O从块设备队列到驱动执行的过程，是由scsi层控制的</strong></p>
</li>
</ul>
<h5 id="1142deadline">11.4.2、deadline调度算法<a class="headerlink" href="#1142deadline" title="Permanent link">&para;</a></h5>
<ul>
<li><code>struct deadline_data{}</code></li>
</ul>
<ul>
<li><code>deadline_add_request()</code></li>
</ul>
<ul>
<li>内部启用了一个红黑树结构来对I/O进行排序，保证出队列时，<strong>已经按照扇区地址排好顺序了</strong>。block/deadline-iosched.c中的</li>
</ul>
<ul>
<li><code>deadline_data</code>结构有2个队列，<strong>一个是红黑树sort_list，另一个是链表fifo_list</strong>（读写请求分别保存在不同的队列中）</li>
</ul>
<ul>
<li>出队列函数是<code>deadline_dispatch_requests()</code>
    + 第一部分，判断是否连续的批模式
    + 第二部分，检查读写请求的饥饿时间
    + 第三部分，挑选一个出队列的I/O
    + 最后，重新开启一轮循环，<code>deadline_find_first_drq()</code></li>
</ul>
<h4 id="115io">11.5、I/O的处理过程<a class="headerlink" href="#115io" title="Permanent link">&para;</a></h4>
<h5 id="1151io">11.5.1、I/O插入队列的过程分析<a class="headerlink" href="#1151io" title="Permanent link">&para;</a></h5>
<ul>
<li>1、submit_bio函数
    + 是文件系统VFS层和通用块层的衔接点，调用generic_make_request函数</li>
<li>2、generic_make_request函数
    + 把入参的bio结构转换为底层处理的请求结构
        + 第一部分，检查最大扇区限制
        + 第二部分，检查I/O的大小不应该超过块设备的最大可处理扇区</li>
<li>3、<code>__generic_make_request</code>函数
    + 第一部分，从bio结构获得I/O的起始扇区地址和以扇区度量的I/O大小
    + 第二部分，首先检查是否需要bounce，其次检查I/O是否barrier I/O
    + 第三部分，处理后向合并
    + 第四部分，处理前向合并
    + 第五部分，申请请求</li>
<li>4、elv_merge函数
    + 判断两个I/O能否合并，通过两步：
        + 第一步，判断能否和块设备队列的最后一个请求合并
        + 第二步，调用电梯队列提供的函数判断能否合并</li>
<li>5、<code>__elv_add_request</code>函数
    + 对于不能合并的I/O，需要把一个请求插入到队列。</li>
<li>6、elv_insert函数
    + 第一部分，处理前向插入
    + 第二部分，处理后向插入
    + 第三部分，处理按顺序插入和重插
    + 第四部分，检查队列的限制</li>
</ul>
<h5 id="1152io">11.5.2、I/O出队列的过程分析<a class="headerlink" href="#1152io" title="Permanent link">&para;</a></h5>
<ul>
<li>0
    + I/O从队列出来真正下发到硬盘？以下几个条件
        + 第一个I/O启动了3毫秒的定时器，时间到了，会执行unplug函数，开始下发I/O
        + 请求数目超过设定的限制（默认是4），执行unplug函数，开始下发
        + 带有sync标志的I/O，立即执行unplug函数，开始下发
        + barrier I/O，需要先清空电梯队列，然后执行unplug函数，开始下发
        + 当硬盘执行完毕一个I/O，也要unplug队列，检查是否有I/O可以执行</li>
<li>1、unplug函数
    + 先检查队列是否设置了stop标志，其次清除队列的plug标志，然后调用队列的request_fn函数</li>
<li>2、scsi_request_fn函数
    + 第一部分，调用<code>elv_next_request()</code>从块设备队列获得一个请求
    + 第二部分，检查各种异常情况
    + 第三部分，初始化保存scsi错误返回值的数据buffer，然后调用<code>scsi_dispatch_cmd()</code>将I/O下发到驱动
    + 第四部分，两个处理错误分支</li>
<li>3、elv_next_request函数
    + 从块设备队列获得一个I/O
    + 第一部分，调用<code>__elv_next_request()</code>从队列中获得一个I/O请求
    + 第二部分，调用队列的<code>prep_rq_fn()</code>来预处理I/O</li>
<li>4、blk_do_ordered函数
    + 检查I/O的顺序，<strong>为了处理barrier I/O</strong>
    + 第一部分，
    + 第二部分，处理特殊情况</li>
<li>5、start_ordered函数
    + 根据要求设置同步cache命令，保证同步cache命令之前的I/O必须完成
    + 第一部分，设置I/O请求的必要参数
    + 第二部分，设置同步cache的命令</li>
<li>6、scsi_dispatch_cmd函数</li>
</ul>
<h5 id="1153io">11.5.3、I/O返回路径<a class="headerlink" href="#1153io" title="Permanent link">&para;</a></h5>
<ul>
<li>0
    + <code>scsi_done()</code>是I/O返回路径上的第一个函数
    + <code>blk_complete_request()</code>
    + <code>scsi_softirq_done()</code></li>
<li><strong><code>scsi_decide_disposition()</code>值得仔细研究，总结了所有的scsi错误类型</strong>，并给出了处理措施</li>
<li>1、sd_rw_intr函数
    + 对scsi命令的各种错误进行处理
    + 第一部分，如果scsi命令的返回结果result不为0，说明命令执行中产生了错误。
    + 第二部分，检查scsi命令的sense key</li>
<li>2、scsi_io_completion函数
    + 第一部分，
    + 第二部分
    + 第三部分</li>
<li>3、scsi_end_request函数</li>
<li><strong>bio设置的回调函数是<code>mpage_end_io_read()</code></strong>.</li>
</ul>
<h4 id="116">11.6、本章小结<a class="headerlink" href="#116" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>通用块层、I/O调度算法和scsi层，共同构建了文件系统之下的I/O处理流程</strong>。</li>
</ul>
<h3 id="chap12-204216232">chap12、内核回写机制   204（216/232）<a class="headerlink" href="#chap12-204216232" title="Permanent link">&para;</a></h3>
<h4 id="121">12.1、内核的触发条件<a class="headerlink" href="#121" title="Permanent link">&para;</a></h4>
<ul>
<li>文件系统的写函数<code>generic_file_buffered_write()</code>要调用<code>balance_dirty_pages_ratelimited()</code></li>
<li>内核定时器触发</li>
<li>当系统申请内存失败，或者文件系统执行同步（sync）操作，或者内存管理模块试图释放更多内存的时候，都可能触发<strong>pdflush线程回写页面</strong>。</li>
</ul>
<h4 id="122">12.2、内核回写控制参数<a class="headerlink" href="#122" title="Permanent link">&para;</a></h4>
<h4 id="123">12.3、定时器触发回写<a class="headerlink" href="#123" title="Permanent link">&para;</a></h4>
<ul>
<li><code>start_kernel()</code>启动了一个定时器</li>
</ul>
<h5 id="1231">12.3.1、启动定时器<a class="headerlink" href="#1231" title="Permanent link">&para;</a></h5>
<ul>
<li>调用<code>page_writeback_init()</code>函数启动定时器</li>
</ul>
<h5 id="1232">12.3.2、执行回写操作<a class="headerlink" href="#1232" title="Permanent link">&para;</a></h5>
<ul>
<li><code>wb_kupdate()</code></li>
</ul>
<h5 id="1233">12.3.3、检查需要回写的页面<a class="headerlink" href="#1233" title="Permanent link">&para;</a></h5>
<ul>
<li><code>writeback_inodes()</code>扫描系统的超级块，检查需要回写的页面</li>
</ul>
<h5 id="1234inode">12.3.4、回写超级块内的inode<a class="headerlink" href="#1234inode" title="Permanent link">&para;</a></h5>
<ul>
<li><code>sync_sb_inodes()</code></li>
</ul>
<h5 id="12341">12.3.4.1、<a class="headerlink" href="#12341" title="Permanent link">&para;</a></h5>
<h5 id="12342">12.3.4.2、<a class="headerlink" href="#12342" title="Permanent link">&para;</a></h5>
<h5 id="12343">12.3.4.3、<a class="headerlink" href="#12343" title="Permanent link">&para;</a></h5>
<h5 id="12344">12.3.4.4、<a class="headerlink" href="#12344" title="Permanent link">&para;</a></h5>
<h4 id="124">12.4、平衡写<a class="headerlink" href="#124" title="Permanent link">&para;</a></h4>
<ul>
<li><code>balance_dirty_pages_ratelimited()</code>检查脏页面是否到达限值，是否进行平衡写操作</li>
</ul>
<ul>
<li><code>balance_dirty_pages()</code></li>
</ul>
<h5 id="1241">12.4.1、检查直接回写的条件<a class="headerlink" href="#1241" title="Permanent link">&para;</a></h5>
<ul>
<li><code>balance_dirty_pages_ratelimited_nr()</code></li>
</ul>
<h5 id="1242">12.4.2、回写系统脏页面的条件<a class="headerlink" href="#1242" title="Permanent link">&para;</a></h5>
<h5 id="1243">12.4.3、检查计算机模式<a class="headerlink" href="#1243" title="Permanent link">&para;</a></h5>
<h4 id="125">12.5、本章小结<a class="headerlink" href="#125" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Linux内核的回写机制提供了一种缓写机制，真实的写并不是直接写入硬盘，而是在page cache中缓存，等待合适的时机才真正执行写入</strong>。</li>
</ul>
<h3 id="chap13ext2-217229232">chap13、一个真实文件系统ext2   217（229/232）<a class="headerlink" href="#chap13ext2-217229232" title="Permanent link">&para;</a></h3>
<h4 id="131ext2">13.1、ext2的硬盘布局<a class="headerlink" href="#131ext2" title="Permanent link">&para;</a></h4>
<h4 id="132ext2">13.2、ext2文件系统目录树<a class="headerlink" href="#132ext2" title="Permanent link">&para;</a></h4>
<ul>
<li><code>struct ext2_dir_entry_2{};</code></li>
<li><strong>根目录是一个固定的inode，它的inode号是2</strong>。</li>
</ul>
<h4 id="133ext2">13.3、ext2文件内容管理<a class="headerlink" href="#133ext2" title="Permanent link">&para;</a></h4>
<ul>
<li>ext2的inode信息可以存放15个块的地址，用户数据就存在这些块中。</li>
<li>15块中前12块是直接数据块，<strong>第13块是一级索引块，第14块是二级索引块，第15块是三级索引块</strong></li>
</ul>
<h4 id="134ext2">13.4、ext2文件系统读写<a class="headerlink" href="#134ext2" title="Permanent link">&para;</a></h4>
<ul>
<li>通过文件系统的目录树，可以获得文件所在目录的上级目录。</li>
<li>读上级目录的内容，就可以获得文件的inode号和文件名称。</li>
<li>根据文件的inode号，可以获得文件的inode信息，也就获得了文件的类型、创建修改时间、文件大小等信息，完成打开文件的过程。</li>
</ul>
<h4 id="135">13.5、本章小结<a class="headerlink" href="#135" title="Permanent link">&para;</a></h4>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../10network/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71/" class="btn btn-neutral float-left" title="《TCPIP详解卷1》"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/" class="btn btn-neutral float-right" title="《文件系统技术内幕》">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../../10network/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
