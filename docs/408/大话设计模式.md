## 《大话设计模式》

+ 全书29章，想解决一下**自己写代码**

+ 3个分类，7个原则
  
  + [设计模式总结篇-创建型&结构型&行为型 区别、联系](https://blog.csdn.net/jason_jiahongfei/article/details/104937128)
  
+ 创建型（5），**创建对象的模式，抽象了实例化的过程**，关注的是对象的创建
  
  + 工厂方法、抽象工厂、单例、建造者、原型
  
+ 结构型（7），**解决怎么组装现有类**，设计它们的交互模式
  
  + 适配器、装饰器、代理、外观、桥接、组合、享元
  
+ 行为型（11），**算法和对象间的职责分配**，描述对象与类的模式，以及它们之间的通信模式
  
  + 策略、模板方法、观察者、迭代子、责任链、命令、备忘录、状态、访问者、中介者、解释器
  
+ 7个原则
  + chap3、单一职责原则
  + chap4、开放-封闭原则
  + chap5、依赖倒转原则
    + 里面有**里氏替换原则**
  + chap11、迪米特原则
  + 差了2个
    + 接口隔离
    + 合成复用（用组合和聚合，少用继承）
  
+ 基础知识

  + C++ 中聚合和组合的实现       https://blog.csdn.net/guanguanboy/article/details/84750139

    C++类的组合和聚合         https://www.cnblogs.com/qlzstudy/p/16496140.html

### chap0、附录

#### 0.2、类与实例

#### 0.3、构造方法（构造函数）

#### 0.4、方法重载

#### 0.5、属性与修饰符

#### 0.6、封装

0.7、继承

0.8、多态

0.9、重构

#### 0.10、抽象类

+ 抽象类注意：
  + 第一，抽象类不能实例化
  + 第二，抽象方法是必须被子类重写的方法
  + 第三，如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其他一般方法
+ **当设计一个新的抽象类时，一定是用来继承的**。

#### 0.11、接口

#### 0.12、集合

+ **用于数据存储和检索的专用类**，这些类提供对堆栈、队列、列表和哈希表的支持。大多数集合类实现相同的接口。
+ 装箱和拆箱

0.13、泛型

#### 0.14、委托与事件

+ **委托**：对函数的封装，可以当作给方法的特征指定一个名称
+ **事件**：委托的一种特殊形式，当发生有意义的事情时，事件对象处理通知过程。**事件其实就是设计模式中 观察者模式 在.NET中的一种实现方式**。

### chap1、简单工厂

#### 1.4、面向对象编程

+ 如果一开始用**计算机能够理解的逻辑**去描述和解决问题，*只能满足当前需求，不能复用、维护和扩展*

#### 1.8、业务的封装

+ 让业务逻辑与界面逻辑分开，让它们之间的耦合度下降

#### 1.10、简单工厂模式

+ **用一个单独的类来做这个创造实例的过程**，这就是工厂。

+ 到底要实例化谁，将来会不会增加实例化的对象
+ 简单运算工厂类
+ Operation运算类
  + GetResult()，virtual
+ AddOperation类，继承Operation运算类
  + GetResult()
+ MinusOperation类，继承Operation运算类
  + CetResult()
+ 其它运算类，继承继承Operation运算类
+ 简单工厂类
  + **创建方法**，new一个Operation运算类，根据不同的符号，找对应的子类
+ client
  + Operation运算类，一个实例

#### 1.11、UML类图

### chap2、策略（Strategy）

#### 2.1、商场收银软件

#### 2.2、增加打折

#### 2.3、简单工厂实现

#### 2.4、策略模式

+ Strategy，**定义了算法家族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户**。
+ 把不同算法封装起来，让它们之间可互相替换，让算法发生变化，不会影响到使用算法的客户。

#### 2.5、策略模式实现

#### 2.6、策略与简单工厂结合

#### 2.7、策略模式解析

+ 策略模式，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少各种算法类与使用算法类之间的耦合。

### chap3、单一职责原则

#### 3.4、单一职责原则

+ SRP，**就一个类而言，应该仅有一个引起它变化的原因**

### chap4、开放-封闭原则

#### 4.2、开放-封闭原则

+ **软件实体（类、模板、函数等等）应该可以扩展，但是不可修改**
  + 对于扩展是开放的（Open for extension）
  + 对于更改的封闭的（Closed for modification）

### chap5、依赖倒转原则

#### 5.3、依赖倒转原则

+ **高层模块不应该依赖低层模块。两个都应该依赖抽象**
+ **抽象不应该依赖细节，细节应该依赖于抽象**（针对接口编程，不要对实现编程）
+ *低层数据库可替换，不影响上层应用*

#### 5.4、里氏代换原则

+ LSP，**子类型必须能够替换掉它们的父类型**【在软件里面，把父类都替换成它的子类，程序的行为没有变化】


### chap6、装饰（Decorator）

#### 6.1、穿什么

#### 6.2、小菜扮靓第一版

+ Person类，里面提供各种穿的方法，穿裤子，穿T
+ client
  + 只能在现有的person方法里组合

#### 6.3、小菜扮靓第二版

+ Person类
  + 提供show的方法
+ 服饰抽象类Finery
  + 提供show()方法，抽象的
+ 各服饰子类，都继承服务抽象类Finery
+ client

#### 6.4、装饰模式（Decorator）

+ **Decorator**：动态地给一个对象添加一些额外的职责，就增加功能来说，**装饰模式比生成子类更为灵活**
+ Component类
+ ConcreteComponet类，继承Component类
+ Decorator类，继承Component类
+ ComponentDecoratorA类，继承Decorator类
+ ComponentDecoratorB类，继承Decorator类

#### 6.5、小菜扮靓第三版

+ 服饰类Decorator，继承自 人类Person

#### 6.6、装饰模式总结

+ 优点：
  + 把类中的装饰功能从类中搬移去除，这样可以简化原有的类，**把类的核心职责和装饰功能区分开**

### chap7、代理（Proxy）

#### 7.1、为别人做嫁衣！

#### 7.2、没有代理的代码

+ 追求者类
+ 被追求者类
+ Client

#### 7.3、只有代理的代码

+ 代理类
+ 被追求者类
+ Client

#### 7.4、符合实际的代码

+ *没怎么看呢，lionel*

#### 7.5、代理模式（Proxy）

+ **Proxy**：为其他对象提供一种代理以控制对这个对象的访问
+ Subject类，
  + 定义公共接口
+ RealSubject类，继承Subject类，**定义Proxy所代表的真实实体**
+ Proxy类，继承Subject类
  + new RealSubject，然后调用与Subject一样接口，当然也要负责实现
  + 保存一个引用使得代理可以访问实体，并提供一个与Subject的接口相同的接口
+ Client
  + new Proxy

#### 7.6、代理模式的应用

+ 远程代理
+ 虚拟代理
+ 安全代理

#### 7.7、秀才让小六代其求婚

### chap8、工厂方法（Factory Method）

#### 8.1、活雷锋

#### 8.2、简单工厂模式实现

#### 8.3、工厂方法模式实现

#### 8.4、简单工厂vs.工厂方法（Factory Method）

+ **Factory Method**：定义一个用于创建对象的接口，让子类决定实例化哪一个类。**工厂方法使一个类的实例化延迟到其子类**
+ 工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行

#### 8.5、雷锋工厂

### chap9、原型

#### 9.1、夸张的简历

+ 简历类，设置性别和年龄，设置工作经历，需要写3份

#### 9.2、简历代码初步实现

+ 3份简历，需要3次实例化

#### 9.3、原型模式（Prototype）

+ **用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象**。（从一个对象再创建另一个可定制的对象，而且不需知道任何创建的细节）
+ 原型类（接口，*clone()是个纯虚函数？*）
+ 具体原型类
+ 客户端代码（调用 原型类）
+ Prototype：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
+ "原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。"
+ *直接调用clone()即可？*

#### 9.4、简历的原型实现

+ *为啥要调用clone()，直接赋值不行吗？*  【**主要是为了省构造函数的时间**-lionel，目前是猜的】

#### 9.5、浅复制与深复制

#### 9.6、简历的深复制实现

#### 9.7、复制简历 vs. 手写求职信

### chap10、模板方法（TemplateMethod）

#### 10.1、选择题不会做，蒙呗！

+ 考试题目抄错了，就算会错，最后也白搭

#### 10.2、重复=易错+难改

+ A和B都抄了题目

#### 10.3、提炼代码

+ 老师出试卷，学生填答案
+ *没太理解，lionel*

#### 10.4、模板方法模式（TemplateMethod）

+ **定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤**。

#### 10.5、模板方法模式特点

+ 提取类库中的公共行为到抽象类中

#### 10.6、主观题，看你怎么蒙

### chap11、迪米特原则

11.1、第一天上班

11.2、无熟人难办事

#### 11.3、迪米特法则

+ LoD：**如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用**

### chap12、外观（Facade）

12.1、牛市股票还会亏钱？

12.2、股民炒股代码

#### 12.3、投资基金代码

+ 这就是一个Facade模式，*相当于通过基金公司去买，去卖，至于卖具体的股票A，股票B，还是货基，债基，不管*

#### 12.4、外观模式

+ **Facade**，为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
+ 它完美的体现了，依赖倒转原则和迪米特法则的思想。
+ 四个子系统类（SubSystemOne类、SubSystemTwo类、SubSystemThree类、SubSystemFour类）
+ Facade外观类
  + new 4个子系统类
  + 实现其MethodA()，MethodB()这样的方法
+ client
  + 直接调用Facade对象
+ 思考：（*facade外观类 与 四个子系统类  是啥有关系呢，lionel*）

12.5、何时使用外观模式

### chap13、建造者

13.1、炒面没放盐

13.2、建造小人一

13.3、建造小人二

#### 13.4、建造者模式

+ Builder：**将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示**

13.5、建造者模式解析

13.6、建造者模式基本代码

### chap14、观察者

14.1、老板回来？我不知道！

14.2、双向耦合的代码

#### 14.5、观察者模式（发布/订阅模式）

+ Publish/Subscribe：定义了一种**一对多的依赖关系，让多个观察者对象同时监听某一个主题对象**。这样主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己

### chap15、抽象工厂

#### 15.5、抽象工厂模式

+ Abstract Factory：**提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类**

### chap16、状态

#### 16.5、状态模式

+ State：**当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类**

### chap17、适配器（Adapter）

#### 17.1、在NBA我需要翻译

#### 17.2、适配器模式

+ **Adapter**：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
+ 适配器模式分两种类型
  + 类适配器模式
  + 对象适配器模式
+ Target类
+ Adaptee（需要适配的类）
+ Adapter（内部包装一个Adaptee对象，**把源接口转换成目标接口**）
  + 继承自Target类
+ Client

#### 17.3、何时使用适配器模式

#### 17.4、篮球翻译适配器

#### 17.5、适合器模式的.NET应用

+ 对不同数据库的**DataAdapter**

#### 17.6、扁鹊的医术

### chap20、迭代器（Iterator）

#### 20.1、乘车买票，不管你是谁！

+ 只计算人头个数，不管具体的人是谁，还是行李，都要算钱

#### 20.2、迭代器模式

+ **Iterator**：提供一种方法顺序访问一个聚合对象中各个元素，而不暴露该对象的内部表示。

#### 20.3、迭代器实现

+ Iterator类：
  + First()
  + Next()，下一个
  + IsDone()，是否结束
+ ConcreteIterator
  + 继承Iteraotr并实现它
+ Aggregate类
  + 创建迭代器，`Iterator CreateIterator()`
+ ConcreteAggreagate类
  + 存放聚合对象
  + 重载`CreateIterator()`
  + *要不要提供啥方法？*
+ Client
  + 创建公交车，即聚集对象
  + 公交车上乘客，即对象数组
  + 创建迭代器对象，即售票员看上车的是哪些人
  + 迭代器操作，`First()，Next()，isDone()`，
    + 从第一个开始，只要没有结束，就不断Next
+ **当你需要对聚集有多种方式遍历时，可以考虑用迭代器模式**
  + 比如按重量遍历

#### 20.4、.NET的迭代器实现

+ foreach in，*我想到的是STL里的迭代器*

#### 20.5、迭代高手

### chap24、职责链（Chain of Responsibility）

#### 24.1、老板，我要加薪！

+ 向经理申请，经理没权利，向总监汇报，也没有权限，向总经理上报。

#### 24.2、加薪代码初步

+ 申请类
  + 申请类别
  + 申请内容
  + 数量
+ 管理类
  + 得到结果，`GetResult()`，一个函数里面判断当前的经理能不能批
+ Client

#### 24.3、职责链模式

+ *这个图，其实没太看，lionel*

+ **Chain of Responsibility**：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
+ Handler类
  + 定义一个处理请示的接口，`HandleRequest()`
+ ConcreteHandler1类
  + 请求数在1-10之间的有权处理
+ ConcreteHandler2类
  + 请求数在11-20之间的有权处理
+ ConcreteHandler3类
  + 请求数在21-30之间的有权处理
+ Client

#### 24.4、职责链的好处

+ 职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用

#### 24.5、加薪代码重构

+ 管理者类，Manager
+ 经理类CommonManager，继承Manger
+ 总监类MajorManager，继承Manger
+ 总经理类GeneralManager，继承Manger
+ Client

#### 24.6、加薪成功

### 构建者

### 学习过程

+ 0531，看了2章，建造者模式builder（13）、观察者模式observer（14）
+ 0601，看了3章，抽象工厂模式（15），状态模式（16），适配器模式（17），*抽象工厂模式，没太看懂*
+ 0710，看了3章，适配器（17，*之前看过了*），迭代器（20），职责链（24）
+ 202303月，大概看一下，全书的前15章左右，*感觉还是忘光了*