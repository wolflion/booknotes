## 《新编数据结构习题与解析》

+ 一些难点（遗留问题）：
  + chap3栈
    + **栈的一些要素**，顺序和链的形式，比如**栈空、栈满、入栈、出栈**
    + 3.2的（表达式求值、走迷宫）
    + 3.4的递归，是不是要单出一个*算法*里，暂时还不确定

+ 一些计划：
  + chap11内排序（计划0821-0826完成的）
  + chap9图（计划0827-0902完成）

### chap3、栈和递归

#### 3.1、栈的基本概念

##### 3.1.1、知识点

+ 栈的定义
+ 栈的特点，**后进先出**
+ 栈的基本运算
  + Init
  + Empty
  + Push
  + Pop
  + Top
+ 栈的存储结构，**顺序、链**

#### 3.2、顺序栈的算法

##### 3.2.1、知识点

+ 定义
  + 分配一段连续的存储空间（*可以是静态分配，也可以是动态*），再用一个变量去指向当前的栈顶

```cpp
typedef struct {
    int data[MaxSize];//lionel，如果是动态的话，这里就是int *data;然后这个数据是用new出来的
    int top;
}SeqStack;
```



+ **要素**
  + 栈空的条件
  + 栈满的条件，**top超过空间的大小**
  + 入栈，**先top++，再放元素**
  + 出栈
+ 基本运算
  + *这个是不是要参考一下书上的代码，lionel*
+ 3、共享栈
  + *lionel，都没怎么见别的书上提过*
+ 4、求算术表达式的值
  + 题目，求"(56-20)/(4+2)"，*lionel，这2步，我都不会，把第一步搞定后，用stl中stack看看能不能解决一下*
    + 1、先把算术表达式换成**后缀表达式**
    + 2、对后缀表达式求值
+ 5、求解迷宫问题
  + 题目，*lionel，其实，我也不太会，用 栈 我能理解，因为要 往回走（回溯），但如何封装结构体呢？*
    + *主要还是自己不知道，怎么组织代码，当然，还不清楚 那个图 到底怎么走*

#### 3.3、链栈的算法

##### 3.3.1、知识点

+ 定义
  + 用链式结构来**存储栈**，单链表时，**这样就不存在栈满的情况**，表头结点是top。*那就是头插法，后进先出*
  + *lionel，本质上还是 画图后，然后用代码去实现它* 【至少有2部分组成，**数据区**（用什么类型）、**指针**（用什么类型）】

```cpp
typedef struct linknode{
    int data;//lionel，首先要有一个数据
    struct linknode *next; //lionel，然后指向下一个
}LinkList;//lionel，如果双链的话，再组织
```



+ **要素**
  + 栈空
  + 栈满
  + 入栈
  + 出栈
+ 2、基本运算
+ 其它
  + 带头结点和不带头结点的区别

#### 3.4、递归

##### 3.5.1、知识点

+ 1、定义
+ 2、模型
+ 3、递归算法的设计
  + 简单递归
  + 复杂递归
+ 4、递归算法到非递归算法的转换
  + 用循环消除尾递归和单向递归
  + 用栈消除递归

##### 3.5.2、习题

###### 一、单选

###### 二、填空

###### 三、算法

+ 8、递归算法，求一个数组A中的最大元素
+ 14、递归算法，求n个不同字符的所有全排列，*比如123的全排列*
+ 15、递归算法，求组合问题，从自然数1，2，...，m中任取k个数的所有组合

### chap9、图

#### 9.1、图的基本概念

##### 9.1.1、知识点

+ 1、图的基本术语

+ 2、图的存储结构

  + （1）邻接矩阵
    + 先定义**顶点**，【图里，一般都要存啥？】，*我一直以为只是个普通的二维数组呢？*

  ```cpp
  #define MAXV <最大顶点个数>
  typedef char ElemType;
  typedef struct {
      int no;  //顶点编号
      ElemType info;
  }VertexType;
  
  typedef struct {
      int edges[MAXV][MAXV];
      int n,e;             //顶点数和边数
      VertexType vexs[MAXV]; //存放顶点信息
  }MGraph;
  ```

  

  + （2）邻接表

```cpp
typedef char ElemType;
typedef int InfoType;
typedef struct ANode{
    int adjvex;
    struct ANode *nextarc;
    InfoType info;
}ArcNode; //边的节点类型

typedef struct Vnode{ //表头
    ElemType data;
    ArcNode *firstarc;
}VNode;

typdef VNode AdjList[MAXV];  //AdjList是邻接表类型

typedef struct {
    AdjList adjlist; //邻接表
    int n,e;
}AGraph;
```



+ 3、图的基本运算及实现算法

#### 9.2、图的遍历

##### 9.2.1、

+ 深度优先
+ 广度优先

#### 9.3、最小生成树

##### 9.3.1、

+ **生成树**，连接n个顶点的n-1条边且无回路的子图
+ **最小生成树**，树权最小
+ Prim算法
+ Kruskal算法

#### 9.4、最短路径

##### 9.4.1、知识点

+ 1、从一个顶点到其余各顶点的最短路径（Dijkstra）
  + 01、初始时，顶点集S只包含源点，S={v}，顶点v到自己的距离为0，到其它点的距离要么是权值，要么是无穷大，*lionel，这一步没问题*
  + 02、从U中选一个顶点u，**是源点v到U中距离最小的一个顶点**，然后把顶点u加入S，（**这个距离就是v到u的距离**），*这一步的核心是找最小的，lionel*
  + 03、以顶点u为新考虑的中间点，修改v到U中各顶点j的距离，（可能经过u，会比不经过u的距离更短），*这一步是计算，然后比较一下，lionel*
  + 04、重复02和03
  + *lionel，算法过程，我大概是懂了，问题在于，我最后的`path[]`怎么算，我不太会*
+ 2、每对顶点之间的最短路径（Floyd）

#### 9.5、AOV网和拓扑排序

+ AOV（Activity On Vertex）**用顶点表示活动的网络**，活动u的完成是活动v可以开始的条件，则顶点u和v之间有一条边<u,v>
+ 拓扑排序过程
  + 1、从有向图中选择一个没有前驱（即入度为0）的顶点并输出它
  + 2、从网中删除该顶点，并且删去从该顶点出发的全部有向边
  + 3、重复上述两步，直到剩余的网中不再存在没有前驱的顶点为止
+ 邻接表的表头结点要**增加一个入度**

```cpp
typedef struct Vnode{ //表头
    ElemType data;
    int count;//存放顶点的入度，专为拓扑排序设置
    ArcNode *firstarc;
}VNode;
```



#### 9.6、AOE网与关键路径

##### 9.6.1、知识点

+ AOE（Activity On Edge）**用边表示活动的网络**，带权有向图（以顶点表示事件，有向边表示活动，边上的权值表示完成该活动的开销）
+ 这里的**关键路径**是最大路径长度的路径
+ *难点在于，也要写代码来分析一下，lionel，如果熟悉了数据结构和业务，其实可能也还好*

### chap11、内排序

#### 11.1、插入（直接插入、希尔）

```cpp
typedef struct {
    int key;//关键字
    int data;//其它数据
}SqList;
```



##### 11.1.1、知识点

+ 直接插入
  + 思路：**前面是有序的**

```cpp
void InsertSort(SqList R[], int len){
    SqList tmp;
    for(int i=1;i<n;i++){
        tmp = R[i];
        int j=i-1; //因为i前面是有序的，j指向有序区的最后一个元素
        while(j>=0 && R[j].key > tmp.key){   //lionel，里面的for循环，就是为了在 有序区，找插入位置
            R[j+1] = R[j];  //不断往后移
            j--;//不断减减，找到合适的插入位置
        }
        R[j+1] = tmp;//找到j后，再j+1，把tmp插入进去
    }
}
```



+ 折半插入
  + 想法是，**在前面的有序区间中，用折半查找的方法**，找到j的位置
+ 希尔
  + 又叫缩小增量，可以用2个函数，也可以在原来的 直接插入 外面套一个while循环
  + **与待排序数据的顺序有关**，正序时效率最高，反序时效率最低

```cpp
void ShellSort(SqList R[], int n) {  //n就是len
    SqList tmp;
    int d = n/2;
    while(d>0){ //lionel，相当于套了一层，一直循环到d=1为止
        for(int i=d;i<n;i++){  //对所有相隔d位置的元素组进行排序
            tmp = R[i];
            int j=i-d;  //lionel，所有的原先是1的地方，变成了增量d
            while(j>=0 && R[j].key>tmp.key){
                R[j+d] = R[j];
                j-=d;
            }
            R[j+d] = tmp;
        }
        d=d/2;
    }
}
```



##### 11.1.2、习题

###### 一、单选

+ 1、直接插入排序最好情况下时间复杂度是`O(n)`，*正序，里层的while循环不需要插入*
+ 2、对n个记录的表进行直接插入排序，在最坏情况下需比较`n(n-1)/2`
  + 我用的是排除法，肯定是O(n方)，只能选D
  + 真实的情况：第2次需要1次比较，第3次需要2次比较，....第n次需要n-1次比较
+ 3、稳定的排序算法是**直接插入排序**
  + 这个肯定是稳定的，*其它的选项不确定*
+ 4、{8,9,10,4,5,6,20,1,2}只能是**直接插入排序**算法的两趟排序后的结果
  + 两趟排序后的有序区，不是**全局有序**
+ 5、
+ 6、
+ 7、在初始序列已基本有序的情况下，排序效率最高的是**直接插入排序**
  + 我本来想的是**希尔排序**，但选项没有，*两个答案都是正确的*，如果是多选的话
+ 8、不稳定的排序算法是**希尔排序**（*其它选项，不确定*）
+ 10、

###### 二、填空

+ 11、
+ 12、
+ 13
+ 14、{Q,H,C,Y,Q,A,M,S,R,D,F,X}，关键字递增，初始步长为4，则第一趟的结果**,**。
  + *lionel，疑问点在于，布长，怎么计*【第1个就是1，然后数4个？】
+ 15、

###### 三、简答

+ 16、直接插入排序与希尔排序算法的不同
  + 直接插入排序，是**稳定的**，采用顺序查找时，也适用于链式存储
  + 希尔排序，是**不稳定的**，不适用于链式存储
+ 17、希尔排序每一趟都要调用若干次直接插入排序，为什么希尔排序还比直接插入排序算法效率更高。
  + **按近正序时**效率很高？*lionel，我感觉答案没写对啊？*
+ 18、
+ 19、
+ 20、写出{4,5,1,2,8,6,7,3,10,9}的直接插入排序过程
+ 21、写出{4,5,1,2,8,6,7,3,10,9}的希尔排序过程

###### 四、算法

+ 22、创建一个带头节点的单链表，设计一个直接插入排序对这个单链表进行递增排序
+ 23、
+ 24、

#### 11.2、选择（简单选择、堆-优先队列）

##### 11.2.1、知识点

+ 简单选择
  + **有序区的均小于无序区的**，每次从无序区找一个第小的与R[i]交换，这样R[0...i]都有序了

```cpp
void SelectSort(SqList R[], int n){ //n就是len
    SqList tmp;
    int k;  //用k指出最小的，为啥不直接用min？lionel
    for(int i=0;i<n;i++){
        k=i;//lionel，哨兵？
        for(int j=i+1;j<n;j++){ //两层for循环，从无序区找最小的
            if( R[k].key > R[j].key)
                k=j;//用k指出每趟在无序区的最小元素
            
            if(i!=k){  //R[k]与R[i]交换，lionel，为啥这个时候交换？【因为i会不断加加，相当于前面的都是排序的】
                tmp = R[i];
                R[i] = R[k];
                R[k] = tmp;
            }
        }
    }
}
```



+ 堆排序（优先队列）
  + 筛选算法？【】搜了一下，感觉是**下沉**，*目前，能知道怎么构造，但例子怎么结合代码，还不太会，主要分不清楚，从0开始还是从1开始？*

```cpp
void Sift(SqList R[], int low, int high){  //把R[low...high]调整成堆
    int i=low,j=2*i;  //R[j]是R[i]的左孩子
    SqList tmp = R[i];
    
    while(j<=high){
        if(j<high && R[j].key < R[j+1].key)  //右孩子大，j指向右孩子
            j++;
        if(tmp.key<R[j].key){//双亲的根节点小于 孩子，需调整
            R[i] = R[j];  //R[j]调整到双亲结点上
            i=j;
            j=2*i;   //修改i和j，以便继续向下筛选  【lionel，就不太明白了】
        }else
            break;   //筛选结束
    }
    R[j]=tmp;  //被筛选节点的值，放入最终位置  【lionel，不太明白】
}


//建立堆
void HeapSort(SqList R[], int n){
    SqList tmp;
    int i;
    for(i=n/2;i>=1;i--)
        Sift(R,i,n);
    
    for(i =n;i>=2;i--){ //n-1次循环
        tmp = R[1];//每一个元素同当前区间内的R[1]对换
        R[1] = R[i];
        R[i] = tmp;
        Sift(R,1,i-1);  //lionel，其实还是不太懂
    }
}
```

##### 11.2.2、习题

###### 一、单选

+ 4、采用简单选择排序，关键字比较次数（**`O(n平方)`**），元素移动次数是（**O(n)**），*这个我不太熟悉呢，lionel*
+ 9、一组{15,9,7,8,20,-1,7,4}，用堆排序的筛选方法建立的初始堆是：`-1,4,7,8,20,15,7,9`，*这个我没做出来的
  + 我的答案是`20,15,7,8,9,-1,7,4`
+ 12、一组{84,47,25,15,21}进行排序，排序过程中变化如下：，采用的排序算法是**堆排序**，*自己按自己的想法没做出来*
  + （1）84，47，25，15，21
  + （2）21，47，25，15，84
  + （3）15，21，25，47，84
  + （4）15，21，25，47，84

###### 二、填空

###### 三、简答

###### 四、算法

#### 11.3、交换（冒泡、快速）

##### 11.3.1、知识点

+ 冒泡

```cpp
void BubbleSort(SqList R[], int n){
    int i,j,exchange;
    SqList tmp;
    for(i=0;i<n-1;i++){
        exchange=0;
        for(j=n-1;j>i;j--){ //lionel，是不是从最后往前，还是前往后，应该无所谓吧
            if(R[j].key<R[j-1].key){  //lionel，这才是核心，逐个比较
                tmp=R[j];
                R[j]=R[j-1];
                R[j-1]=tmp;
                exchang=1; //优化版本，如何不需要交换，就省了一轮
            }
        }
        if(exchange==0)  //本趟未发生交换时结束算法
            return ;
    }
}
```



+ 快速
  + 单次的分界**Partation**的实现方式有2种，见《趣学算法》

```cpp
void QuickSort(SqList R[], int s, int t){ //对R[s...t]的元素进行快速排序
    int i=s,j=t;
    SqList tmp;
    if(s<t){
        tmp=R[s];
        while(i!=j){
            while(j>i && R[j].key > tmp.key)
                j--;
            R[i]=R[j];
            while(j>i && R[i].key < tmp.key)
                i++;
            R[j]=R[i];
        }
        R[i] = tmp;
        QuickSort(R,s,i-1);
        QuickSort(R,i+1,t);
    }
}
```



##### 11.3.2、习题

###### 一、单选

###### 二、填空

###### 三、简答

+ 18、对序列{15,5,16,2,25,8,20,9,18,12}，给出采用快速排序法对该序列作升序排序的每一趟结果
  + 方法1【选中15为基准值pivlot】
    + 从右边开始，12小于15，与15交换，变成12,5,16,2,25,8,20,9,18,15
    + 换到左边开始，5是小于15的，继续下一个，16大于15了，就要与15交换（right指针没变），变成12,5,15,2,25,8,20,9,18,16
    + 换到右边开始，18大于15，9小于15，交换，12,5,9,2,25,8,20,15,18,16
    + 换到左边开始，left指向的是9，2也是小于15的，25大于15，再交换，12,5,9,2,15,8,20,25,18,16
    + 换到右边开始，right指向的是25，20是大于15的，8小于15，再交换，12,5,9,2,8,15,25,18,16
    + 换到左边开始，left指向的是8，8小于15，到下一个，发现left==right
  + 方法2【选中15为基准值pivlot】，**两边同时前进，遇到不符合的，就交换**
+ 22、

###### 四、算法

+ 23、设计一个**双向冒泡排序**，即在排序过程中交替改变扫描方向

#### 11.4、归并

+ 《算法4》对归并有几种场景，自底向上，自顶向下

##### 11.4.1、知识点

+ 手工模拟场景

+ 自底向上的情况

```cpp
void MergeSort(SqList R[], int n){
    int length;
    for(length=1;length<n;length=2*length)  //2个成一组
        MergePass(R,length,n);
}

//lionel，这个还没细看
void MergePass(SqList R[], int length, int n){
    int i;
    for(i=0;i+2*length-1<n;i=i+2*length) //lionel，没懂
        Merge(R,i,i+length-1,i+2*length-1);
    if(i+length-1<n)  //余下2个子表
        Merge(R,i,i+length-1,n-1); //归并2个子表
}

void Merge(SqList R[], int low, int mid, int high){
    
}
```



##### 11.4.2、习题

###### 一、单选

###### 二、填空

###### 三、简答

###### 四、算法

#### 11.5、基数

##### 11.5.1、知识点

##### 11.5.2、习题

###### 一、单选

###### 二、填空

###### 三、简答

###### 四、算法









##### 11.2.2、习题

###### 一、单选

###### 二、填空

###### 三、简答

###### 四、算法