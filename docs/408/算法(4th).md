## 《算法4th》

+ 书上的chap1基础是java，我尽量想用C++给整一下

### chap1、基础

#### 1.1、基础编程模型

##### 1.1.3、语句

+ 声明语句
+ 赋值语句
+ 条件语句
+ 循环语句
  + break，**从循环中退出**
  + continue，**下一轮循环**
+ 调用的返回语句

##### 1.1.4、数组

##### 1.1.8、字符串

##### 1.1.9、输入输出

##### 1.1.10、二分查找

+ 用C++实现、用例、性能

##### 答疑&练习&提高题

#### 1.2、数据抽象

+ ADT，用`class`或`struct`关键字，**向用例隐藏内部表示的数据类型**

##### 1.2.1、使用抽象数据类型

##### 1.2.2、抽象数据类型举例

##### 1.2.3、抽象数据类型的实现

+ 构造函数

##### 1.2.4、更多抽象数据类型的实现

##### 1.2.5、数据类型的设计

###### 1.2.5.1、封装

###### 1.2.5.5、接口继承与实现继承

+ [C++中区别接口继承与实现继承](https://blog.csdn.net/YinShiJiaW/article/details/99940566)
  + **C++不太区分**，整体是一套
  + 不继承实现，只继承方法接口，就用**纯虚函数**
  + 继承方法接口，以及默认实现，**虚函数**
  + 继承方法接口，以及默认实现，**普通函数**

##### 答疑&练习&提高题

#### 1.3、背包、队列和栈

##### 1.3.1、API

###### 1.3.1.4、Bag

+ **不支持从中删除元素的集合数据类型**

##### 13.2、集合类数据类型的实现

##### 13.3、链表

##### 13.4、综述

+ 以介绍的数据结构为基石
+ 展示数据结构和算法的关系
+ 若干算法的实现重点

##### 答疑&练习&提高题

#### 1.4、算法分析

1.4.1、科学方法

1.4.2、观察

1.4.3、数学模型

1.4.4、增长数量级的分类

1.4.5、

1.4.6、

1.4.7、注意事项

##### 1.4.8、处理对于输入的依赖

1.4.9、内存

##### 答疑&练习&提高题

#### 1.5、案例研究：union-find算法

##### 1.5.1、动态连通性

1.5.2、

##### 1.5.3、展望

##### 答疑&练习&提高题

### chap2、排序  152（163/647）

#### 2.1、初级排序

##### 2.1.1、游戏规则

##### 2.1.2、选择排序

+ **重复的从待排元素中选出最大者或 最小者**
  + 我之前一般都是*存元素*，这里存的是下标

```cpp
void SelectSort(vector<int> nums){
    int len = nums.size();
    for(int i=0;i<len;i++){
        //将a[i]与a[i+1...len]中最小元素交换
        int min = i;//最小元素的索引
        for(int j=i+1;j<len;j++){
            if(less(a[j],a[min]))//这个less的写法，自己要会,lionel
                min=j;
        }
        exch(a,i,min);
    }
}
```



##### 2.1.3、插入排序

+ **为了腾空间，其它元素在插入之前都向右移动一位**

```cpp
void InsertSort(vector<int> nums){
    //按升序排列
    int lne = nums.size();
    for(int i=0;i<len;i++){
        //nums[i]插入到a[i-1],a[i-2],a[i-3]...之中
        for(int j=i;j>0&&less(a[j],a[j-1]);j--)
            exch(a,j,j-1);//lionel,我没看到哪个是往右移的，这也是种交换啊，难道是逐个交换？
    }
}
```



+ **部分有序**的场景

##### 2.1.4、插入排序的可视化

##### 2.1.5、比较两种排序算法

+ 用`time()`函数

##### 2.1.6、希尔排序

+ **基于插入排序的快速排序**
+ 使数组中任意间隔为h的元素都是有序的，**插入排序中移动元素的距离由1改为h即可**
+ 问题：**如何选择递增子序列？**

##### 答疑&练习&提高题

+ 2.1.19、希尔排序的最坏情况
+ 2.1.20、希尔排序的最好情况

#### 2.2、归并排序

+ **两个有序的数组归并成一个更大的数组**，NlogN，需要额外的空间
+ **先递归的分成两半分别排序，然后将结果归并起来**

##### 2.2.1、原地归并的抽象方法

+ 创建一个数组，将原数组从小到大放入。

##### 2.2.2、自顶向下的归并排序

+ *没理解*

##### 2.2.3、自底向上的归并排序

+ *没理解*

##### 2.2.4、排序算法的复杂度

#### 2.3、快速排序

+ Nlog2N（2为底）

##### 2.3.1、基本算法

+ **是一种分治排序算法**，2个子数组有序那么整个数组自然就有序了

###### 2.3.1.1、原地切分

###### 2.3.1.2、别越界

###### 2.3.1.3、保持随机性

###### 2.3.1.4、终止递归

##### 2.3.2、性能特点

##### 2.3.3、算法改进

#### 2.4、优先队列

##### 2.4.1、API

##### 2.4.2、初级实现

##### 2.4.3、堆的定义

+ 当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为**堆有序**

##### 2.4.4、堆的算法

###### 2.4.4.1、由下至上的堆有序变化（上浮）

###### 2.4.4.2、由上至下的堆有序变化（下沉）

###### 2.4.4.3、多叉堆

##### 2.4.5、堆排序

###### 2.4.5.1、堆的构造

#### 2.5、应用

##### 2.5.1、将各种数据排序

##### 2.5.2、我应该使用哪种排序算法

##### 2.5.3、问题的归纳

##### 2.5.4、排序应用一览

### chap3、查找  227（238/647）

#### 3.1、符号表

3.2、二叉查表树

3.3、平衡查找树

3.4、散列表

3.5、应用

### chap4、图 329（/647）

#### 4.1、无向图

#### 4.2、有向图

#### 4.3、最小生成树

#### 4.4、最短路径

### chap5、字符串  451（/647）