## Linux命令行与shell脚本编程大全

+ Part2: shell脚本编程基础（11-16）
  + chap15呈现数据
  + chap16控制脚本（`trap, &, jobs, nice, at, cron`）
+ Part3:高级shell脚本编程（17-23）

### chap11、构建基本脚本

#### 11.1、使用多个命令

+ 用`;`分隔
+ 最大命令行字符数不能超过255

#### 11.2、创建shell脚本文件

+ shell的第一行要指定使用的shell。`#!/bin/bash`  **虽然#是注释符，但第一行是例外**
+ 要找到自己写的shell脚本
  + 将shell脚本的目录添加到PATH环境变量中
  + 在提示符中用绝对或相对路径执行
+ shell脚本的执行权限
  + umask的值

#### 11.3、显示消息

+ `echo`中的单引号或双引号的问题

#### 11.4、使用变量

##### 11.4.1、环境变量

+ `set`命令
+ 环境变量前面加美元符号`$`
  + `echo "The cost of the item is \$15"`会认为是要输入$，没有`\`，会被认为是`$1`+5这样的，可以通过`${15}`的方式来表达

##### 11.4.2、用户变量

+ **区分大小写，不能出现空格**
+ 引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符

##### 11.4.3、命令替换

+ 将命令输出给变量
  + 反引号字符  `
  + `$()`格式

#### 11.5、重定向输入和输出

+ 输出重定向
+ 输入重定向

#### 11.6、管道

##### 11.6.1、expr命令

#### 11.7、执行数学运算

+ expr命令
  + `expr 1+5`，`expr 5 \*2 `（*要用反斜杠）
+ 使用方括号`$[]`
  + `var1=$[1+5]`
+ 浮点解决方案
  + `bc`的基本用法 

#### 11.8、退出脚本

+ 查出退出状态码
+ exit命令

#### 11.9、小结

### chap12、使用结构化命令

#### 12.1、使用if-then语句

```shell
#!/bin/bash
#testing the if statement
if pwd
then
	echo "It worked"
#else
	#echo "else"
fi
```



#### 12.2、if-then-else语句

##### 12.3、嵌套if

+ `elif`组合

#### 12.4、test命令

+ 判断三类条件

##### 12.4.1、数组比较

##### 12.4.2、字符串比较

##### 12.4.3、文件比较

#### 12.5、复合条件测试

#### 12.6、if-then的高级特征

##### 12.6.1、使用双括号

##### 12.6.2、使用双方括号

#### 12.7、case命令

#### 12.8、小结

### chap13、更多的结构化命令

#### 13.1、for命令

#### 13.2、C语言风格的for命令

13.3、while命令

13.4、until命令

13.5、嵌套循环

13.6、循环处理文件数据

13.7、控制循环

13.8、处理循环的输出

13.9、实例

13.10、小结

### chap14、处理用户输入

#### 14.2、特殊参数变量

##### 14.2.1、参数统计

### chap15、呈现数据

#### 15.7、创建临时文件

#### 15.8、记录消息

### chap16、控制脚本

+ 也就是运行，除了**实时模式**，还有其它方式
  + 向脚本发送信号
  + 修改脚本的优先级
  + 在脚本运行时切换到运行模式

#### 16.1、处理信号

##### 16.1.1、重温Linux信号

+ shell会**忽视SIGQUIT，SIGTERM**，**处理SIGHUP，SIGINT**

##### 16.1.2、生成信号

+ 中断进程
  + ctrl+c，会生成SIGINT信号，停止shell中当前运行的进程
+ 暂停进程
  + ctrl+z，会生成SIGTSTP信号，停止shell中当前运行的进程
+ **停止（stopping）与终止（terminating）不同**
  + 停止，会让程序继续保留在内存中，并能从上次停止的位置继续运行
+ `ps -l`中 S列的值，如果是**T**，说明命令要么被跟踪，要么被停止了

##### 16.1.3、捕获信号

+ `trap`
  + `trap "echo 'Sorry! I have trapped Ctrl-C'"  SIGINT`，**用一组空格分开的待捕获的信号**

##### 16.1.4、捕获脚本退出

+ 在trap后面加上`EXIT`信号

##### 16.1.5、修改或移除捕获

#### 16.2、以后台模式运行脚本

+ 在后台模式中，进程运行时不会和终端会话上的STDIN，STDOUT以及STDERR关联

##### 16.2.1、后台运行脚本（&）

##### 16.2.2、运行多个后台脚本

+ 只能逐个运行
+ **ps的输出中，每一个后台进程都和终端会话（pts/0）终端联系在一起。如果终端会话退出，那么后台进程也会随之退出**

#### 16.3、在非控制台下运行脚本

+ **nohup命令运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号**
+ `nohup ./test1.sh &`

#### 16.4、作业控制

+ 启动、停止、终止以及恢复作业这些功能统称为**作业控制**

##### 16.4.1、查看作业

+ jobs命令

##### 16.4.2、重启停止的作业

+ `bg 作业号`，如果只有1个作业，**直接`bg`命令即可**

#### 16.5、调整谦让度

+ 从-20（最高优先级）到+19（最低优先级）

##### 16.5.1、nice命令

+ `nice -n 10`，**只能降低，不能提高**

##### 16.5.2、renice命令

+ renice命令的限制

#### 16.6、定时运行作业

##### 16.6.1、用at命令来计划执行作业

##### 16.6.2、安排需要定期执行的脚本

+ cron时间表
+ 构建cron时间表
+ 浏览cron目录
  + `ls /etc/cron.*ly`

##### 16.6.3、使用新shell启动脚本

#### 16.7、小结

### chap17、创建函数

#### 17.1、基本的脚本函数

+ 17.1.1、创建函数，2种形式

```shell
function name {commands} #关键字function
name() {commands} #关键的()
```



+ 17.1.2、使用函数

#### 17.2、返回值

+ 17.2.1、默认退出状态码
  + **函数中最后一条命令返回的退出状态码，可以用`$?`来确定**
+ 17.2.2、使用return命令
  + **退出状态码，必须是0-255**
+ 17.2.3、使用函数输出
  + `result = $(dbl)	 #dbl是函数`

#### 17.3、在函数中使用变量

##### 17.3.1、向函数传递参数

+ `$#`判断传给函数的参数数目

##### 17.3.2、在函数中处理变量

+ 全局变量
+ 局部变量
  + `local`关键字，**保证了变量只局限在该函数中**
  + *问题，如果有2个同名的怎么办？*

#### 17.4、数组变量和函数

##### 17.4.1、向函数传数组参数

##### 17.4.2、从函数返回数组

+ test12.sh

#### 17.5、函数递归

+ test13.sh

#### 17.6、创建库

#### 17.7、在命令行上使用函数

#### 17.8、实例

#### 17.9、小结

### chap19、初始sed和gawk

### chap20、正则表达式

### 最后

#### 履历

+ 20220319写了点纸上的笔记