## 《大话设计模式》

+ 3个分类，7个原则
+ 创建型（5）
  + 工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
+ 结构型（7）
  + 适配器、装饰器、代理、外观、桥接、组合、享元
+ 行为型（11）
  + 策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
+ 7个原则

### chap3、单一职责原则

#### 3.4、

+ SRP，**就一个类而言，应该仅有一个引起它变化的原因**

### chap4、开放-封闭原则

#### 4.2、

+ **软件实体（类、模板、函数等等）应该可以扩展，但是不可修改**
  + 对于扩展是开放的（Open for extension）
  + 对于更改的封闭的（Closed for modification）

### chap5、依赖倒转原则

#### 5.3、依赖倒转原则

+ **高层模块不应该依赖低层模块。两个都应该依赖抽象**

+ **抽象不应该依赖细节，细节应该依赖于抽象**（针对接口编程，不要对实现编程）

#### 5.4、里氏代换原则

+ LSP，**子类型必须能够替换掉它们的父类型**

### chap11、迪米特原则

### chap1、简单工厂模式

#### 1.10、简单工厂模式

+ 到底要实例化谁，将来会不会增加实例化的对象
+ 简单运算工厂类

### chap2、策略模式（Strategy）

#### 2.1、商场收银软件

#### 2.4、

+ Strategy，**定义了算法家族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户**。

### chap6、装饰模式

### chap7、代理模式

### chap8、工厂方法模式

### chap9、原型

#### 9.1、夸张的简历

+ 简历类，设置性别和年龄，设置工作经历，需要写3份

#### 9.2、简历代码初步实现

+ 3份简历，需要3次实例化

#### 9.3、原型模式（Prototype）

+ **用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象**。（从一个对象再创建另一个可定制的对象，而且不需知道任何创建的细节）
+ 原型类（接口，*clone()是个纯虚函数？*）
+ 具体原型类
+ 客户端代码（调用 原型类）

#### 9.4、简历的原型实现

+ *为啥要调用clone()，直接赋值不行吗？*  【**主要是为了省构造函数的时间**-lionel，目前是猜的】

#### 9.5、浅复制与深复制

#### 9.6、简历的深复制实现

#### 9.7、复制简历 vs. 手写求职信

### chap10、模板方法

#### 10.1、选择题不会做，蒙呗！

+ 考试题目抄错了，就算会错，最后也白搭

#### 10.2、重复=易错+难改

+ A和B都抄了题目

#### 10.3、提炼代码

+ 老师出试卷，学生填答案
+ *没太理解，lionel*

#### 10.4、模板方法模式（TemplateMethod）

+ **定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤**。

#### 10.5、模板方法模式特点

#### 10.6、主观题，看你怎么蒙

### chap12、外观

### chap13、建造者

### chap17、适配器（Adapter）

#### 17.1、在NBA我需要翻译

#### 17.2、适配器模式

+ **Adapter**：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
+ 适配器模式分两种类型
  + 类适配器模式
  + 对象适配器模式
+ Target类
+ Adaptee（需要适配的类）
+ Adapter（内部包装一个Adaptee对象，**把源接口转换成目标接口**）
  + 继承自Target类
+ Client

#### 17.3、何时使用适配器模式

#### 17.4、篮球翻译适配器

#### 17.5、适合器模式的.NET应用

+ 对不同数据库的**DataAdapter**

#### 17.6、扁鹊的医术

### chap20、迭代器（Iterator）

#### 20.1、乘车买票，不管你是谁！

+ 只计算人头个数，不管具体的人是谁，还是行李，都要算钱

#### 20.2、迭代器模式

+ **Iterator**：提供一种方法顺序访问一个聚合对象中各个元素，而不暴露该对象的内部表示。

#### 20.3、迭代器实现

+ Iterator类：
  + First()
  + Next()，下一个
  + IsDone()，是否结束
+ ConcreteIterator
  + 继承Iteraotr并实现它
+ Aggregate类
  + 创建迭代器，`Iterator CreateIterator()`
+ ConcreteAggreagate类
  + 存放聚合对象
  + 重载`CreateIterator()`
  + *要不要提供啥方法？*
+ Client
  + 创建公交车，即聚集对象
  + 公交车上乘客，即对象数组
  + 创建迭代器对象，即售票员看上车的是哪些人
  + 迭代器操作，`First()，Next()，isDone()`，
    + 从第一个开始，只要没有结束，就不断Next
+ **当你需要对聚集有多种方式遍历时，可以考虑用迭代器模式**
  + 比如按重量遍历

#### 20.4、.NET的迭代器实现

+ foreach in，*我想到的是STL里的迭代器*

#### 20.5、迭代高手

### chap24、职责链（Chain of Responsibility）

#### 24.1、老板，我要加薪！

+ 向经理申请，经理没权利，向总监汇报，也没有权限，向总经理上报。

#### 24.2、加薪代码初步

+ 申请类
  + 申请类别
  + 申请内容
  + 数量
+ 管理类
  + 得到结果，`GetResult()`，一个函数里面判断当前的经理能不能批
+ Client

#### 24.3、职责链模式

+ *这个图，其实没太看，lionel*

+ **Chain of Responsibility**：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
+ Handler类
  + 定义一个处理请示的接口，`HandleRequest()`
+ ConcreteHandler1类
  + 请求数在1-10之间的有权处理
+ ConcreteHandler2类
  + 请求数在11-20之间的有权处理
+ ConcreteHandler3类
  + 请求数在21-30之间的有权处理
+ Client

#### 24.4、职责链的好处

+ 职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用

#### 24.5、加薪代码重构

+ 管理者类，Manager
+ 经理类CommonManager，继承Manger
+ 总监类MajorManager，继承Manger
+ 总经理类GeneralManager，继承Manger
+ Client

#### 24.6、加薪成功

### 构建者

### 学习过程

+ 0531，看了2章，建造者模式builder（13）、观察者模式observer（14）
+ 0601，看了3章，抽象工厂模式（15），状态模式（16），适配器模式（17），*抽象工厂模式，没太看懂*
+ 0710，看了3章，适配器（17，*之前看过了*），迭代器（20），职责链（24）