## 《算法设计与分析》

+ 作者**张军**，因为叫这本书的比较多，这本书也许不出名，但正好自己有，就努力就把它全书读懂吧
+ 配合《趣学算法》一起看
+ 2023-08-10左右意识到自己比较大的问题，**如何用代码去定义这些ADT，比如图的存储，这涉及到一些遍历的算法，虽然有思路，但还是要依靠具体的ADT去存东西的**，争取在2023年突破掉（不管是有意识去记，还是慢慢去理解，争取消化掉）
+ 各种疑问
  + Q1，疑问在于，这些伪代码怎么去对应真实的代码的if或者各种判断
  + Q2，有些场景自己能做出填空或计算题，比如**哈夫曼树**，但代码肯定是写不出来的的，以及**Dijkstra、Prim、Kruskal**
+ 各种整理
  + 绪论：**组合问题**怎么定义？
  + 贪心：用在 **图**（最短距离）和**组合**（背包问题）

### chap1、绪论

1.1、算法的基本概念

#### 1.2、算法设计与分析的重要问题类型

1.2.1、排序问题

1.2.2、查找问题

1.2.3、图问题

##### 1.2.4、组合问题

+ **Combinatorial Problem**，从离散的空间中寻找到一个对象，使之能够满足特定的标准。
  + 旅行商问题（Travelling Sales Problem）
  + 车辆路由问题 （Vehicle Routing Problem）

1.2.5、数值问题

1.2.6、几何问题

#### 1.3、算法复杂性分析基础

1.3.1、算法复杂性分析的原理

1.3.2、渐近符号

#### 1.5、习题

### chap2、基本数据结构

#### 2.1、数据结构的概念

#### 2.2、线性结构

2.2.1、线性表

2.2.2、栈

2.2.3、队列

##### 2.2.4、串

+ *kmp，后面学一下，lionel*

#### 2.3、树形结构

##### 2.3.1、树的定义与性质

+ 树的性质
  + 1、

##### 2.3.2、二叉树

+ 1、定义和性质
  + 满二叉树
  + 完全二叉树
  + 二叉排序树
  + 平衡二叉树
  + 二叉树的基本性质（*这个要记一下，其它书上也都有，应该都是一样的，lionel*）
    + 1、第i层上最多有2的(i-1)次方个结点
    + 2、如果高度为h，至多有2的h次方，再-1个结点
    + 3、
    + 4、完全二叉树有n个节点，高度h=log2n取最少，再加1
    + 5、
+ 2、存储结构
  + 顺序存储
  + 链式存储
+ 3、二叉树的遍历
  + 先序
  + 中序
  + 后序

##### 2.3.3、多叉树

#### 2.4、图状结构

+ 图的遍历，*这个我自己的笔记，单独写过*

##### 2.4.1、图的定义

##### 2.4.2、图的存储结构

+ 1、矩阵存储
+ 2、邻接表
+ 3、带权图

##### 2.4.3、图的遍历

+ 1、BFS
+ 2、DFS  （*有了递归了，可以不栈去存*）
  + [深度优先搜索两种实现方法java模板 递归和栈以及使用栈的潜在问题](https://blog.csdn.net/usualheart/article/details/108103136)

```cpp
DFS(G,s)
    1 visit(s)
    2 visited[s] <- TRUE
    3 for each v 属于 adj[s]
        do if visited[v] == FALSE
            then DFS(G,v)
```



#### 2.5、集合与字典（set与map）*感觉叫这个比较好*

+ 之前看了一下人家的面试题，map和set有啥区别？【*虽然STL的读书笔记里有写，但2者的区别，自己还没有完全搞得特别明白*】

##### 2.5.1、集合（Set）

+ 集合的3大特性
  + 确定性
  + 无序性
  + 互异性
+ 集合的三种基本运算

##### 2.5.2、字典（dictory）

+ 集合的特殊形式，**每个元素，由Key和Value组合，这个组合称为**【关联association】，难怪叫*关联容器*
+ 字典的**散列存储**（hash）

#### 2.6、本章小结

2.7、习题

### chap3、蛮力算法

+ Q1：**图、数值**一般不用蛮力？

3.1、算法设计思想

#### 3.2、排序问题

#### 3.3、查找问题

#### 3.4、组合问题

#### 3.5、几何问题

3.6、本章小结

3.7、习题

### chap4、分治算法

+ Q1：**图、数值**一般不用分治？

4.1、算法设计思想

#### 4.2、排序问题

#### 4.3、查找问题

#### 4.4、组合问题

#### 4.5、几何问题

4.6、本章小结

4.7、习题

#### 《趣学算法》一书中的题

### chap5、贪心算法

+ **排序、查找、数值、几何**不用贪心

5.1、算法设计思想

5.1.1、贪心算法的设计思想

5.1.2、贪心算法的求解过程

#### 5.2、图问题

##### 5.2.3、哈夫曼树

+ *lionel，这个逻辑我会，但代码写不出来*

#### 5.3、组合问题

+ Q1，我不是很能理解，把背包规为**组合问题**，难道是*离散空间里的最优解？ lionel*

##### 5.3.1、背包问题

+ 0-1背包，**物品不可拆分**
+ 部分背包，**可以只装入部分**
+ 伪代码（*部分背包了*）

```cpp
KNAPSACK-GREEDY(w,A,n)  //w是最大承重量，A是n个物品有序序列【weight和in（有多少重量放入背包）2个属性】，n个物品
    1 i<-w  //lionel，不懂为啥要赋值给i  【看完懂了，主要是每次要减去一些放入的，然后才是剩下的，第一次是 最大的】
    2 for j <- 1 to n
        do if i = 0   //表示最大承重为0
            break;
           else if A[j].weight <= i  //当前的重量小于最大承重
               then A[j].in <- A[j].weight
               else
                   A[j].in <- i
                i <- i-A[j].in //表示每次还剩多少【最大承重量】
```



+ *最终可能不是最优解*，但把问题简化为**线性的问一下，每个物品，存，存不存2种判断**

##### 5.3.2、活动安排问题

+ **每次选结束时间最早的**
+ 伪代码

```cpp
ACTIVITY-ASSIGN-GREEDY(m, s, f, n)  //n是活动数目，s是start,f是finish，m是编号
    A <- {m[1]},pre <- 1   //lionel，不太懂，直接给把编号1放入到集合里，还预设了一个变量pre？
    for i <- 2 to n
        do if(s[i]>=f[pre]) //只要是开始时间  大于 当前的结束时间，就属于处理逻辑，【其它场景，直接抛弃，不处理了？lionel】
            then A <- A U {m[i]}  //把当前这个i放入到集合里
                 pre <- i //更新pre变量
    return A
```



+ other

##### 5.3.3、多机调度问题

+ 问题描述：n个作业（job）要分配到m台机器（Machine）上，每个作业的时间（Time）
+ *这个自己还没看，其实应该不难，这个要想一下？*

5.4、本章小结

5.5、习题