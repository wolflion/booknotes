## 《文件系统技术内幕》

+ chap3、本地文件系统
  + open打开、路径查找
  + 3.2.1 **磁盘空间布局**，先介绍了所有情况，**再以ext系列为例**
+ chap4、ext2
  + 挂载、创建、删除、写、读、分配磁盘空间、文件扩展属性、权限管理

### chap1、从文件系统是什么说起

#### 1.1、什么是文件系统

+ 中间层是硬盘驱动器和操作系统把硬盘抽象为的一个连续的线性空间。

##### 1.1.1、普通用户角度的文件系统

+ 对文件系统而言，所有文件都是字节流，它并不关注文件的格式与内容。

###### 1.1.1.1、目录的概念

+ 目录本身也是一种文件，**目录中存储的数据是特殊的数据**
+ inodeID

###### 1.1.1.2、文件的概念

+ 文件是存储数据的实体
+ 文件名，分为两部分，**文件主名**，扩展名
+ 一个文件通常在逻辑上被划分为若干等份，每一份被称为一个**逻辑块**（Block）

###### 1.1.1.3、链接的概念

+ 软链接，**内容指向另外一个文件路径**，文件开头是`l`，最后有个`->`
+ 硬链接，**多个文件名指向同一个索引节点**，防止数据误删

##### 1.1.2、操作系统层面的文件系统

+ `dumpe2fs`

##### 1.1.3、文件系统的基本原理

+ 磁盘就是一个线性空间
+ **磁盘布局**

#### 1.2、常见文件系统及分类

##### 1.2.1、本地文件系统

+ 树形目录结构

##### 1.2.2、伪文件系统

+ **并不会持久化数据、而是内存中的文件系统**
+ 伪文件系统，**实现内核与用户态的交互**，`/proc/diskstats`

##### 1.2.3、网络文件系统

+ 在用户层面，完成挂载后的网络文件系统与本地文件系统完全一样

##### 1.2.4、集群文件系统

+ 本地文件系统，**构建基于网络的SAN设备上**
+ 集群文件系统本质上还是构建在客户端的，**网络文件系统则是构建在服务端的**。

##### 1.2.5、分布式文件系统

+ 网络文件系统的一种
+ 分布式文件系统与网络文件系统的差异在于服务端包含多个节点，**服务器是可以横向扩展的**

### chap2、如何使用文件系统

+ 写数据是如何绕过缓存的，如何创建一个稀疏文件，如何给文件加锁

#### 2.1、准备开发环境

#### 2.2、读/写文件

##### 2.2.1 文件系统的 API

+ 文件的读/写等操作通过文件描述符来确定具体的文件，不再关心文件名称

##### 2.2.2 文件访问的一般流程

##### 2.2.3 文件内容的读/写实例

##### 2.2.4 关于 API 函数的进一步解释

###### 2.2.4.1、open()函数

###### 2.2.4.2、read()函数

###### 2.2.4.3、write()函数

###### 2.2.4.4、close()函数

+ 疑问:
  + **为什么这些API通过一个整数（文件描述符）来标识一个文件？**
  + **当多个进程打开同一个文件时，文件描述符在不同进程中是怎样的？**

#### 2.3、如何遍历目录中的文件

+ `readdir()`

#### 2.4、格式化文件和挂载

+ 格式化，相当于在块设备上创建一个文件系统
+ 挂载，将文件系统激活（在操作系统目录树呈现）的过程
+ `mkfs.ext4`

#### 2.5、文件系统与权限管理

##### 2.5.1 Linux 权限管理简介

##### 2.5.2 设置文件的 RWX 权限

###### 2.5.2.1、基于API的权限设置

###### 2.5.2.2、基于命令的权限设置

+ 1.chmod命令
+ 2.chown命令
+ 3.chgrp命令

##### 2.5.3 设置文件的 ACL 权限

+ 1、获取文件的ACL属性
  + `getfacl`
+ 2、设置文件的ACL属性
  + `setfacl`

#### 2.6、文件系统的锁机制

##### 2.6.1、文件锁的分类与模式

+ 从大类上来分，分为
  + 劝告锁（Advisory Lock）
  + 强制锁（Mandatory Lock）
+ 在**使用上**，无论哪种锁都分为**共享锁和排他锁**两种

##### 2.6.2、Linux文件锁的使用

###### 2.6.2.1、flock()函数的使用简析

+ `int flock(int fd, int operation);`

###### 2.6.2.2、fcntl()函数的使用简析

+ `int fcntl(int fd, int cmd, struct flock *lock);`
+ **强制锁需要满足以下条件:**
  + 挂载文件系统时要指定mand选项
  + 必须关闭文件的组成员执行位
  + 必须打开文件的SGID位

#### 2.7、文件系统的扩展属性

+ `getfattr`命令

#### 2.8、文件的零拷贝

##### 2.8.1、零拷贝的基本原理

+ 读取文件的两个步骤:
  + 首先从磁盘中读取数据并将其保存到内核内存中
  + 然后从内核内存中交数据拷贝到用户分配的data_buf中

##### 2.8.2、零拷贝的系统API

+ `sendfile()`，**无法对数据进行修改**
+ `mmap()`，**将一个文件中一定区域的数据直接映射到进程的虚拟地址空间**

### chap3、本地文件系统原理及核心技术

+ 我们将直接管理磁盘等存储设备的文件系统称为**本地文件系统（Local File system）**

#### 3.1、Linux文件系统整体架构简介

+ 图3-1

##### 3.1.1、从VFS到具体文件系统

+ 写入数据，函数调用流程

##### 3.1.2、关键处理流程举例

###### 3.1.2.1、文件系统的注册

+ mount()主要作用：**从存储介质读取超级块信息，并创建该文件系统根目录的dentry实例。

###### 3.1.2.2、打开文件的流程

+ （1）如何通过一个字符串路径来打开一个文件？
+ （2）为什么通过一个文件描述符就可以实现文件的访问？
+ 打开文件有2个流程，`do_sys_open()->do_sys_openat2()->do_filp_open()->path_openat()`
  + 流程1：解析：`link_path_walk()->walk_component()->lookup_slow()->inode->i_op->lookup()->ext4_lookup()`
  + 流程2：打开：`do_open()->vfs_open()->do_dentry_open()->f->f_op->open()->ext4_file_open()`

###### 3.1.2.2、挂载文件系统

+ 关键流程：`do_mount()->do_new_mount()->do_new_mount_fc()->do_add_mount()->graft_tree()->attach_recursive_mnt()`

###### 3.1.2.2、读/写数据流程

+ 通过在inode注册的函数指针完成的，函数指针会赋值给file结构体中的成员`f_op`

#### 3.2、本地文件系统的关键技术与特性

##### 3.2.1、磁盘空间布局（Layout）

+ **元数据区**：对数据区进行管理的地方

###### 3.2.1.1、基于固定功能区的磁盘空间布局

+ 元数据区，又分为:
  + 数据块位图
  + inode位图
  + inode表
+ **块组**：
+ 块组0:
  + 引导块：**预留给操作系统的**
  + 超级块
  + 块组描述符
  + 预留GDT块
  + 数据块位图
  + inode位图
  + inode表
  + 数据块
+ 问题在于：**元数据功能区大小固定，因此容易出现资源不足的情况**。

###### 3.2.1.2、基于非固定功能区的磁盘空间布局

+ XFS文件系统先将磁盘划分为等份的区域，称为**分配组（Allocate Group）**

###### 3.2.1.3、基于数据追加的磁盘空间布局

+ NILFS2

##### 3.2.2、文件的数据管理

+ **将文件的逻辑块与磁盘的物理块建立关系**

###### 3.2.2.1、基于连续区域的文件数据管理

+ 只要知道文件的起始位置所对应的磁盘位置和文件的长度
+ 缺点在于，**对文件进行追加写操作非常困难**

###### 3.2.2.2、基于链表的文件数据管理

+ **解决连续区域的碎片问题，但是对文件的随机读写无能为力**
+ FAT12

###### 3.2.2.3、基于索引的文件数据管理

+ 1、基于间接块的文件数据管理
  + **元数据与数据有一个固定的对应关系**，也就是数据越多，需要的元数据越多。
+ 2、基于Extent的文件数据管理
  + 每一个索引项记录的值不是一个数据块的地址，而是**数据块的起始地址和长度**。

##### 3.2.3 缓存技术

###### 3.2.3.1、缓存的替换算法

+ **将缓存数据刷写到磁盘，并且存储新数据的过程**，称为 缓存替换

+ 1、LRU算法
  + **使用一个链表来实现**
  + 会存在**缓存污染**
+ 2、LFU算法

###### 3.2.3.2、预读算法

+ 预读算法**通过识别I/O模式方式来提前将数据从磁盘读到缓存中**

+ 2种情况会触发预读
  + 一是
  + 二是当应用访问到有预读标记的缓存时会触发预读操作

##### 3.2.4、快照与克隆技术

###### 3.2.4.1、快照技术原理简析

+ 两种实现方式:
  + 一种是**写时拷贝（Copy-on-Write）**
  + 一种是**写时重定向（Redirect-On-Write）**

###### 3.2.4.2、克隆技术原理简析

###### 3.2.4.3、应用实例

##### 3.2.5 日志技术

##### 3.2.6 权限管理

###### 3.2.6.1、RWX权限控制的原理

+ root,group,other这些属主的rwx权限

###### 3.2.6.2、ACL权限控制的原理

+ accessACL
+ defaultACL

###### 3.2.6.3、SELinux权限管理

+ 关键是SElinux策略数据库的建立

##### 3.2.7 配额管理

+ 软上限
+ 硬上限
+ 宽限期：**针对软上限而言**，即几天内允许数据量超过软上限

##### 3.2.8 文件锁的原理

##### 3.2.9 扩展属性与ADS

+ 扩展属性：**现有文件系统支持原始设计中未提供的功能**，xattr
+ ADS（Alternate Data Streams）交换数据流

##### 3.2.10 其他技术简介

###### 3.2.10.1、数据加密

+ 透明数据加密，**对用户来说是感知不到的**

###### 3.2.10.2、数据压缩

#### 3.3、常见本地文件系统简介

##### 3.3.1 ExtX 文件系统

##### 3.3.2 XFS 文件系统

##### 3.3.3 ZFS 文件系统

##### 3.3.4 Btrfs 文件系统

##### 3.3.5 FAT 文件系统

##### 3.3.6 NTFS 文件系统

### chap4、Ext2 文件系统代码详解

#### 4.1、本地文件系统的分析方法与工具

##### 4.1.1、基于文件构建文件系统

+ dd命令生成一个全0的二进制文件`dd if=/dev/zero of=./ext2.bin bs=1M count=100`
+ 格式化`mkfs.ext2 ext2.bin`
+ 使用loop设备，`losetup /dev/loop10 ./ext2.bin`
+ 挂载，`mount /dev/loop10 /tmp/ext2/`

##### 4.1.2、了解函数调用流程的利器

+ **ftrace**

#### 4.2 从 Ext2 文件系统磁盘布局说起

##### 4.2.1 Ext2 文件系统整体布局概述

##### 4.2.2 超级块（SuperBlock）

+ 超级块，是**文件系统的起始位置，是整个文件系统的入口**

##### 4.2.3 块组描述符（Block Group Descriptor）

+ 以列表形式跟在超级块之后
+ `dumpe2fs`

##### 4.2.4 块位图（Block Bitmap）

##### 4.2.5 inode 位图（inode Bitmap）

##### 4.2.6 inode 与 inode 表

+ **inode表**，以列表的形式紧跟在inode位图之后，每一项就是一个inode节点。

#### 4.3、Ext2 文件系统的根目录与目录数据布局

+ 目录本质上也是一个文件，**其存储的数据是一个特定的、格式化的数据**
+ **目录项entry**

#### 4.4、Ext2 文件系统的挂载

+ `ext2_mount()`

#### 4.5 如何创建一个文件

##### 0、

+ 创建文件的步骤:
  + 1.从inode表中申请一个inode
  + 2.在目录中创建一个目录项
  + 3.申请磁盘空间存储数据（如果存在写数据）

##### 4.5.1 创建普通文件

+ `ext2_create()`

##### 4.5.2 创建软硬链接

+ 0
+ 1、硬链接的创建流程
  + `ext2_link()`
+ 2、软链接的创建流程
  + `ext2_symlink()`

##### 4.5.3、创建目录

#### 4.6 Ext2 文件系统删除文件的流程 . 125

#### 4.7 Ext2 文件系统中文件的数据管理与写数据流程 . 129

4.7.1 Ext2 文件系统中的文件数据是如何管理的 . 129
4.7.2 从 VFS 到 Ext2 文件系统的写流程. 130
4.7.3 不同写模式的流程分析 . 134
4.7.4 缓存数据刷写及流程 . 138

#### 4.8、读数据的流程分析

##### 4.8.1、缓存命中场景

##### 4.8.2、非缓存命中场景

##### 4.8.3、数据预读逻辑

#### 4.9、如何分配磁盘空间

+ `ext2_get_blocks()`

##### 4.9.1、计算存储路径

+ 0
  + `ext2_block_to_path()`
+ 1级间接块偏移值为0
+ 2级间接块偏移值为0
+ 3级间接块偏移值为4

##### 4.9.2、获取存储路径

+ `ext2_get_branch()`

##### 4.9.3、分配磁盘空间

+ `ext2_alloc_branch()`

#### 4.10 Ext2 文件系统的扩展属性

##### 4.10.1、Ext2 文件系统扩展属性是怎么在磁盘存储的

+ `struct ext2_xattr_header{};`

##### 4.10.2、设置扩展属性的 VFS 流程

+ `fsetxattr()`

##### 4.10.3、Ext2 文件系统扩展属性接口实现

+ `ext2_xattr_user_set()`

#### 4.11、权限管理代码解析

##### 4.11.1、ACL 的设置与获取

+ `setfacl()`

##### 4.11.2、ACL 权限检查

+ `may_open()`

#### 4.12、文件锁代码解析

##### 4.12.1、flock()函数的内核实现

+ fs/locks.c中

##### 4.12.2、fcntl()函数的内核实现

+ fs/fcntl.c中