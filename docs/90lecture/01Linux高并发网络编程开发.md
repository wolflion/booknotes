## 内容

### day10、网络编程基础socket

#### 01、知识点概述（20200401）

+ 第8-10天，自己实现一个Mini Web服务器（有两个功能）
  + 处理网络I/O
  + 业务处理

#### 02、网络开发两种设计模式（）

+ 

#### 03、网络模型分层（）

+ 

#### 04、以太网帧协议（）

+ 

#### 05、IP协议（）

+ 

#### 06、UDP协议（）

+ 

#### 07、TCP协议（）

+ 

#### 08、TCP-IP四层模型协议封装（）

+ 

#### 09、UDP和TCP讲解（）

+ 

#### 10、什么是套接字（20200401）

+ **Socket是网络通信的函数接口的总称**，封装了传输层的协议（TCP，UDP）。
+ 浏览器，应用层用的是HTTP，往下封装的是TCP。
+ Socket：IP+Port。

#### 11、套接字内存模型（20200401）

+ socket通信
  + 服务器端（插座）**被动**让客户端连接；
  + 客户端（电风扇、电视）**主动**
+ socket编程--**网络IO编程**
  + 读写操作（read/wirte)
    + 文件描述符
  + 创建一个套接字，得到的是文件描述符，**这个fd也是一块内核缓冲区**
  + **内核缓冲区分为两部分（读缓冲区，写缓冲区）**，这是系统处理好的，不用应用程序关心。
  + 客户端的数据先write到写缓冲区，然后会到同步到服务端的读缓冲区里，服务端fd里的写缓冲区也一样。
  + *与匿名管道的区别？*
  + **默认是阻塞的**，对应的是fd的设备的文件性质，不是wirte(),read()函数的性质。
+ 匿名管道
  + 分为读、写两端  **队列**数据结构
  + 管道的读写两端分别对应一个文件描述符
  + 内核缓冲区（内存中一块存储空间）
  + **默认是阻塞的**

#### 12、知识点复习（）

+ 

#### 13、大端和小端存储（）

+ 

#### 14、大小端转换函数

### day11、TCP三次握手-并发

#### 1、学习目标

+ 3次握手、4次挥手、滑动窗口
  + connect时就会握手，close时就会挥手
+ 错误处理函数封装
+ 多进程并发，多线程并发

#### 2、知识点回顾

+ 网络开发设计模式
  + C/S：桌面客户端
  + B/S：跨平台，http，**效率低**
+ 分层模型：
  + 七层
  + 四层：网络接口层、网络层、传输层、应用层
+ tcp,udp
+ socket
  + 文件（内核中的缓冲区）操作
  + socket tcp server的操作流程
    + *还是记住这些几种细节*，10min左右
    + **accpet()的返回值，是用于通信的**，listen()的返回值，是用于监听的
    + close(lfd)，close(cfd)，**就需要关闭2次**
  + socket tcp client的操作流程
    + `struct sockaddr_in client;`，进行connect操作

#### 3、tcp客户端代码实现（20200401）

+ [client_tcp.c]

#### 4、socket函数封装（20200402）

+ [wrap.c]查看
  + **Man文档跳转的时候，不区分大小写**，可以把accept()的函数重装包装成Accpet()。
  + *用啥+K可以跳转？lionel*
  + bind(),connect(),listen(),socket(),close()，这些返回-1时，就打印错误。
  + accept()、read()，write()返回-1，都递归调用。**read和write会阻塞**。
  + readn()是自己写的，多了个**应该读取的字节数`n`**；
  + writen()也是自己写的，跟readn()一样
  + Readline()调用一个静态函数my_read()

#### 5、TCP三次握手（20200403）

+ 连接服务器的过程中完成三次握手，6个标志位：
  + SYN：请求建立连接
  + ACK：应答
  + FIN：断开连接
  + RST
  + URG
  + PSH
+ **第1次握手是由客户端发起**，
  + 客户端：
    + SYN标志位+32位序号（随机产生）+数据（也可以不带数据）
  + 服务器
    + 判断SYN值为1时，第1次握手才算成功。
+ 第2次握手
  + 服务器
    + ACK标志位+32确认序号（在随机序号基础上+1）+数据（也可以不带数据）
    + 发起一个连接请求：SYN标志位+32位序号（随机产生）+数据（也可以不带数据）
  + 客户端
    + 检测ACK标志位是不是为1
    + 检测32位确认序号是否是自己随机序号基础上加1
+ 第3次握手
  + 客户端
    + 发送确认数据包：ACK标志位+32位确认序号
  + 服务器：
    + 检测：ACK是否为1，
    + 检测：确认序号是否正确
+ *思考*
  + 带数据的时候，回的确认序号是多少？（大小后再加1？）

#### 6、TCP的数据传输过程（20200403）

+ MSS（最大数据长度）：客户端告诉服务器，你给我发的数据长度的值。
+ 三次握手，建立连接的过程
  + 客户端：`connect()`
  + 服务器：`accept()`
+ 数据传输
  + 客户端：编号（对方最后发送ACK的时候携带的确认序号）+ACK+对方最后一次的ACK编号
  + 服务端：ACK+确认+数据
  + 客户端：ACK+确认
+ *这部分其实没太完全懂，但看图能说出个大概来*，**数据连接过程中没有SYN关键字**

#### 07、四次挥手（20200403）

+ **哪一些主动主动断开连接都可以**。
+ 需要一个标志位：FIN。
+ 第一次挥手
  + 客户端（发送断开的请求）：
    + FIN+对方最后发送ACK的时候携带的确认序号+数据（可以不带）；
    + ACK+序号（对方的发送的序号+长度）
  + 服务端：
    + 检测FIN值是否为1
    + ACK的作用：告诉对方之前发的数据收到了多少
+ 第二次挥手
  + 服务器（给Client确认数据包）
    + ACK+确认编号（FIN对应的序号+1+数据大小）
  + 客户端：
    + 检测：ACK的值
    + 检测：确认序号
+ 第三次挥手：（**服务器发起的告别过程**）
  + 服务器端（发送断开连接的请求）
    + FIN+序号（最后一次收到，对方的ACK）
    + ACK+序号
  + 客户端：
    + 数据检测，数据是不是收到
+ 第四次挥手
  + 客户端：
    + ACK+序号（收到的ACK序号+1）
+ **第2次和第3次都是同一个人发的**，*主要是序号的值，要确认一下*。
+ 在代码中表现就是
  + 客户端和服务端都是用`close()`

#### 08、滑动窗口（20200403）

+ **滑动窗口**就是缓存，对应的“16位窗口大小”，就是记录的缓存大小。
+ WIN 4096
  + win-滑动窗口
  + 4096-滑动窗口对应的缓冲区大小
  + **客户端和服务端的WIN，大小值可以不一样**，一般都不一样。  
+ 可以发很多条，服务器再答复。

#### 09、多进程并发服务器分析（20200404）

+ **并发**：在某个时间点处理的个数。
+ 服务端只处理单连接
  + 创建套接字
  + 绑定
  + 监听
  + 接受连接请求
  + 通信
+ 服务端处理多连接
  + 监听：最多可以128个【listen(fd,128)】
  + 接受连接请求
    + 让父进程创建子进程，去连接客户端A
    + **父进程只等待连接请求**，有请求就fork()一下
+ 使用多进程的方式，解决服务器处理多连接的问题
  + 共享
    + **读时共享，写时复制**，读的时候对应的同一个物理地址；写的时候，就会开辟新的空间，再读就会去新开辟的空间读。
    + 共享的内容有：文件描述符；内存映射区--mmap创建出来的；
  + 父进程的角色是什么？
    + 等待接收客户端连接 ---accept()
      + 有连接，创建一个子进程 fork()
      + **将通信的文件描述符关闭**
  + 子进程的角色是什么？
    + 通信
      + 使用accept()返回值，就是fd。
    + **关掉监听的文件描述符**
      + 主要原因是：浪费资源（因为fd的个数有限，才1024个）
  + 创建的进程的个数有限制吗？
    + 有，受硬件限制。
    + **文件描述符默认有上限是1024个**。
  + 子进程资源回收
    + 不回收的话，会被init回收或变成僵尸进程。
    + wait()或waitpid()回收。
    + 用信号回收
      + 信号捕捉（signal，sigaction）推荐后者
      + 捕捉SIGCHLD信号
+ 文件描述符（有2个）？
  + 用于监听的
  + 用于通信的

#### 10、多进程并发服务器伪代码（20200404）

+ [多进程并发服务器伪代码.c]

#### 11、多进程并发服务器代码实现（20200404）

+ [process_server.c]

#### 12、多线程并发服务器实现思路（20200404）

+ 服务器收到客户端的connect()，可以当作是主线程收到，然后`pthread_creat()`创建子线程处理。
  + 把文件描述传到子线程内部，进行read/write操作。
+ 线程共享：
  + 全局数据区
  + 堆区数据
  + 一块有效内存的地址
+ **每个线程都要备份独立的处理**，把处理封装到结构体里，同时在回调函数里处理。

#### 13、多线程版客户端代码实现（20200404）

+ [pthread_server.c]



### day12、TCP状态转换-select-poll

#### 01、知识点概述

#### 02、三次握手四次挥手复习

#### 03、多进程多线程并发复习（）

#### 04、recv和send函数（20200406）

+ 数据接收
  + read()
  + recv()
+ 数据发送
  + write()
  + send()
+ 两者是可替代的，**区别在于后面的函数多了一个参数flags，赋值为0即可**。
  + UDP的话，用的是`recvfrom()`和`sendto()`**它们的flags也赋值为0**。

#### 05、tcp状态转换（20200408）

+ 客户端：`CLOSED`->`SYN_SENT`->`ESTABLISTHED`->数据传偷中状态不变->**谁先发送挥手请求，谁先变**->`FIN_WAIT_1`->`FIN_WAIT_2`->`TIME_WAIT`->`CLOSED`
  + 主动断开的一方，最后的状态是**TIME_WAIT**。
+ 服务端：`CLOSED`->`LISTEN`->`SYN_RCVD`->`ESTABLISTHED`->`CLOSE_WAIT`->`LAST_ACK`->`CLOSED`
  + *这不是服务端主动断开连接*。

#### 06、2msl等待时长（20200408）

+ 能捕捉到的状态（netstat命令会捕捉）
  + LISTEN
  + ESTABLISHED
+ 主动断开连接的一方到`TIME_WAIT`状态时，会等待2MSL时长，一个MSL是30秒，2个就是1分钟。
  + 怕对方没有收到，用这个2MSL再发送一次。

#### 07、半关闭（20200408）

+ 如何理解？
  + **有一端关闭，另一端没关闭**
  +  A给B发送是FIN（A调用了close函数），但是B没有给A发送FIN（B没有调用close）
  + 即A断开了与B的连接，B没有断开与A的连接。
+ 特点：
  + A不能给B发送数据，但能收到B发送的数据。
  + B能给A发送数据
+ 函数：`shutdown(int sockfd, int how)`
  + how
    + SHUT_RD 0读
    + SHUT_WR 1 写
    + SHUT_RDWR 2 读写
  + **把拷贝的文件描述符也不能用了**
+ dup,dup2
  + 复制文件描述符，dup2()还能得定向。
+ 思考：close函数能否实现半关闭？

#### 08、netstat命令（20200407）

+ 用netstat捕捉进程的状态（套接字通信）
  + -a，默认不显示LISTEN相关，所以要用a
  + -p，显示建立相关链接的程序名
  + -n，拒绝显示别名，能显示数字的全部转化为数字
  + -t（tcp）仅显示tcp相关选项
  + -u（udp）仅显示udp相关选项
  + l 仅列出有在Listen（监听）的服务状态
+ `grep -apn`
  + **服务端永远有个监听套接字**，最后看名称判断服务器还是客户端。
  + 第1个ip+port表示当前名称的本地IP+Port，第2个是连的远端的IP+Port。
+ **`TIME_WAIT`，主动断开的一方，会有一个TIME_WAIT状态**，这个等待大概是1min。
  + `FIN_WAIT2`和`CLOSE_WAIT`又分别是谁是发起人呢？

#### 09、端口复用设置（20200409）

+ 作为server端主动断开连接后，再启动会有“Address already in use”，原因是
  + **主动断开连接的一方有2MSL的等待时长**。--lionel，我在定位问题的日志里就见过，但当时不知道啥原因呢。
+ 当然也可以用**端口复用**的方式解决。
+ 端口复用的用途
  + 防止服务器重启时之前绑定的端口还未释放
  + 程序突然退出而系统没有释放端口
+ 设置方法
  + `int opt = 1; setsockopt(sockfd, SOL_SOCKET,SO_REUSEADDR,(const void*)&amp;opt, sizeof(opt));`
    + **文件描述符是监听描述符**。
+ 注意事项
  + **在绑定之前设置端口复用的属性**。

#### 10、IO多路转换讲解（20200408）

+ IO操作方式
  + 阻塞等待
    + 好处：不占CPU宝贵的时间片
    + 缺点：同一时刻只能处理一个操作，效率低
    + **多进程/多线程**解决，只等待，再用子线程/子线程处理相应业务，**创建进程/线程太耗费资源**
  + 非阻塞，忙轮询
    + 优点：提高了程序的执行效率
    + 缺点：需要占用更多的CPU和系统资源
    + **单任务/多任务**（不断问）
  + **解决方案：使用IO多路转接技术select/poll/epoll**
    + 第一种：select/poll
      + **先委托内核帮我们检测一下有哪些客户端会跟我通信**，通过`select()`来实现。
      + **select()只识数不认字，只会告诉你有几个快递（客户端）到了**，但是哪个快递，需要挨个遍历所有客户端。
      + poll遍历的是线性表。
    + 第二种：epoll
      + **epoll()不仅告诉你数量，也会告诉你哪个快递公司的快递**。
      + epoll遍历的是红黑树。
+ *以取快递的例子来讲*

#### 11、内核大致是如何实现IO连接的（20200408）

+ 先构造一张有关文件描述符的列表，将要监听的文件描述符添加到该表中
  + 阻塞信号集表/自定义信号集表，再用`sigpromask()`是这两张的桥梁。
+ 然后调用一个函数，监听该表中的文件描述符，直接这些描述符表中的一个进行I/O操作时，该函数才返回
  + 该函数为阻塞函数
  + 函数对文件描述符的检测操作是由内核完成的
+ 在返回时，它告诉进程有多少（哪些）描述符要进行I/O操作
+ *通过调用selec()函数，把构造的文件描述符列表给到内核？*--是这样的吗？

#### 12、select的参数和返回值（20200409）

+ `int select(int nfds, fd_set *readfds, fd_set *writefds,
                    fd_set *exceptfds, struct timeval *timeout);`
  + ndfs：一组描述符中最大的值再加1；最多传1024
    + `fd_set`是个数组，大小是16个，所以最多传1024（16 乘 8位 乘 字节），所以最多1024个标志位。
  + readfds：**传入传出参数**，读集合
  + writefds：一般传空  （写是主动操作，不捕捉）
  + exceptfds：一般传空  **异常集合**
  + timeout：**通过设置它来确定是否阻塞**
    + NULL：永久阻塞（当检测到fd有变化的时候返回）
    + 要让结构体变量的a有值，a.tv_sec=0，a.tv_usec=0。
+ 文件描述符集类型：`fd_set rdset;`
  + FD_ZERO()清空
  + FD_CLR()删除某项
  + FD_SET()添加文件描述符
  + FD_ISSET()判断是否存在集合中 **没有设置上，就是0**
+ select函数的优缺点
  + 优点
    + 跨平台
  + 缺点
    + 内核的开销太大（一是拷贝；二是遍历）
    + select支持的文件描述符数量太小了，默认是1024

#### 13、复习（）

#### 14、select工作过程（20200409）

+ 需求：客户端A,B,C,D,E,F连接到服务器；分别对应文件描述符3，4，100，101，102，103，ABC发送了数据。
+ 第一步：创建fd_set类型的reads;   **这是用户空间**
+ 第二步：添加到reads，`FD_SET(3,&reads)`
+ 第三步：`select(103+1,&reads,NULL,NULL,NULL);`
  + 内核会把用户空间的reads，拷贝到内核空间。
  + 内核根据值为1，去找文件描述符；**如果文件描述符没有数据，内核会把值从1变为0**，有值的话，就不变。
  + **内核把修改过的表会再传给用户空间，会覆盖到用户空间的reads**（这样就可能不一样了）
+ **得定义两个fd_set变量**，用于对比。

#### 15、select伪代码实现（20200410）

+ [select伪代码实现.cpp]

#### 16、select代码实现（20200410）

+ [day12_17select.c]

#### 17、poll函数介绍（20200410）

+ poll的数据结构是个链接，epoll的数据结构是个树。
+ poll两块互拷贝也有开销。 
+ `int poll(struct pollfd *fd, nfds_t nfds, int timeout)`
  + pollfd：数组的地址
  + nfds：数组的最大长度，数组中最后一个使用的元素下标+1
    + 内核会轮询检测fd数组的每个文件描述符
  + timeout：
    + -1：永久阻塞
    + 0：调用完成立即返回
    + `>0`：等待的时长毫秒
  + 返回值：IO发送变化的文件描述符的个数
+ *没太好好听*--后面再补充这部分

#### 18、poll实现IO转接代码分析（20200411）

+ *比较poll.c和select.c*，这两个都找他们的例子吧。
+ **要把流程搞清楚**。

### day13、epoll-udp

#### 01、知识点概述

#### 02、通过gdb定位段错误的位置（20200412）

+ `set args`设置参数
+ `r`运行
+ 最终定位是`pthread_detach()`引用参数有错。*我对pthread_detach()还不熟悉*

#### 03、tcp状态转换复习（）

+ 

#### 04、select复习（）

+ 

#### 05、epoll相关的函数介绍（20200412）

+ **epoll在内部是个树结构**。
  + 持在树上的是`struct epoll_event`类型里的`fd`。

+ `epoll_create()`
  + 用来生成一个树的根结点
  + 参数size：epoll上能关注的最大描述符数
+ `epoll_clt()`
  + 控制某个epoll文件描述符事件，可以注册、修改、删除
  + epfd参数：create()创建的
  + op参数：
    + EPOLL_CTL_ADD
    + EPOLL_CTL_MOD
    + EPOLL_CTL_DEL
  + fd参数：关联的文件描述符
  + event参数：告诉内核要监听什么事件
+ `epoll_wait()`
  + 等待IO事件发生---可以设置阻塞的函数
  + epid参数：epoll_create()创建的
  + `struct epoll_event* events`参数：结构体数组，作用是（有哪几个变化了，都在这个结构体里）**传出参数**
  + maxevents参数：告诉内核events的大小（结构体数组的容量）
  + timeout参数：超时时间
    + -1：永久阻塞
    + 0：立即返回，阻塞0毫秒，立即返回了
    + 大于0：阻塞时长，单位是毫秒

#### 06、epoll工作流程（20200415）

+ [伪代码.c]

#### 07、（）

+  

#### 08、epoll模型代码实现（20200415）

+ 

#### 09、epoll复习（）

+ 

#### 10、epoll水平触发模式（20200419）

+ 默认的触发工作模式
+ 水平触发模式
  + 只要fd对应的缓冲区有数据，**根据读来解释**
  + epoll_wait()返回
  + 返回的次数与发送数据的次数没有关系
  + 发100个数据，每次只读1个的话，就要读100次。
  + *不需要额外的操作*
+ [lt_epoll.c]
  + 读数据时，原来的buf[1024]，bufchar[5]。
  + printf()是标准C库函数，有默认缓冲区8K，是**行缓冲**，加`\n`才会强刷缓冲区。
  + 换成`write(STDOUT_FILENO,buf,len);`，**原先定义的buf，最后一位没有给它强制加一个`\0`**，这个在代码中确实有风险。
  + linux系统函数，有哪些。
+ `epoll_wait()`调用次数越多，系统的开销越式。

#### 11、边沿触发模式（20200419）

+ **ET**
+ fd-默认阻塞属性
+ 客户端给server发数据：
  + 发一次数据server的epoll_wait()被触发一次（即返回一次）
  + 不管有没有读完，都只返回一次，**不在乎数据有没有读完**
  + **如果读不完，如何全部读出来？**
    + `while(recv());`这种写法的副作用是**数据读完之后recv会阻塞**。
    + 解决阻塞问题（设置非阻塞--fd）
+ [et_poll.c]
  + 边延触发：要加个宏 `temp.events = EPOLLIN | EPOLLET;`

#### 12、边沿非阻塞模式（20200419）

+ **效率最高**
+ 如何设置非阻塞
  + open()，通过设置flags的必选项，以及可选项`O_NOBLOCK`，**适用于终端文件/dev/tty**
  + fcntl()
    + 更改属性前先获取 `int flag = fcntl(fd,F_GETFL);`
    + 设置一下`flag |= O_NONBLOCK;`
    + 再设置回去`fcntl(fd,F_SETFL,flag);`
+ 将缓冲区的全部数据都读出
  + `while(recv() >0 ) {printf();}`
  + //当缓冲区数据读完之后，返回是否为0？
+ [noblock_et_poll.c]
  + while()后再进行数据回写`send(fd,buf,len,0);`
  + `len ==0 prinf("断开连接");close(fd);`**还得从树上删除**
  + `len == -1,printf();exit(1);` **这里判断一下`errno==EAGAIN`**
+ 阻塞
  + 数据读完之后
+ 非阻塞
  + 强行读了一个没有数据的缓冲区（fd）
  + 判断`errno==EAGAIN`

#### 13、文件描述符突破1024（20200419）

+ select--突破不了，需要编译内核
  + 通过数组实现的，**数组有固定大小**
+ poll和epoll可以突破1024限制
  + poll是通过内部链表实现的
  + epoll是通过红黑树来实现的
+ 查看受计算机硬件限制的文件描述符上限
  + cat或vi  `/proc/sys/fs.file-max`
  + `ulimit -a`
+ 通过配置文件修改上限值
  + `/etc/security/limits.conf`
+ `ulimit -n`修改open files的数量

#### 14、udp通信流程（20200413）

+ 基于SOCK_STREAM，**面向无连接**，不需要`connect()`
+ 服务器端：
  + **Server只有一个**
  + 创建套接字`int fd = socket(af_inet,sock_dgram,0);`
  + 绑定本地IP和端口`bind()`
  + 通信：接收数据`recvfrom()`
  + 发送数据`sendto()`
  + 关闭套接字`close()`
+ 客户端
  + 创建套接字`int fd = socket(af_inet,sock_dgram,0);`
  + 通信：发送数据`sendto()`
  + 接收数据`recvfrom()`
  + 关闭套接字`close()`
+ **客户端是通过（IP+端口）发送给服务器端，服务器会保存客户端的IP+端口信息**。
+ *qt里面，两者流程都差不多，如果任何一端想接受数据，必须绑定端口*
  + 因为是被封装过了。
  + **越封装越简单，越简单越不知道怎么回事**

#### 15、udp服务器端代码实现（20200413）

+ `recvfrom()`
+ `sendto()`
+ [server.c]

#### 16、udp客户端代码实现（20200413）

+ [client.c]

### day14、广播-组播-本地套接字

#### 01、知识点概述

#### 02、epoll复习

#### 03、udp通信流程复习（）

+ 

#### 04、tcp_udp使用场景（20200419）

+ 1、tcp使用场景
  + 对数据安全性要求高的时候
    + 登录数据的传输
    + 文件传输
  + http协议
    + 传输层协议--tcp
+ 2、udp使用场景
  + 效率高--实时性要求比较高
    + 视频聊天
    + 通话
  + 有实力的大公司
    + 先使用upd，在应用层自定义协议，做数据校验

#### 05、广播通信流程（20200419）

+ 广播（只有在udp时才可以）
  + 服务器：只主动发数据
    + **需要广播地址，发送到固定端口**
    + 窗口套接字--socket
    + fd需要绑定服务器IP和端口
    + **初始化客户端IP和端口信息**`struct sockaddr_in cli;`
    + 发送数据`sendto(fd,buf,len,0,)`
    + **设置广播权限**
      + `setsockopt()`
  + 客户端：被动收数据
    + **绑定固定端口**，你不绑定固定端口，也会收到数据，只不过不处理，被当成垃圾处理处理掉了
    + 创建套接字
    + 显示绑定IP和端口
      + bind()
    + 接收数据--server数据
      + recvfrom()
  + 适用范围
    + **只适用于局域网**
+ 广播地址
  + XXX.XXX.123.255，123网段的都能收到，**255就是广播地址**。
  + XXX.XXX.123.1，**1是网关**
  + 255.255.255.255所有网段都能收到。

#### 06、广播服务器代码实现（20200419）

+ [broadcast_server.c]

#### 07、广播客户端代码实现（20200419）

+ [broadcast_client.c]

#### 08、广播客户端通信总结（20200419）

#### 09、组播通信流程（20200420）

+ **广播只能用于局域网范围**。
+ 组播可以适用于局域网和Internet
+ 组播Server
  + **只发送数据**
  + 需要使用组播地址，发送到客户端对应的端口8989
  + **添加组播权限**，`setsockopt()`
+ 组播Client
  + 绑定固定端口8989
  + 加入到组播地址，`setsockopt()`
  + **只接收，不发送数据**
+ **组播地址**（4类）
  + 224.0.0.0-224.0.0.255（预留的永久地址）
  + 239.0.0.0-239.255.255.255（局域网）
+ `struct ip_mreqn`
+ `struct in_addr`

#### 10、组播服务器代码实现（2020420）

+ 要对**`struct ip_mreqn`**初始化，名称记为*美人儿去哪*
+ `if_nametoindex()`通过eth0这样的名称，获取mac地址，**if代表ifconfig的if**。
+ 对比一下组播、广播的代码

#### 11、组播客户端代码实现（20200420）

#### 12、复习

#### 13、本地套接字通信流程（20200421）

+ 文件格式
  + 管道：p
  + 套接字：s
  + **这两个文件是伪文件**（在磁盘上大小永远为0，不存在磁盘，存在内核缓冲区里）
+ 有两种方式
  + tcp流程，**讲这个**
  + udp
+ 服务器端
  + 创建套接字`int lfd = socket(AF_LOCAL,sock_stream,0)`
  + 绑定`struct sockaddr_un serv; serv.sun_family=af_local; strcpy(serv.sun_path,"server.socket");bind(lfd,(struct sockaddr_un&serv,len);`
    + **只有绑定成功后，.socket文件才能被创件出来**
  + 设置监听`listen()`
  + 等待接收消息请求`struct sockaddr_un client; int len = sizeof(client); int cfd = accept(lfd,&client,&len);`
  + 通信 send和recv
  + 断开连接 close(cfd),close(lfd)
+ 客户端
  + 创建套接字`int lfd = socket(AF_LOCAL,sock_stream,0)`
  + **绑定一个套接字文件**：`struct sockaddr_un client; client.sun_family=af_local; strcpy(client.sun_path,"client.socket");bind(lfd,(struct sockaddr_un&client,len);`
  + 连接服务器：`struct sockaddr_un serv; serv.sun_family=af_local; strcpy(serv.sun_path,"server.socket");`，**然后再连接server**，`connect(fd,&serv,sizeof(serv));`
  + 通信 send和recv
  + 断开连接 close(cfd),close(lfd)

#### 14、本地套接字Server实现（20200421）

#### 15、本地套接字Client实现（20200421）

#### 16、心跳包（20200422）

+ 作用：**判断客户端和服务器是否处于连接状态**
  + 心跳机制
    + 不会携带大量的数据
    + 每个一定时间 服务器->客户端/客户端->服务器发送一个数据包
  + 心跳包看成一个协议
    + 应用层协议
  + 判断网络是否断开
    + 有多个连续的心跳包没收到/没有回复
    + 关闭通信的套接字
  + 重连
    + 重新初始套接字
    + 继续发送心跳包
+ **乒乓包**
  + 比心跳包携带的数据多一些
  + 除了知道连接是否存在，还能获取一些信息
+ **心跳包的实现**--*看一下项目里的代码*

#### 17、epoll反应堆模型main函数（20200424）

+ [epoll_loop.c]的源码学习
+ **看代码时，先不要追求细节，要先理清流程**。

#### 18、epoll反应堆模型监听套接字初始函数（20200425）

#### 19、epoll反应堆模型acceptconn函数

### day15、libevent

### day16、xml json

