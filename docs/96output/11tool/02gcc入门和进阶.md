## gcc入门和进阶

+ ref
  + [gcc online doc](https://gcc.gnu.org/onlinedocs/) ， 官网
  + 《高级C/C++编译技术》，*自有，看过一些，做过一些纸质笔记，准备电子化一下*
  + 《深入分析GCC》，*自有，但没有看过*，分析的是4.4.0

### 一、gcc简单示例&全家桶

#### 1、gcc简单示例

+ `gcc -o hello hello.c`

#### 2、gcc全家桶

+ 编译器（*一般用前2个*）
  + g++，编译C++
  + gcc，编译C
  + objc（object-c）、objc++（object++）、gnat（ada）、gfortran（Fortran）、gcj（java）
+ 辅助工具（*一般用前3个*）
  + ld，链接器
  + gdb，调试器
  + make，构建工具
  + ar，库文件生成器
  + as，汇编器
  + gprof，性能分析
  + libtool，库管理工具

### 二、编译背景知识介绍

+ ref
  + 《高级C/C++编译技术》chap2、程序生命周期阶段基础
+ 心得
  + *一般网上都直接说4步，我更喜欢书上说的2大节，第1大节里包含3个阶段*
  + **因为gcc分成编译（-c）、链接（-l）2步**

#### 1、传统的编译阶段（分为三步）

+ 1.1、预处理，宏展开，条件编译，头文件，**生成中间文件**
+ 1.2、编译，**把中间文件转换成汇编语言**，`.s`或`.asm`的格式
+ 1.3、汇编，**汇编语言转换为机器码**，`.o`或`.obj`

#### 2、链接

+ 2.1、链接，**将目标文件和库文件合并成可执行文件**，链接的过程中包含了**重定位、解析引用**这些阶段
  + *这是最后一步，但一般不包含在编译阶段*
  + *现代编译器，可能会有静态分析、代码优化 这些步骤啥的*

### 三、gcc必掌握参数

+ 1、所有这些，都可以在`CFLAG`这个变量里，`CFLAG += -DENABLE`的方式来让其加入进来
+ 2、之前不太熟悉的用法
  + `-D`
  + `-pthread`
+ 3、动态链接库，**可以用2阶段来理解，但2个参数可以放在一起**
  + `-fPIC `，生成**位置无关的目标代码**（Position Independent Code）
    + 是一种可在内存中的任意位置加载和执行的代码，适用于共享对象（动态库）
  + `-shared`，把位置无关的目标代码**链接为动态库文件**
  + **可以放在一起执行**，`gcc -shared -fPIC file1.c file2.c -o libmylibrary.so`

#### 3.1、-o ` <output>`

+ 指定输出**可执行文件**

#### 3.2、-c

+ 编译，**生成目标文件**，`.o`那种

#### 3.3、-g

+ 生成**调试信息**

#### 3.4、`-I <directory>`

+ 大写`I`，**指定，包含头文件的目录**，还可以多个`-I`来指定**多个目录**

#### 3.5、-L` <directory>`

+ `-L`指定库文件的搜索路径，多个`-L`指定多个目录

#### 3.6、-l`<library>`

+ 小写l，link，**链接**指定库文件

#### 3.7、-D`<macro>`，-U`<macro>`

+ **定义**预处理宏，`-U`取消定义，**分别代表`#define`和`#undef`预处理指令**
+ 代码块中含有`#ifdef ENABLE {code block} #endif`，`-DENABLE `定义了ENABLE宏
+ *这个用得少，要特意记一下*
+ *自己当时有过疑问*，Q1：代码中定义了宏，那么Makefile中如何启用这个宏

#### 3.8、-std=`<standard>`

+ 指定要使用的语言标准，`-std=c11`或者`-std=c++11`

#### 3.9、-Wall【Waring all】

+ 开启所有常见的警告信息

#### 3.10、-Werror【Waring error】

+ 将警告视为错误，即将警告信息转化为编译错误

#### 3.11、-O

+ 优化选项，**后面可以跟一个数字或字母**，表示**不同的优化级别**
  + o0，关闭优化
  + o1，基本的优化，比如**删除冗余代码**
  + o2，更高级别优化，比如**函数内联，循环展开**
  + o3，最高级别优化
  + og，调试优化
  + os，优化代码大小

#### 3.11、`-pthread`多线程库链接，与`-lpthread`区别

+ `-pthread`
  + 这个选项其实是**2个操作（编译和链接）**
  + 这里有个**编译**过程，
+ `-lpthread`
  + 只有一个**显式链接**的操作，没有编译

### 四、动态库与静态库

+ 0
  + **两者都用在编译和链接时，可重用**上，目录的答案都来自AI，*还没跟ref中的书对应上*
+ ref
  + 《高级C/C++编译技术》chap4重用，chap5静态库，chap6动态库-基础篇

#### 4.1、两者区别

+ 静态库
  + 静态库是一组已经编译好的目标文件（通常是以`.a`为扩展名）
  + 静态库在链接时被静态地链接到程序中，使得程序在运行时不需要依赖外部的库文件
  + 使用静态库可以使得程序更加独立和可移植，但会**增加可执行文件的大小**
  + 在使用静态库时，需要在编译和链接命令中**显式地指定静态库文件**
+ 动态库
  + 动态库是一个独立的文件（通常是以`.so`为扩展名），其中包含了编译好的目标代码。
  + 在编译程序时，只会在可执行文件中包含动态库的引用信息，而不是实际的代码。
  + 在程序运行时，操作系统会根据引用信息加载动态库，并将其映射到进程的地址空间中。
  + 多个程序可以共享同一个动态库的实例，节省内存空间。
  + 动态库的更新和升级更加灵活，不需要重新编译整个程序。
  + 使用动态库时，需要在编译和链接命令中指定动态库的名称，以及在运行时确保动态库能够被系统找到。

#### 4.2、gcc生成静态库&使用

+ 1、编译源代码文件为目标文件（`.o`），

  ```shell
  gcc -c file1.c -o file1.o
  gcc -c file2.c -o file2.o
  ```

+ 2、将所有目标文件打包成静态库文件（`.a`），**用ar命令**，`ar rcs libmylibrary.a file1.o file2.o`
+ 3、使用静态库文件，`gcc main.c -L/path/to/library -lmylibrary -o myprogram`

#### 4.3、gcc生成动态库&使用

+ 1、编译源代码文件为位置无关的目标文件（`.o`）。使用 `-fPIC` 选项编译源代码，生成位置无关的目标文件。

  ```shell
  gcc -c -fPIC file1.c -o file1.o
  gcc -c -fPIC file2.c -o file2.o
  ```

+ 2、将所有位置无关的目标文件链接为动态库文件（`.so`），`gcc -shared file1.o file2.o -o libmylibrary.so`
+ 3、使用动态库文件，`gcc main.c -L/path/to/library -lmylibrary -o myprogram`
+ 4、**使用动态库时，需要确保系统能够正确地找到动态库文件**。
  + 4.1、设置`LD_LIBRARY_PATH` 环境变量
    + 1、当前用户的话，`~/.bashrc`
    + 2、系统都有效的话，`/etc/profile`
    + 3、只有当前窗口有效的话，`export LD_LIBRARY_PATH=./`，*这个用得比较多，一般窗口关掉了，又得重新导一下*
    + 4、`/etc/ld.so.cache`，*这个没怎么用过*
  + 4.2、将动态库文件复制到系统的标准库路径中（如 `/usr/lib`）
+ 5、**动态库的验证**
  + `ldd <file>`
    + file可以是**动态库**，也可以是**可执行文件**
  + -v，显示详细的依赖信息，包括版本号和符号表
  + -u，仅显示未使用的直接依赖项
  + -r，显示重定位信息
  + -d，显示所需的共享对象名称，但不执行依赖项检查

### 五、其它命令

#### 5.1、GCC默认头文件搜索路径

+ linux下，`echo | gcc -v -x -c -E-;`
+ win下，`gcc<filename> -v;`

### 六、

### 最后

#### 履历

+ 0.1版，init
  + 2024-01-05花了2个cubi整理了一下，至少基础的够用了