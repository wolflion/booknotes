<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>《操作系统导论》 - lionel的技术笔记</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u300a\u64cd\u4f5c\u7cfb\u7edf\u5bfc\u8bba\u300b";
        var mkdocs_page_input_path = "408\\\u64cd\u4f5c\u7cfb\u7edf\u5bfc\u8bba.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> lionel的技术笔记
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../01daily/">daily</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">C++</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/effectiveC%2B%2B/">《Effective C++》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/EffectiveSTL/">《Effective STL》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">基础知识</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">《操作系统导论》</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#chap1">chap1、关于本书的对话</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap2">chap2、操作系统介绍</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#21cpu">2.1、虚拟化CPU</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#22">2.2、虚拟化内存</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#23">2.3、并发</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#24">2.4、持久性</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#25">2.5、设计目标</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#26">2.6、简单历史</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_2">早期操作系统：只是一些库</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_3">超越库：保护</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_4">多道程序时代</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_5">摩登时代</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#27">2.7、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap3">chap3、关于虚拟化的对话</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap4">chap4、抽象：进程</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#41">4.1、抽象：进程</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#42api">4.2、进程API</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#43">4.3、进程创建：更多细节</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#44">4.4、进程状态</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#45">4.5、数据结构</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#46">4.6、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap5api">chap5、插叙：进程API</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#51fork">5.1、fork()系统调用</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#52wait">5.2、wait()系统调用</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#53exec">5.3、最后是exec()系统调用</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#54api">5.4、为什么这样设计API</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#55api">5.5、其他API</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#56">5.6、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap6">chap6、机制：受限直接执行</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap7">chap7、进程调度：介绍</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap8">chap8、调度：多级反馈队列</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap9">chap9、调度：比例份额</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap10">chap10、多处理器调度（高级）</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap11cpu">chap11、关于CPU虚拟化的总结对话</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap12">chap12、关于内存虚拟化的对话</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap13">chap13、抽象:地址空间</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#131">13.1、早期系统</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#132">13.2、多道程序和时分共享</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#133">13.3、地址空间</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#134">13.4、目标</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#135">13.5、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap14api">chap14、插叙：内存操作API</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#141">14.1、内存类型</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#142malloc">14.2、malloc()调用</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#143free">14.3、free()调用</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#144">14.4、常见错误</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#145">14.5、底层操作系统支持</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#146">14.6、其他调用</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#147">14.7、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap15">chap15、机制：地址转换</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#0">0、</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#151">15.1、假设</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#152">15.2、一个例子</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#153">15.3、动态（基于硬件）重定位</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#154">15.4、硬件支持：总结</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#155">15.5、操作系统的问题</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#156">15.6、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap16">chap16、分段</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#0_1">0、</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#161">16.1、分段：泛化的基址/界限</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#162">16.2、我们引用哪个段</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#163">16.3、栈怎么办</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#164">16.4、支持共享</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#165">16.5、细粒度与粗粒度的分段</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#166">16.6、操作系统支持</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#167">16.7、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap17">chap17、空闲空间管理</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#171">17.1、假设</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#172">17.2、底层机制</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#173">17.3、基本策略</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#174">17.4、其他方式</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#175">17.5、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap18">chap18、分页：介绍</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#181">18.1、一个简单的例子</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#182">18.2、页表存在哪里</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#183">18.3、列表中究竟有什么</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#184">18.4、分页：也很慢</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#185">18.5、内存追踪</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#186">18.6、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap19tlb">chap19、分页：快速地址转换（TLB）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#191tlb">19.1、TLB的基本算法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#192">19.2、示例：访问数组</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#193tlb">19.3、谁来处理TLB未命中</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#194tlb">19.4、TLB的内容</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#195tlb">19.5、上下文切换时对TLB的处理</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#196tlb">19.6、TLB替换策略</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#197tlb">19.7、实际系统的TLB表项</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap20">chap20、分页：较小的表</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#201">20.1、简单的解决方案：更大的页</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#202">20.2、混合方法：分页和分段</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#203">20.3、多级页表</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_6">详细的多级示例</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_7">超过两级</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#tlb">地址转换过程：记住TLB</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#204">20.4、反向页表</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#205">20.5、将页表交换到磁盘</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#206">20.6、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap21">chap21、超越物理内存：机制</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#211">21.1、交换空间</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#212">21.2、存在位</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#213">21.3、页错误</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#214">21.4、内存满了怎么办</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#215">21.5、页错误处理流程</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#216">21.6、交换何时真正发生</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#217">21.7、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap22">chap22、超越物理内存：策略</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#221">22.1、缓存管理</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#222">22.2、最优替换策略</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#223fifo">22.3、简单策略：FIFO</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#224">22.4、另一简单策略：随机</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#225lru">22.5、利用历史数据：LRU</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#226">22.6、工作负载示例</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#227">22.7、实现基于历史信息的算法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#228lru">22.8、近似LRU</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#229">22.9、考虑脏页</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2210">22.10、其他虚拟内存策略</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2211">22.11、抖动</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2212">22.12、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap23vaxvms">chap23、VAX/VMS虚拟内存系统</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#231">23.1、背景</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#232">23.2、内存管理硬件</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#233">23.3、一个真实的地址空间</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#234">23.4、页替换</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#fifo">分段FIFO</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_8">页聚集</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#235">23.5、其他漂亮的虚拟内存技巧</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#236">23.6、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap24">chap24、内存虚拟化总结对话</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#chap25">chap25、并发的对话</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#chap26">chap26、并发：简介</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#263">26.3、问题的核心：自由安排</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#264">26.4、原子性</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#chap27api">chap27、插曲：线程API</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#271">27.1、线程创建</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#272">27.2、线程完成</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#273">27.3、锁</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#274">27.4、条件变量</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#275">27.5、编译和运行</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#276">27.6、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#chap28">chap28、锁</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#281">28.1、锁的基本思想</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#282pthread">28.2、pthread锁</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#283">28.3、实现一个锁</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#284">28.4、评价锁</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#285">28.5、控制中断</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#286">28.6、测试并设置指令（原子交换）</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#287">28.7、实现可用的自旋锁</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#288">28.8、评价自旋锁</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#289">28.9、比较并交换</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2810">28.10、链接的加载和条件式存储指令</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2811">28.11、获取并增加</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2812">28.12、自旋过多：怎么办</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2813">28.13、简单方法：让出来吧，宝贝</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2814">28.14、使用队列：休眠替代自旋</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2815">28.15、不同操作系统，不同实现</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2816">28.16、两阶段锁</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2817">28.17、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#chap29">chap29、基于锁的并发数据结构</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#291">29.1、并发计数器</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#292">29.2、并发链表</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#293">29.3、并发队列</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#294">29.4、并发散列表</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#295">29.5、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#chap30">chap30、条件变量</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#301">30.1、定义和程序</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#302">30.2、生产者/消费者（有界缓冲区）问题</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#303">30.3、覆盖条件</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#chap31">chap31、信号量</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#311">31.1、信号量的含义</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#312">31.2、二值信号量（锁）</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#313">31.3、信号量用作条件变量</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#314">31.4、生产者/消费者（有界缓冲区）问题</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#315-">31.5、读者-写者锁</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#316">31.6、哲学家就餐问题</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#317">31.7、如何实现信号量</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#318">31.8、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#chap32">chap32、常见并发问题</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#321">32.1、有哪些类型的缺陷</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#322">32.2、非死锁缺陷</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#323">32.3、死锁缺陷</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#324">32.4、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#chap33">chap33、基于事件的并发（进阶）</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#331">33.1、基本想法：事件循环</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#332apiselectpoll">33.2、重要API：select()（或poll()）</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#333select">33.3、使用select()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#334">33.4、为何更简单？无须锁</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#335">33.5、一个问题：阻塞系统调用</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#336io">33.6、解决方案：异步I/O</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#337">33.7、另一个问题：状态管理</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#338">33.8、什么事情仍然很难</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#chap34">chap34、并发的总结对话</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_9"></a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#chap35">chap35、关于持久性的对话</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网络编程</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">《TCP/IP网络编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">《Linux高性能服务器编程》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">文件系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/Linux%E5%86%85%E6%A0%B8%E6%8E%A2%E7%A7%98/">《Linux内核探秘》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《文件系统技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">《存储技术原理分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">存储</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../12storage/ceph%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《ceph设计原理与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">内核</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《Linux内核设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/">《深入Linux设备驱动程序内核机制》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">《深入理解Linux虚拟内存管理》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">刷题</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../91leetcode/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/">《剑指offer专项突破》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网课</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/01Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/">《Linux高并发网络编程开发》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/%E4%BE%AF%E6%8D%B7/%E4%BE%AF%E6%8D%B7C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8660%E8%AE%B2/">《侯捷C++内存管理60讲》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/11NJU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">《NJU算法设计与分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">英语专</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../60English/00794%E7%BB%BC%E5%90%88%E8%8B%B1%E8%AF%AD%E4%B8%80%E4%B8%8A/">《综合英语(一)上》</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">lionel的技术笔记</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>基础知识 &raquo;</li>
      <li>《操作系统导论》</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h2 id="_1">《操作系统导论》<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<ul>
<li>Part1、虚拟化<ul>
<li>虚拟化CPU（3-11）</li>
<li>虚拟化内存（12-24）</li>
</ul>
</li>
<li>PartII：Concurrency并发（25-34）</li>
<li>Part3、持久性（35-）</li>
</ul>
<h3 id="chap1">chap1、关于本书的对话<a class="headerlink" href="#chap1" title="Permanent link">&para;</a></h3>
<h3 id="chap2">chap2、操作系统介绍<a class="headerlink" href="#chap2" title="Permanent link">&para;</a></h3>
<h4 id="21cpu">2.1、虚拟化CPU<a class="headerlink" href="#21cpu" title="Permanent link">&para;</a></h4>
<h4 id="22">2.2、虚拟化内存<a class="headerlink" href="#22" title="Permanent link">&para;</a></h4>
<h4 id="23">2.3、并发<a class="headerlink" href="#23" title="Permanent link">&para;</a></h4>
<h4 id="24">2.4、持久性<a class="headerlink" href="#24" title="Permanent link">&para;</a></h4>
<h4 id="25">2.5、设计目标<a class="headerlink" href="#25" title="Permanent link">&para;</a></h4>
<h4 id="26">2.6、简单历史<a class="headerlink" href="#26" title="Permanent link">&para;</a></h4>
<h5 id="_2">早期操作系统：只是一些库<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h5>
<h5 id="_3">超越库：保护<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h5>
<h5 id="_4">多道程序时代<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h5>
<h5 id="_5">摩登时代<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h5>
<h4 id="27">2.7、小结<a class="headerlink" href="#27" title="Permanent link">&para;</a></h4>
<h3 id="chap3">chap3、关于虚拟化的对话<a class="headerlink" href="#chap3" title="Permanent link">&para;</a></h3>
<h3 id="chap4">chap4、抽象：进程<a class="headerlink" href="#chap4" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>进程，就是运行中的程序</strong></li>
</ul>
<ul>
<li>关键问题：<strong>如何提供有许多CPU的假象？</strong><ul>
<li>时分共享（time sharing）CPU技术</li>
</ul>
</li>
<li><strong>机制</strong>（mechanism）：低级机制，<strong>是一些低级方法或协议，实现了所需的功能</strong></li>
<li><strong>策略</strong>：智能，<strong>在操作系统内做出某种决定的算法</strong></li>
</ul>
<h4 id="41">4.1、抽象：进程<a class="headerlink" href="#41" title="Permanent link">&para;</a></h4>
<ul>
<li>操作系统为正在运行的程序提供的抽象，就是<strong>所谓的进程（process）</strong></li>
</ul>
<h4 id="42api">4.2、进程API<a class="headerlink" href="#42api" title="Permanent link">&para;</a></h4>
<ul>
<li>创建</li>
<li>销毁</li>
<li>等待</li>
<li>其他控制</li>
<li>状态</li>
</ul>
<h4 id="43">4.3、进程创建：更多细节<a class="headerlink" href="#43" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>程序如何转化为进程，也就是说，OS如何启动并运行一个程序？进程创建实际如何进行？</strong><ul>
<li>第一件事是将代码和所有静态数据加载到内在中，加载到进程的地址空间中</li>
<li>创建和初始化栈以及执行与I/O设置相关的其他工作</li>
<li>启动程序，即main()，跳转到main()例程，OS将CPU的控制权转移到新创建的进程中，从而程序开始执行</li>
</ul>
</li>
</ul>
<h4 id="44">4.4、进程状态<a class="headerlink" href="#44" title="Permanent link">&para;</a></h4>
<ul>
<li>运行</li>
<li>就绪</li>
<li>阻塞</li>
</ul>
<h4 id="45">4.5、数据结构<a class="headerlink" href="#45" title="Permanent link">&para;</a></h4>
<ul>
<li><code>struct context{};</code></li>
</ul>
<ul>
<li><code>struct proc{};</code></li>
</ul>
<h4 id="46">4.6、小结<a class="headerlink" href="#46" title="Permanent link">&para;</a></h4>
<ul>
<li>实现进程所需的低级机制和以智能方式调度这些进程所需的高级策略</li>
</ul>
<h3 id="chap5api">chap5、插叙：进程API<a class="headerlink" href="#chap5api" title="Permanent link">&para;</a></h3>
<h4 id="51fork">5.1、fork()系统调用<a class="headerlink" href="#51fork" title="Permanent link">&para;</a></h4>
<h4 id="52wait">5.2、wait()系统调用<a class="headerlink" href="#52wait" title="Permanent link">&para;</a></h4>
<h4 id="53exec">5.3、最后是exec()系统调用<a class="headerlink" href="#53exec" title="Permanent link">&para;</a></h4>
<h4 id="54api">5.4、为什么这样设计API<a class="headerlink" href="#54api" title="Permanent link">&para;</a></h4>
<ul>
<li>分享fork()和exec()的做法，<strong>给了shell在fork之后exec之前运行代码的机会</strong></li>
</ul>
<h4 id="55api">5.5、其他API<a class="headerlink" href="#55api" title="Permanent link">&para;</a></h4>
<ul>
<li><code>kill()</code></li>
</ul>
<h4 id="56">5.6、小结<a class="headerlink" href="#56" title="Permanent link">&para;</a></h4>
<h3 id="chap6">chap6、机制：受限直接执行<a class="headerlink" href="#chap6" title="Permanent link">&para;</a></h3>
<p>6.1、基本技巧：受限直接执行</p>
<p>6.2、问题1：受限制的操作</p>
<p>6.3、问题2：在进程之间切换</p>
<p>6.4、担心并发吗</p>
<h3 id="chap7">chap7、进程调度：介绍<a class="headerlink" href="#chap7" title="Permanent link">&para;</a></h3>
<p>7.1、工作负载假设</p>
<p>7.2、调度指标</p>
<p>7.3、先进先出（FIFO）</p>
<p>7.4、最短任务优先（SJF）</p>
<p>7.5、最短完成时间优先（STCF）</p>
<p>7.6、新度量指标：响应时间</p>
<p>7.7、轮转</p>
<p>7.8、结合I/O</p>
<p>7.9、无法预知</p>
<h3 id="chap8">chap8、调度：多级反馈队列<a class="headerlink" href="#chap8" title="Permanent link">&para;</a></h3>
<p>8.1、MLFQ：基本规则</p>
<p>8.2、尝试1：如何改变优先级</p>
<p>8.3、尝试2：提升优先级</p>
<p>8.4、尝试3：更好的计时方式</p>
<p>8.5、MLFQ：调优及其他问题</p>
<p>8.6、MLFQ：小结</p>
<h3 id="chap9">chap9、调度：比例份额<a class="headerlink" href="#chap9" title="Permanent link">&para;</a></h3>
<p>9.1、基本概念：彩票数表示份额</p>
<p>9.2、彩票机制</p>
<p>9.3、实现</p>
<p>9.4、一个例子</p>
<p>9.5、如何分配彩票</p>
<p>9.6、为什么不是确定的</p>
<p>9.7、小结</p>
<h3 id="chap10">chap10、多处理器调度（高级）<a class="headerlink" href="#chap10" title="Permanent link">&para;</a></h3>
<p>10.1、背景：多处理架构</p>
<p>10.2、别忘了同步</p>
<p>10.3、最后一个问题：缓存亲和度</p>
<p>10.4、单队列调度</p>
<p>10.5、多队列调度</p>
<p>10.6、Linux多处理器调度</p>
<p>10.7、小结</p>
<h3 id="chap11cpu">chap11、关于CPU虚拟化的总结对话<a class="headerlink" href="#chap11cpu" title="Permanent link">&para;</a></h3>
<h3 id="chap12">chap12、关于内存虚拟化的对话<a class="headerlink" href="#chap12" title="Permanent link">&para;</a></h3>
<h3 id="chap13">chap13、抽象:地址空间<a class="headerlink" href="#chap13" title="Permanent link">&para;</a></h3>
<h4 id="131">13.1、早期系统<a class="headerlink" href="#131" title="Permanent link">&para;</a></h4>
<ul>
<li>没有抽象</li>
</ul>
<h4 id="132">13.2、多道程序和时分共享<a class="headerlink" href="#132" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>分时共享的方法</strong>，让一个进程单独占用全部内存一小段时间，然后停止它，并将它所有状态信息保存在磁盘上</li>
</ul>
<h4 id="133">13.3、地址空间<a class="headerlink" href="#133" title="Permanent link">&para;</a></h4>
<ul>
<li>address space，<strong>运行的程序看到的系统中的内存</strong></li>
</ul>
<h4 id="134">13.4、目标<a class="headerlink" href="#134" title="Permanent link">&para;</a></h4>
<ul>
<li>一个目标是<strong>透明</strong>，运行的程序不感知</li>
<li>另一个目标是<strong>效率</strong>，尽可能高效，有时不得不依赖硬件</li>
<li>第三个目标是<strong>保护</strong>，不受其他进程影响，操作系统本身也不会受进程影响</li>
</ul>
<h4 id="135">13.5、小结<a class="headerlink" href="#135" title="Permanent link">&para;</a></h4>
<h3 id="chap14api">chap14、插叙：内存操作API<a class="headerlink" href="#chap14api" title="Permanent link">&para;</a></h3>
<h4 id="141">14.1、内存类型<a class="headerlink" href="#141" title="Permanent link">&para;</a></h4>
<ul>
<li>栈内存，由编译器隐式管理</li>
<li>堆内存，程序员显式调用</li>
</ul>
<h4 id="142malloc">14.2、malloc()调用<a class="headerlink" href="#142malloc" title="Permanent link">&para;</a></h4>
<h4 id="143free">14.3、free()调用<a class="headerlink" href="#143free" title="Permanent link">&para;</a></h4>
<h4 id="144">14.4、常见错误<a class="headerlink" href="#144" title="Permanent link">&para;</a></h4>
<ul>
<li>忘记分配内存</li>
<li>没有分配足够的内存</li>
<li>忘记释放内存</li>
<li>在用完之前释放内存</li>
<li>反复释放内存</li>
<li>错误地调用free()</li>
<li>忘记初始化分配的内存</li>
<li>小结<ul>
<li>利用<code>purify</code>和<code>valgrind</code>工具</li>
</ul>
</li>
</ul>
<h4 id="145">14.5、底层操作系统支持<a class="headerlink" href="#145" title="Permanent link">&para;</a></h4>
<ul>
<li>malloc和free是库调用，不是系统调用，<code>brk()</code>或<code>sbrk()</code>才是系统调用。</li>
<li><code>mmap()</code>调用从操作系统获取内存</li>
</ul>
<h4 id="146">14.6、其他调用<a class="headerlink" href="#146" title="Permanent link">&para;</a></h4>
<ul>
<li><code>calloc()</code>和<code>realloc()</code></li>
</ul>
<h4 id="147">14.7、小结<a class="headerlink" href="#147" title="Permanent link">&para;</a></h4>
<h3 id="chap15">chap15、机制：地址转换<a class="headerlink" href="#chap15" title="Permanent link">&para;</a></h3>
<h4 id="0">0、<a class="headerlink" href="#0" title="Permanent link">&para;</a></h4>
<h4 id="151">15.1、假设<a class="headerlink" href="#151" title="Permanent link">&para;</a></h4>
<ul>
<li>先假设用户的地址空间必须连续地放在物理内存中</li>
<li>假设每个地址空间大小完全一样</li>
</ul>
<h4 id="152">15.2、一个例子<a class="headerlink" href="#152" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>理解地址转换需要什么</strong></li>
</ul>
<h4 id="153">15.3、动态（基于硬件）重定位<a class="headerlink" href="#153" title="Permanent link">&para;</a></h4>
<ul>
<li>基址加虚拟地址（可以看作是地址空间的偏移量）的方式，很容易得到物理地址。<strong>虚拟地址“过大”或者为负数时，会导致异常</strong></li>
</ul>
<h4 id="154">15.4、硬件支持：总结<a class="headerlink" href="#154" title="Permanent link">&para;</a></h4>
<ul>
<li>特权模式（privileged mode）也叫<strong>内核模式</strong></li>
<li>用户模式</li>
</ul>
<h4 id="155">15.5、操作系统的问题<a class="headerlink" href="#155" title="Permanent link">&para;</a></h4>
<h4 id="156">15.6、小结<a class="headerlink" href="#156" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>地址转换（address translation），扩展了受限直接访问的概念</strong></li>
<li>利用地址转换，操作系统可以控制进程的所有内存访问，确保访问在地址空间的界限内</li>
<li><strong>避免内存碎片</strong>，得到了<strong>分段（segmentation）的概念</strong></li>
</ul>
<h3 id="chap16">chap16、分段<a class="headerlink" href="#chap16" title="Permanent link">&para;</a></h3>
<h4 id="0_1">0、<a class="headerlink" href="#0_1" title="Permanent link">&para;</a></h4>
<ul>
<li>之前，一直假设把所有进程的地址空间完整地加载到内存中。</li>
<li><strong>怎样支持大地址空间</strong></li>
</ul>
<h4 id="161">16.1、分段：泛化的基址/界限<a class="headerlink" href="#161" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>在典型的地址空间里有3个逻辑不同的段：代码、栈和堆</strong></li>
<li>分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中的未使用部分占用物理内存</li>
</ul>
<h4 id="162">16.2、我们引用哪个段<a class="headerlink" href="#162" title="Permanent link">&para;</a></h4>
<ul>
<li>硬件在地址转换时使用段寄存器。<strong>它如何知道段内的偏移量，以及地址引用了哪个段？</strong></li>
</ul>
<h4 id="163">16.3、栈怎么办<a class="headerlink" href="#163" title="Permanent link">&para;</a></h4>
<h4 id="164">16.4、支持共享<a class="headerlink" href="#164" title="Permanent link">&para;</a></h4>
<h4 id="165">16.5、细粒度与粗粒度的分段<a class="headerlink" href="#165" title="Permanent link">&para;</a></h4>
<h4 id="166">16.6、操作系统支持<a class="headerlink" href="#166" title="Permanent link">&para;</a></h4>
<ul>
<li>分段带来的问题:<ul>
<li>第一个是，<strong>操作系统在上下文切换时应该做什么？</strong>各个段寄存器中的内容必须保存和恢复</li>
<li>第二个是，<strong>管理物理内存的空闲空间</strong></li>
</ul>
</li>
</ul>
<h4 id="167">16.7、小结<a class="headerlink" href="#167" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>分段的好处是：代码共享</strong></li>
</ul>
<h3 id="chap17">chap17、空闲空间管理<a class="headerlink" href="#chap17" title="Permanent link">&para;</a></h3>
<h4 id="171">17.1、假设<a class="headerlink" href="#171" title="Permanent link">&para;</a></h4>
<ul>
<li>在堆上管理空闲空间的数据结构通常称为空闲列表（free list）。<strong>该结构包含了管理内存区域中所有空闲块的引用</strong>。</li>
</ul>
<h4 id="172">17.2、底层机制<a class="headerlink" href="#172" title="Permanent link">&para;</a></h4>
<h4 id="173">17.3、基本策略<a class="headerlink" href="#173" title="Permanent link">&para;</a></h4>
<ul>
<li>最优匹配（best fit）</li>
<li>最差匹配（worst fit）</li>
<li>首次匹配（first fit）</li>
<li>下次匹配（next fit）</li>
<li>例子</li>
</ul>
<h4 id="174">17.4、其他方式<a class="headerlink" href="#174" title="Permanent link">&para;</a></h4>
<ul>
<li>分离空闲列表（segregated list）<ul>
<li><strong>如果某个应用程序经常申请一种（或几种）大小的内存空间，那就用一个独立的列表，只管理这样大小的对象</strong>。</li>
</ul>
</li>
<li>伙伴系统<ul>
<li>2的整数次幂大小的空闲块</li>
</ul>
</li>
<li>其他想法</li>
</ul>
<h4 id="175">17.5、小结<a class="headerlink" href="#175" title="Permanent link">&para;</a></h4>
<ul>
<li>讨论了最基本的内存分配程序形式。</li>
</ul>
<h3 id="chap18">chap18、分页：介绍<a class="headerlink" href="#chap18" title="Permanent link">&para;</a></h3>
<ul>
<li>关键问题：<strong>如何通过页来实现虚拟内存</strong></li>
</ul>
<h4 id="181">18.1、一个简单的例子<a class="headerlink" href="#181" title="Permanent link">&para;</a></h4>
<ul>
<li>操作系统通常为每个进程保存一个数据结构，称为<strong>页表</strong>（page table），主要作用是：<strong>为地址空间的每个虚拟页面保存地址转换（address translation），从而让我们知道每个页在物理内存中的位置</strong>。</li>
</ul>
<h4 id="182">18.2、页表存在哪里<a class="headerlink" href="#182" title="Permanent link">&para;</a></h4>
<h4 id="183">18.3、列表中究竟有什么<a class="headerlink" href="#183" title="Permanent link">&para;</a></h4>
<h4 id="184">18.4、分页：也很慢<a class="headerlink" href="#184" title="Permanent link">&para;</a></h4>
<h4 id="185">18.5、内存追踪<a class="headerlink" href="#185" title="Permanent link">&para;</a></h4>
<h4 id="186">18.6、小结<a class="headerlink" href="#186" title="Permanent link">&para;</a></h4>
<ul>
<li>分页（paging）比起分段有优点，<strong>不会导致外部碎片、非常灵活</strong></li>
<li>缺点：机器变慢和内存浪费</li>
</ul>
<h3 id="chap19tlb">chap19、分页：快速地址转换（TLB）<a class="headerlink" href="#chap19tlb" title="Permanent link">&para;</a></h3>
<h4 id="191tlb">19.1、TLB的基本算法<a class="headerlink" href="#191tlb" title="Permanent link">&para;</a></h4>
<h4 id="192">19.2、示例：访问数组<a class="headerlink" href="#192" title="Permanent link">&para;</a></h4>
<h4 id="193tlb">19.3、谁来处理TLB未命中<a class="headerlink" href="#193tlb" title="Permanent link">&para;</a></h4>
<h4 id="194tlb">19.4、TLB的内容<a class="headerlink" href="#194tlb" title="Permanent link">&para;</a></h4>
<ul>
<li>硬件TLB中的内容，典型的TLB有32项、64项或128项，<strong>并且是全相联的（fully associative）</strong></li>
</ul>
<h4 id="195tlb">19.5、上下文切换时对TLB的处理<a class="headerlink" href="#195tlb" title="Permanent link">&para;</a></h4>
<h4 id="196tlb">19.6、TLB替换策略<a class="headerlink" href="#196tlb" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>缓存策略</strong>（cache replacement）</li>
<li>关键问题：<strong>如何设计TLB替换策略</strong></li>
</ul>
<h4 id="197tlb">19.7、实际系统的TLB表项<a class="headerlink" href="#197tlb" title="Permanent link">&para;</a></h4>
<h3 id="chap20">chap20、分页：较小的表<a class="headerlink" href="#chap20" title="Permanent link">&para;</a></h3>
<ul>
<li>解决分页引入的第二个问题：<strong>页表太大，因而消耗的内存太多</strong></li>
<li>关键问题：<strong>如何让页表更小？</strong></li>
</ul>
<h4 id="201">20.1、简单的解决方案：更大的页<a class="headerlink" href="#201" title="Permanent link">&para;</a></h4>
<h4 id="202">20.2、混合方法：分页和分段<a class="headerlink" href="#202" title="Permanent link">&para;</a></h4>
<h4 id="203">20.3、多级页表<a class="headerlink" href="#203" title="Permanent link">&para;</a></h4>
<h5 id="_6">详细的多级示例<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h5>
<h5 id="_7">超过两级<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h5>
<h5 id="tlb">地址转换过程：记住TLB<a class="headerlink" href="#tlb" title="Permanent link">&para;</a></h5>
<h4 id="204">20.4、反向页表<a class="headerlink" href="#204" title="Permanent link">&para;</a></h4>
<h4 id="205">20.5、将页表交换到磁盘<a class="headerlink" href="#205" title="Permanent link">&para;</a></h4>
<h4 id="206">20.6、小结<a class="headerlink" href="#206" title="Permanent link">&para;</a></h4>
<ul>
<li>构建真正的页表，不一定只是线性数组，<strong>而是更复杂的数据结构</strong>。</li>
</ul>
<h3 id="chap21">chap21、超越物理内存：机制<a class="headerlink" href="#chap21" title="Permanent link">&para;</a></h3>
<ul>
<li>关键问题：<strong>如何超越物理内存</strong></li>
</ul>
<h4 id="211">21.1、交换空间<a class="headerlink" href="#211" title="Permanent link">&para;</a></h4>
<h4 id="212">21.2、存在位<a class="headerlink" href="#212" title="Permanent link">&para;</a></h4>
<h4 id="213">21.3、页错误<a class="headerlink" href="#213" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>为什么硬件不能处理页错误</strong></li>
</ul>
<h4 id="214">21.4、内存满了怎么办<a class="headerlink" href="#214" title="Permanent link">&para;</a></h4>
<ul>
<li>页交换策略</li>
</ul>
<h4 id="215">21.5、页错误处理流程<a class="headerlink" href="#215" title="Permanent link">&para;</a></h4>
<h4 id="216">21.6、交换何时真正发生<a class="headerlink" href="#216" title="Permanent link">&para;</a></h4>
<ul>
<li>为了保证有少量的空闲内存，大多数操作系统会设置高水位线（High Watermark，HW）和低水位线（Low Watermark，LW），来帮助决定何时从内存中清除页。</li>
</ul>
<h4 id="217">21.7、小结<a class="headerlink" href="#217" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>存在位</strong>（present bit），告诉我们页是不是在内存中</li>
</ul>
<h3 id="chap22">chap22、超越物理内存：策略<a class="headerlink" href="#chap22" title="Permanent link">&para;</a></h3>
<h4 id="221">22.1、缓存管理<a class="headerlink" href="#221" title="Permanent link">&para;</a></h4>
<h4 id="222">22.2、最优替换策略<a class="headerlink" href="#222" title="Permanent link">&para;</a></h4>
<h4 id="223fifo">22.3、简单策略：FIFO<a class="headerlink" href="#223fifo" title="Permanent link">&para;</a></h4>
<h4 id="224">22.4、另一简单策略：随机<a class="headerlink" href="#224" title="Permanent link">&para;</a></h4>
<h4 id="225lru">22.5、利用历史数据：LRU<a class="headerlink" href="#225lru" title="Permanent link">&para;</a></h4>
<h4 id="226">22.6、工作负载示例<a class="headerlink" href="#226" title="Permanent link">&para;</a></h4>
<h4 id="227">22.7、实现基于历史信息的算法<a class="headerlink" href="#227" title="Permanent link">&para;</a></h4>
<ul>
<li>关键问题：<strong>如何实现LRU替换策略</strong></li>
</ul>
<h4 id="228lru">22.8、近似LRU<a class="headerlink" href="#228lru" title="Permanent link">&para;</a></h4>
<h4 id="229">22.9、考虑脏页<a class="headerlink" href="#229" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>硬件应该包括一个修改位（modified bit）</strong></li>
</ul>
<h4 id="2210">22.10、其他虚拟内存策略<a class="headerlink" href="#2210" title="Permanent link">&para;</a></h4>
<h4 id="2211">22.11、抖动<a class="headerlink" href="#2211" title="Permanent link">&para;</a></h4>
<h4 id="2212">22.12、小结<a class="headerlink" href="#2212" title="Permanent link">&para;</a></h4>
<h3 id="chap23vaxvms">chap23、VAX/VMS虚拟内存系统<a class="headerlink" href="#chap23vaxvms" title="Permanent link">&para;</a></h3>
<h4 id="231">23.1、背景<a class="headerlink" href="#231" title="Permanent link">&para;</a></h4>
<h4 id="232">23.2、内存管理硬件<a class="headerlink" href="#232" title="Permanent link">&para;</a></h4>
<h4 id="233">23.3、一个真实的地址空间<a class="headerlink" href="#233" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>为什么空指针访问会导致段错误</strong>，硬件试图在TLB中查找VPN（这里是0），遇到TLB未命中。查询页表，并且发现VPN 0的条目被标记为无效。把控制权交给OS</li>
</ul>
<h4 id="234">23.4、页替换<a class="headerlink" href="#234" title="Permanent link">&para;</a></h4>
<h5 id="fifo">分段FIFO<a class="headerlink" href="#fifo" title="Permanent link">&para;</a></h5>
<h5 id="_8">页聚集<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h5>
<h4 id="235">23.5、其他漂亮的虚拟内存技巧<a class="headerlink" href="#235" title="Permanent link">&para;</a></h4>
<ul>
<li>VMS有另外两个现在成为标准和技巧：<strong>按需置零和写入时复制</strong></li>
</ul>
<h4 id="236">23.6、小结<a class="headerlink" href="#236" title="Permanent link">&para;</a></h4>
<h3 id="chap24">chap24、内存虚拟化总结对话<a class="headerlink" href="#chap24" title="Permanent link">&para;</a></h3>
<h4 id="chap25">chap25、并发的对话<a class="headerlink" href="#chap25" title="Permanent link">&para;</a></h4>
<ul>
<li>吃一个桃子？</li>
</ul>
<h4 id="chap26">chap26、并发：简介<a class="headerlink" href="#chap26" title="Permanent link">&para;</a></h4>
<h5 id="263">26.3、问题的核心：自由安排<a class="headerlink" href="#263" title="Permanent link">&para;</a></h5>
<h5 id="264">26.4、原子性<a class="headerlink" href="#264" title="Permanent link">&para;</a></h5>
<h4 id="chap27api">chap27、插曲：线程API<a class="headerlink" href="#chap27api" title="Permanent link">&para;</a></h4>
<h5 id="271">27.1、线程创建<a class="headerlink" href="#271" title="Permanent link">&para;</a></h5>
<h5 id="272">27.2、线程完成<a class="headerlink" href="#272" title="Permanent link">&para;</a></h5>
<ul>
<li>如果你想等待线程完成，会发生什么情况？你需要做一些特别的事情来等待完成。</li>
</ul>
<ul>
<li><code>pthread_join(pthread_t, )</code><ul>
<li>第1个参数，用于指定要等待的线程</li>
<li>第2个参数，指向你希望得到的返回值</li>
</ul>
</li>
</ul>
<h5 id="273">27.3、锁<a class="headerlink" href="#273" title="Permanent link">&para;</a></h5>
<ul>
<li>通过<strong>锁来互斥进入临界区</strong>的那些函数</li>
</ul>
<h5 id="274">27.4、条件变量<a class="headerlink" href="#274" title="Permanent link">&para;</a></h5>
<ul>
<li><strong>当线程之间必须发生某种信号时，如果一个线程在等待另一个线程继续执行某些操作</strong>，条件变量就很有用。</li>
<li><strong>要使用条件变量，必须另外有一个与此条件相关的锁</strong>。</li>
<li><code>int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);</code><strong>使调用线程进入休眠状态</strong>，因此等待其它线程发出信号，通常当程序中的某些内容发生变化时，现在正在休眠的线程可能会关心它。</li>
</ul>
<h5 id="275">27.5、编译和运行<a class="headerlink" href="#275" title="Permanent link">&para;</a></h5>
<ul>
<li>增加<code>-pthread</code>标记，例：<code>gcc -o main main.c -Wall -pthread</code></li>
</ul>
<h5 id="276">27.6、小结<a class="headerlink" href="#276" title="Permanent link">&para;</a></h5>
<ul>
<li><code>man -k pthread</code></li>
<li><strong>线程难的部分不是API，而是如何构建并发程序的棘手逻辑</strong>。</li>
</ul>
<h4 id="chap28">chap28、锁<a class="headerlink" href="#chap28" title="Permanent link">&para;</a></h4>
<h5 id="281">28.1、锁的基本思想<a class="headerlink" href="#281" title="Permanent link">&para;</a></h5>
<ul>
<li>锁为程序员提供了最小程度的调度控制。通过给临界区加锁，可以保证临界区内只有一个线程活跃。<strong>锁将原本由操作系统调度的混乱状态变得更为可控</strong>。</li>
</ul>
<pre class="highlight"><code class="language-c++">lock_t mutex;//some globally-allocated lock 'mutex'
...
lock(&amp;mutex);
balance = balance + 1;
unlock(&amp;mutex);</code></pre>
<h5 id="282pthread">28.2、pthread锁<a class="headerlink" href="#282pthread" title="Permanent link">&para;</a></h5>
<ul>
<li>POSIX库将锁称为<strong>互斥量（mutex）</strong>，因为它被用来提供线程之间的互斥。即当一个线程在临界区，它能够阻止其他线程进入直到本线程离开临界区。</li>
</ul>
<h5 id="283">28.3、实现一个锁<a class="headerlink" href="#283" title="Permanent link">&para;</a></h5>
<ul>
<li>怎样实现一个锁？</li>
<li><strong>我们需要硬件和操作系统的帮助来实现一个可用的锁</strong>。</li>
</ul>
<h5 id="284">28.4、评价锁<a class="headerlink" href="#284" title="Permanent link">&para;</a></h5>
<h5 id="285">28.5、控制中断<a class="headerlink" href="#285" title="Permanent link">&para;</a></h5>
<h5 id="286">28.6、测试并设置指令（原子交换）<a class="headerlink" href="#286" title="Permanent link">&para;</a></h5>
<h5 id="287">28.7、实现可用的自旋锁<a class="headerlink" href="#287" title="Permanent link">&para;</a></h5>
<h5 id="288">28.8、评价自旋锁<a class="headerlink" href="#288" title="Permanent link">&para;</a></h5>
<h5 id="289">28.9、比较并交换<a class="headerlink" href="#289" title="Permanent link">&para;</a></h5>
<h5 id="2810">28.10、链接的加载和条件式存储指令<a class="headerlink" href="#2810" title="Permanent link">&para;</a></h5>
<h5 id="2811">28.11、获取并增加<a class="headerlink" href="#2811" title="Permanent link">&para;</a></h5>
<h5 id="2812">28.12、自旋过多：怎么办<a class="headerlink" href="#2812" title="Permanent link">&para;</a></h5>
<h5 id="2813">28.13、简单方法：让出来吧，宝贝<a class="headerlink" href="#2813" title="Permanent link">&para;</a></h5>
<h5 id="2814">28.14、使用队列：休眠替代自旋<a class="headerlink" href="#2814" title="Permanent link">&para;</a></h5>
<h5 id="2815">28.15、不同操作系统，不同实现<a class="headerlink" href="#2815" title="Permanent link">&para;</a></h5>
<h5 id="2816">28.16、两阶段锁<a class="headerlink" href="#2816" title="Permanent link">&para;</a></h5>
<h5 id="2817">28.17、小结<a class="headerlink" href="#2817" title="Permanent link">&para;</a></h5>
<h4 id="chap29">chap29、基于锁的并发数据结构<a class="headerlink" href="#chap29" title="Permanent link">&para;</a></h4>
<h5 id="291">29.1、并发计数器<a class="headerlink" href="#291" title="Permanent link">&para;</a></h5>
<h5 id="292">29.2、并发链表<a class="headerlink" href="#292" title="Permanent link">&para;</a></h5>
<h5 id="293">29.3、并发队列<a class="headerlink" href="#293" title="Permanent link">&para;</a></h5>
<h5 id="294">29.4、并发散列表<a class="headerlink" href="#294" title="Permanent link">&para;</a></h5>
<h5 id="295">29.5、小结<a class="headerlink" href="#295" title="Permanent link">&para;</a></h5>
<h4 id="chap30">chap30、条件变量<a class="headerlink" href="#chap30" title="Permanent link">&para;</a></h4>
<h5 id="301">30.1、定义和程序<a class="headerlink" href="#301" title="Permanent link">&para;</a></h5>
<h5 id="302">30.2、生产者/消费者（有界缓冲区）问题<a class="headerlink" href="#302" title="Permanent link">&para;</a></h5>
<h5 id="303">30.3、覆盖条件<a class="headerlink" href="#303" title="Permanent link">&para;</a></h5>
<h4 id="chap31">chap31、信号量<a class="headerlink" href="#chap31" title="Permanent link">&para;</a></h4>
<h5 id="311">31.1、信号量的含义<a class="headerlink" href="#311" title="Permanent link">&para;</a></h5>
<h5 id="312">31.2、二值信号量（锁）<a class="headerlink" href="#312" title="Permanent link">&para;</a></h5>
<h5 id="313">31.3、信号量用作条件变量<a class="headerlink" href="#313" title="Permanent link">&para;</a></h5>
<h5 id="314">31.4、生产者/消费者（有界缓冲区）问题<a class="headerlink" href="#314" title="Permanent link">&para;</a></h5>
<h5 id="315-">31.5、读者-写者锁<a class="headerlink" href="#315-" title="Permanent link">&para;</a></h5>
<h5 id="316">31.6、哲学家就餐问题<a class="headerlink" href="#316" title="Permanent link">&para;</a></h5>
<h5 id="317">31.7、如何实现信号量<a class="headerlink" href="#317" title="Permanent link">&para;</a></h5>
<h5 id="318">31.8、小结<a class="headerlink" href="#318" title="Permanent link">&para;</a></h5>
<h4 id="chap32">chap32、常见并发问题<a class="headerlink" href="#chap32" title="Permanent link">&para;</a></h4>
<h5 id="321">32.1、有哪些类型的缺陷<a class="headerlink" href="#321" title="Permanent link">&para;</a></h5>
<h5 id="322">32.2、非死锁缺陷<a class="headerlink" href="#322" title="Permanent link">&para;</a></h5>
<h5 id="323">32.3、死锁缺陷<a class="headerlink" href="#323" title="Permanent link">&para;</a></h5>
<h5 id="324">32.4、小结<a class="headerlink" href="#324" title="Permanent link">&para;</a></h5>
<h4 id="chap33">chap33、基于事件的并发（进阶）<a class="headerlink" href="#chap33" title="Permanent link">&para;</a></h4>
<h5 id="331">33.1、基本想法：事件循环<a class="headerlink" href="#331" title="Permanent link">&para;</a></h5>
<h5 id="332apiselectpoll">33.2、重要API：select()（或poll()）<a class="headerlink" href="#332apiselectpoll" title="Permanent link">&para;</a></h5>
<h5 id="333select">33.3、使用select()<a class="headerlink" href="#333select" title="Permanent link">&para;</a></h5>
<h5 id="334">33.4、为何更简单？无须锁<a class="headerlink" href="#334" title="Permanent link">&para;</a></h5>
<h5 id="335">33.5、一个问题：阻塞系统调用<a class="headerlink" href="#335" title="Permanent link">&para;</a></h5>
<h5 id="336io">33.6、解决方案：异步I/O<a class="headerlink" href="#336io" title="Permanent link">&para;</a></h5>
<h5 id="337">33.7、另一个问题：状态管理<a class="headerlink" href="#337" title="Permanent link">&para;</a></h5>
<h5 id="338">33.8、什么事情仍然很难<a class="headerlink" href="#338" title="Permanent link">&para;</a></h5>
<h4 id="chap34">chap34、并发的总结对话<a class="headerlink" href="#chap34" title="Permanent link">&para;</a></h4>
<h3 id="_9"><a class="headerlink" href="#_9" title="Permanent link">&para;</a></h3>
<h4 id="chap35">chap35、关于持久性的对话<a class="headerlink" href="#chap35" title="Permanent link">&para;</a></h4>
<h2 id="_10">履历<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h2>
<ul>
<li>2022年27W（7.5-7.）看Part2并发的chap26，但习题没做和练习，只是有个概念</li>
</ul>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../21STL/EffectiveSTL/" class="btn btn-neutral float-left" title="《Effective STL》"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../../10network/TCPIP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="btn btn-neutral float-right" title="《TCP/IP网络编程》">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../../21STL/EffectiveSTL/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../../10network/TCPIP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
