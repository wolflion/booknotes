## 《Linux内核设计与实现》

### chap5、系统调用
#### 5.1、与内核通信
+ 系统调用在用户空间进程和硬件设备之间添加了一个中间层。**中间层**的3个作用：
#### 5.2、API、POSIX和C库
+ POSIX是个标准
+ C库：实现了Unix系统的主要API，包括标准C库函数和系统调用接口
+ 接口设计格言：**提供机制而不是策略**，*这个没懂，lionel*
#### 5.3、系统调用
##### 0、
+ 系统调用在出现错误的时候C库会把错误码写入errno全局变量。通过调用`perror`库函数，把该变量翻译成用户可以理解的错误字符串。
+ `SYSCALL_DEFINE0`-这个在2.6.18里没找到啊，直接在`/include/linux/syscalls.h`中定义了`asmlinkage long sys_getpid(void);`，实现怎么在time.c了呢？
	+ asmlinkage是个**编译指令**，通知编译器仅从栈中提取该函数的参数
	+ 返回值是long的原因，兼容32位和64位
	+ 系统调用的命名规则是`sys_`开头
##### 5.3.1、系统调用号
+ **进程不会提及系统调用的名称**，通过系统调用号来关联，**一旦分配就不会再有任何变更**
+ 所有已经注册过的系统调用的列表，存储在sys_call_table中。*2.6里搜了一下在arch/x86_64/kernel/syscall.c*
+ *问题1：何时删除系统调用号呢？ 问题2：系统调用号存在哪？*
+ 其它
	+ `sys_ni_syscall()`
##### 5.3.2、系统调用的性能
#### 5.4、系统调用处理程序
##### 0、
+ 通知内核的机制是靠**软中断**实现的：通过引发一个异常
+ x86系统上预定义的软中断是**中断号128，`int $0x80`指令**，名称叫`system_call()`
+ entry_64.S中用汇编编写
+ sysenter的指令
##### 5.4.1、指定恰当的系统调用
+ 在x86上，**系统调用号是通过eax寄存器传递给内核的**。*eax寄存器是啥？lionel，问题1，什么时候传给eax寄存器的，用什么方式传的？*
+ *表项是64位存放的，所以要乘4，不太懂啥意思，lionel*
##### 5.4.2、参数传递
+ x86-32系统上，**ebx，ecx，edx，esi和edi按照顺序存放前5个参数**。
#### 5.5、系统调用的实现
##### 5.5.1、实现系统调用
+ *通过思考这个过程，去想一下，日常的接口怎么设计？lionel*
##### 5.5.2、参数验证
+ `copy_from_user()`和`copy_to_user()`
+ 书上以`kernel/sys.c`中的`sys_reboot()`为例，说了些要注意的权限问题
+ `CAP_SYS_BOOT`，权限的定义在`/include/linux/capability.h`中，*以CAP开头，是因为capability.h的命名*
#### 5.6、系统调用上下文
##### 0、
+ *问题，为何可以休眠，是比较重要的呢*
##### 5.6.1、绑定一个系统调用的最后步骤
+ 注册
	+ 1、在系统调用表的最后加入一个表项，`entry.S`
	+ 2、支持各种体系结构，系统调用号都必须定义于`<asm/unistd.h>`
	+ 3、**系统调用必须被编译进内核映像（不能被编译成模块）**，放在`kernel/`下的一个相关文件就可以了，比如sys.c
##### 5.6.2、从用户空间访问系统调用
+ `_syscalln`，n的范围是0-6，表示**需要传递给系统调用的参数个数**。
+ *lionel，这个没具体看，想实践一下，怎么编进内核，怎么写了跟内核交互，系统调用*
##### 5.6.3、为什么不通过系统调用的方式实现
+ 系统调用有好处（创建容易且使用方便，性能高），但有问题：
+ 替代方法：（*不太懂*）
	+ 实现一个设备节点，并对此实现`read()`和`write()`
		+ 像信号量这样的某些接口
		+ 把增加的信息作为一个文件放在sysfs的合适位置

#### 5.7、小结

### chap6、内核数据结构

#### 6.1、链表
##### 0、
##### 6.1.1、单向链表和双向链表
##### 6.1.2、环形链表
##### 6.1.3、沿链表移动
+ **只能是线性移动**
##### 6.1.4、Linux内核中的实现
+ 0、
	+ **linux内核，将链表节点塞入数据结构，不是将数据结构塞入链表**。
+ 1、链表数据结构
	+ linux/list.h
+ 2、定义一个链表
+ 3、链表头
##### 6.1.5、操作链表
+ 0、
+ 1、向链表中增加一个节点
	+ `list_add()`
+ 2、从链表中删除一个节点
	+ `list_del()`
+ 3、移动和合并链表节点
	+ `list_move()`
	+ `list_move_tail()`
	+ `list_empty()`
##### 6.1.6、遍历链表
+ 0、
+ 1、
+ 2、
+ 3、反向遍历链表
	+ `list_for_each_entry_reverse()` 
+ 4、遍历的同时删除
	+ `list_for_each_entry_safe()`
+ 5、其它链表方法
#### 6.2、队列
##### 0、
+ `linux/kfifo.h`
##### 6.2.1、kfifo
+ kfifo对象维护了两个偏移量：入口偏移和出口偏移（**下一次出队列时的位置**）
+ enqueue
+ dequeue
##### 6.2.2、创建队列
+ 动态创建`kfifo_alloc()`
+ 静态创建
##### 6.2.3、推入队列数据
+ `kfifo_in()`
##### 6.2.4、摘取队列数据
+ `kfifo_out()`
##### 6.2.5、获取队列数据
+ `kfifo_size()`
##### 6.2.6、重置和撤销队列
+ `kfifo_reset()`
##### 6.2.7、队列使用举例
+ *未看，lionel*
#### 6.3、映射
##### 0、
##### 6.3.1、初始化一个idr
##### 6.3.2、分配一个新的UID
+ 第一步，告诉idr你需要分配新的UID，允许其在必要时调整后备树的大小
+ 第二步，才是真正请求新的UID
##### 6.3.3、查找UID
+ `idr_find`
##### 6.3.4、删除UID
+ `idr_move`
##### 6.3.5、撤销idr
+ `idr_destroy`
#### 6.4、二叉树
##### 6.4.1、二叉搜索树（BST）
##### 6.4.2、自平衡二叉搜索树
+ 1、红黑树
+ 2、rbtree
	+ linux/rbtree.h
	+ lib/rbtree.c
#### 6.5、数据结构以及选择
+ 遍历数据，就使用链表
+ 如果需要存储大量数据，并且检索迅速，那么红黑树最好
#### 6.6、算法复杂度
##### 6.6.1、算法
##### 6.6.2、大O符号
##### 6.6.3、大xita符号
##### 6.6.4、时间复杂度
#### 6.7、小结

### chap9、内核同步介绍
#### 9.1、临界区和竞争条件
##### 0、
+ 临界区
+ 竞争条件race coditions
##### 9.1.1、为什么我们需要保护
##### 9.1.2、单个变量
#### 9.2、加锁
##### 0、
+ *lionel，没太看懂啊*
##### 9.2.1、造成并发执行的原因
+ 内核中有类似可能造成并发执行的原因。它们是
	+ 中断
	+ 软中断和tasklet
	+ 内核抢占
	+ 睡眠及与用户空间的同步
	+ 对称多处理
##### 9.2.2、了解要保护些什么
#### 9.3、死锁
#### 9.4、争用和扩展性
#### 9.5、小结

### chap12、内存管理
#### 12.1、页
+ **MMU**（是硬件），以页为单位进行处理。
+ 大多数32位体系结构支持4KB的页，而64位体系结构一般会支持8KB的页。
+ `struct page{};`，include/linux/mm.h
+ **page结构与物理页相关，而并非与虚拟页相关**。
#### 12.2、区
+ **内核把页划分为不同的区（zone）**,Linux主要使用了四种区
	+ ZONE_DMA
	+ ZONE_DMA32
	+ ZONE_NORMAL
	+ ZONE_HGHEM
+ `struct zone {};`
#### 12.3、获得页
##### 0、
+ `alloc_pages()`
+ `page_address()`
##### 12.3.1、获得填充为0的页
+ `get_zeroed_page()`
##### 12.3.2、释放页
+ `free_page()`
+ **内核是完全相信自己的**
#### 12.4、kmalloc
##### 0、
+ **以字节为单位，确保页在物理地址上是连续的**，实现在include/linux/slab.h中
##### 12.4.1、gfp_mask标志
+ 标志分为**3种**
+ 1、行为修饰符
+ 2、区修饰符
+ 3、类型标志
##### 12.4.2、kfree
#### 12.5、vmalloc
+ **分配的内存虚拟地址是连续的，而物理地址无须连续**
#### 12.6、slab层
##### 0、
##### 12.6.1、slab层的设计
##### 12.6.2、slab分配器的接口
+ `kmem_cache_create()`
#### 12.7、在栈上的静态分配
##### 0、
+ **32位和64位体系结构的页面大小分别是4KB和8KB，所以通常它们的内核栈的大小分别是8KB和16KB**。
##### 12.7.1、单页内核栈
##### 12.7.2、在栈上光明正大地工作
#### 12.8、高端内存的映射
##### 0、
+ **在高端内存中的页不能永久地映射到内核地址空间上**。
##### 12.8.1、永久映射
+ `kmap()`
##### 12.8.2、临时映射
+ `kmap_atomic()`
#### 12.9、每个CPU的分配
+ 每个CPU的数据存放在一个数组中。
+ 内核抢占会引起下面提及的两个问题：
	+ 如果你的代码被其他
	+ 如果另一个
#### 12.10、新的每个CPU接口
##### 0、
+ **percpu**，简化了创建和操作每个CPU的数据。
##### 12.10.1、编译时的每个CPU数据
##### 12.10.2、运行时的每个CPU数据
#### 12.11、使用每个CPU数据的原因
+ 首先，**减少了数据锁定**
+ 第二个好处，**使用每个CPU数据可以大大减少缓存失效**
#### 12.12、分配函数的选择
+ 连续的物理页：**使用某个低级页分配器或kmalloc()**
	+ GFP_ATOMIC：进行不睡眠的高优先级分配
	+ GFP_KERNEL：如果有必要，进程可以睡眠
+ 不需要物理上连续的页，**仅仅需要虚拟地址上连续的页**，就使用vmalloc 【**vmalloc相对kmalloc，有一定的性能损失**】，把物理内存块映射到连续的逻辑地址空间上。
+ 如果你想从高端内存进行分配，使用alloc_pages()。**为了获得真正的指针，应该调用kmap()，把高端内存映射到内核的逻辑地址空间**。
+ 创建和撤销很多大的数据结构，考虑建立**slab高速缓存**。slab层会给每个处理器维持一个对象高速缓存（空闲链表），这种高速缓存会极大地提高对象分配和回收的性能。**为你把事先分配好的对象存放到高速缓存中**
#### 12.13、小结
+ 在内核中分配内存并非总是轻而易举，因为你必须小心地**确保分配过程遵从内核特定的状态约束**。
+ **分配内存相对复杂**是内核开发和用户开发的最大区别之一。

### chap13、

#### 13.1、通用文件系统接口

#### 13.2、文件系统抽象层

#### 13.3、Unix文件系统

+ 4种与文件系统相关的传统抽象概念
  + 文件：可以看作有序的字节串（unix把目录也看作文件）
  + 目录项：路径中的每一部分称作**目录条目**，也叫**目录项**
  + 索引节点：文件信息按照索引形式存储在单独的块中，**控制信息存储在超级块中**。
  + 安装点（mount point）

#### 13.4、VFS对象及其数据结构

+ VFS采用**面向对象**的设计原理，不过是用C语言实现的
+ VFS中有四个主要的对象类型：（这里对象是指**结构体**）
  + 超级块对象：代表一个具体的已安装文件系统
    + super_operations
  + 索引节点对象：代表一个具体文件
    + inode_operations
  + 目录项对象：代表一个目录项，是路径的一个组成部分
    + dentry_operations
  + 文件对象：代表由进程打开的文件
    + file_operations
+ 每个主要对象都包含一个**操作对象**，操作对象作为一个结构体指针来实现的

#### 13.5、超级块对象

+ `struct super_block{};`这个定义在linux/fs.h
+ **创建、管理和撤销超级块对象**代码位于fs/super.c

#### 13.6、超级块操作

+ 最重要的一个域`s_op`

#### 13.7、索引节点对象

#### 13.8、索引节点操作

#### 13.9、目录项对象

##### 13.9.1、目录项状态

##### 13.9.2、目录项缓存

#### 13.10、目录项操作

#### 13.11、文件对象

#### 13.12、文件操作

#### 13.13、和文件系统相关的数据结构

#### 13.14、和进程相关的数据结构

#### 13.15、小结