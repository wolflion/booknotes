<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>《Effective STL》 - lionel的技术笔记</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u300aEffective STL\u300b";
        var mkdocs_page_input_path = "21STL\\EffectiveSTL.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> lionel的技术笔记
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../01daily/">daily</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">C++</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/effectiveC%2B%2B/">《Effective C++》</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">《Effective STL》</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#part1">Part1、容器</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1">1、慎重选择容器类型</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2">2、不要试图编写独立于容器类型的代码</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3">3、确保容器中的对象拷贝正确而高效</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4emptysize0">4、调用empty而不是检查size()是否为0</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5">5、区间成员函数优先于与之对应的单元素成员函数</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#6c">6、当心C++编译器最烦人的分析机制</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#7newdelete">7、如果容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#8auto_ptr">8、切勿创建包含auto_ptr的容器对象</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#9">9、慎重选择删除元素的方法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#10allocator">10、了解分配子（allocator）的约定和限制</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#11">11、理解自定义分配子的合理用法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#12stl">12、切勿对STL容器的线程安全性有不切实际的依赖</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#part2vectorstring">Part2、vector和string</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#13vectorstring">13、vector和string优先于动态分配的数组</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#14reverse">14、使用reverse来避免不必要的重新分配</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#15string">15、注意string实现的多样性</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#16vectorstringapi">16、了解如何把vector和string数据传给旧的API</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#17swap">17、使用“swap技巧”除去多余的容量</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#18-vectorbool">18、避免使用 vector&lt;bool&gt;</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#part319-25">Part3、关联容器（19-25）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#19">19、</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#20">20、</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#21">21、</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#22">22、</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#23">23、</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#24">24、</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#25">25、</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#part426-29">Part4、迭代器（26-29）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#26">26、</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#27">27、</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#28">28、</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#29">29、</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#part5">Part5、算法</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#30">30、确保目标区间足够大</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#31">31、了解各种与排序有关的选择</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#32removeerase">32、如果确实需要删除元素，则需要在remove这一类算法之后调用erase</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_1">备注</a>
    </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">基础知识</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">《操作系统导论》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">《大话设计模式》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网络编程</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">《TCP/IP网络编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">《Linux高性能服务器编程》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">文件系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/Linux%E5%86%85%E6%A0%B8%E6%8E%A2%E7%A7%98/">《Linux内核探秘》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《文件系统技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">《存储技术原理分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">存储</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../12storage/ceph%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《ceph设计原理与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">内核</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《Linux内核设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/">《深入Linux设备驱动程序内核机制》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">《深入理解Linux虚拟内存管理》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">刷题</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../91leetcode/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/">《剑指offer专项突破》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网课</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/01Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/">《Linux高并发网络编程开发》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/%E4%BE%AF%E6%8D%B7/%E4%BE%AF%E6%8D%B7C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8660%E8%AE%B2/">《侯捷C++内存管理60讲》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/11NJU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">《NJU算法设计与分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">英语专</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../60English/00794%E7%BB%BC%E5%90%88%E8%8B%B1%E8%AF%AD%E4%B8%80%E4%B8%8A/">《综合英语(一)上》</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">lionel的技术笔记</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>C++ &raquo;</li>
      <li>《Effective STL》</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h2 id="effective-stl">《Effective STL》<a class="headerlink" href="#effective-stl" title="Permanent link">&para;</a></h2>
<h3 id="part1">Part1、容器<a class="headerlink" href="#part1" title="Permanent link">&para;</a></h3>
<h4 id="1">1、慎重选择容器类型<a class="headerlink" href="#1" title="Permanent link">&para;</a></h4>
<ul>
<li>标准STL序列容器：vector、string、deque、list</li>
<li>标准STL关联容器：set、multiset、map、multimap</li>
</ul>
<h4 id="2">2、不要试图编写独立于容器类型的代码<a class="headerlink" href="#2" title="Permanent link">&para;</a></h4>
<h4 id="3">3、确保容器中的对象拷贝正确而高效<a class="headerlink" href="#3" title="Permanent link">&para;</a></h4>
<ul>
<li>存入容器的是<strong>你所指定的对象的拷贝</strong>。</li>
</ul>
<h4 id="4emptysize0">4、调用empty而不是检查size()是否为0<a class="headerlink" href="#4emptysize0" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>empty对所有的标准容器都是常数时间操作</strong>。</li>
</ul>
<h4 id="5">5、区间成员函数优先于与之对应的单元素成员函数<a class="headerlink" href="#5" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>区间成员函数</strong>（range member function）：它们像STL算法一样，使用两个迭代器来确定该成员操作所执行的区间。</li>
</ul>
<h4 id="6c">6、当心C++编译器最烦人的分析机制<a class="headerlink" href="#6c" title="Permanent link">&para;</a></h4>
<h4 id="7newdelete">7、如果容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉<a class="headerlink" href="#7newdelete" title="Permanent link">&para;</a></h4>
<h4 id="8auto_ptr">8、切勿创建包含auto_ptr的容器对象<a class="headerlink" href="#8auto_ptr" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>C++11已经废弃了这个关键字<code>auto_ptr</code></strong>。</li>
</ul>
<h4 id="9">9、慎重选择删除元素的方法<a class="headerlink" href="#9" title="Permanent link">&para;</a></h4>
<ul>
<li>连续内存用<code>c.erase(remove(c.begin(),c.end(),1963),c.end());</code></li>
<li>关联容器用<code>c.erase(1963);</code></li>
</ul>
<h4 id="10allocator">10、了解分配子（allocator）的约定和限制<a class="headerlink" href="#10allocator" title="Permanent link">&para;</a></h4>
<h4 id="11">11、理解自定义分配子的合理用法<a class="headerlink" href="#11" title="Permanent link">&para;</a></h4>
<ul>
<li><code>allocator&lt;T&gt;</code></li>
</ul>
<h4 id="12stl">12、切勿对STL容器的线程安全性有不切实际的依赖<a class="headerlink" href="#12stl" title="Permanent link">&para;</a></h4>
<h3 id="part2vectorstring">Part2、vector和string<a class="headerlink" href="#part2vectorstring" title="Permanent link">&para;</a></h3>
<h4 id="13vectorstring">13、vector和string优先于动态分配的数组<a class="headerlink" href="#13vectorstring" title="Permanent link">&para;</a></h4>
<ul>
<li>使用了<code>new</code>的后遗症<ul>
<li>确保<code>delete</code>；</li>
<li>确保用对了<code>delete</code>，<code>delete[]</code>形式</li>
<li>确保只<code>delete</code>了一次；</li>
</ul>
</li>
<li><code>string</code>的实现使了<strong>引用计数</strong>技术，<em>这可能对于多线程带来性能问题</em>；<code>vector</code>的实现没有用。</li>
</ul>
<h4 id="14reverse">14、使用reverse来避免不必要的重新分配<a class="headerlink" href="#14reverse" title="Permanent link">&para;</a></h4>
<ul>
<li>相对于<code>array</code>而言，是<strong>可变增长</strong>，realloc操作分为4部分：<ul>
<li>分配一个当前容量某个倍数的新内存。（一般是2）</li>
<li>元素拷贝到新内存中</li>
<li>析构旧内存的对象</li>
<li>释放旧内存</li>
</ul>
</li>
<li>理解以下4个成员函数：<ul>
<li><code>size()</code>：容器里有多少个元素</li>
<li><code>capacity()</code>：容器有多大</li>
<li><code>resize(n)</code>：强迫到n的大小（不够的话，自己申请；多的话，就析构掉部分）</li>
<li><code>reserve(n)</code>：强迫到n的大小（<strong>n不会小于当前的大小</strong>）</li>
</ul>
</li>
<li>体会一下这两段代码的区别：</li>
</ul>
<pre class="highlight"><code class="language-cpp">vector&lt;int&gt; v;
for(int i=0;i&lt;=1000;++i)  v.push_back(i);  // 1000是2的10次方

// reserve
vector&lt;int&gt; v1;
v1.reserve(1000);
for(int i=0;i&lt;=1000;++i)  v.push_back(i);</code></pre>
<h4 id="15string">15、注意string实现的多样性<a class="headerlink" href="#15string" title="Permanent link">&para;</a></h4>
<ul>
<li><em>不同的STL库，对于string的具体实现有差异</em>。</li>
</ul>
<h4 id="16vectorstringapi">16、了解如何把vector和string数据传给旧的API<a class="headerlink" href="#16vectorstringapi" title="Permanent link">&para;</a></h4>
<ul>
<li><code>char*</code>与<code>string</code>的互换：<code>s.c_str()</code></li>
<li><code>&amp; *v.begin()</code>才与<code>&amp;v[0]</code>等价。<strong><code>v.begin()</code>返回值是一个迭代器，不是指针</strong>。</li>
<li><strong>练习题</strong>：<ul>
<li>用C API中的元素初始化一个<code>vector</code>和<code>string</code></li>
</ul>
</li>
</ul>
<h4 id="17swap">17、使用“swap技巧”除去多余的容量<a class="headerlink" href="#17swap" title="Permanent link">&para;</a></h4>
<ul>
<li>本例中的代码：</li>
</ul>
<pre class="highlight"><code class="language-cpp">string s;
// ... // 让s变大，然后再删除它的大部分字符
string(s).swap(s);  //对s做shrink-to-fit

string s1;
// ... // 使用s1
string().swap(s1);//清除s并把它的容量变为最小</code></pre>
<ul>
<li>C11新特性支持<code>shrink_to_fit()</code>：<strong>将capacity()减少为与size()相同大小</strong>。</li>
</ul>
<h4 id="18-vectorbool">18、避免使用 <code>vector&lt;bool&gt;</code><a class="headerlink" href="#18-vectorbool" title="Permanent link">&para;</a></h4>
<ul>
<li><code>vector&lt;bool&gt;</code>有两点不对<ul>
<li>1、它不是一个STL容器（并不支持<code>operator[]</code>）</li>
<li>2、它不存储<code>bool</code></li>
</ul>
</li>
<li><strong>这个是尝试失败的试验品</strong>，建议用<code>bitset</code></li>
</ul>
<h3 id="part319-25">Part3、关联容器（19-25）<a class="headerlink" href="#part319-25" title="Permanent link">&para;</a></h3>
<ul>
<li>有哪些特性：（自动排序，不允许有重复数据）</li>
</ul>
<h4 id="19">19、<a class="headerlink" href="#19" title="Permanent link">&para;</a></h4>
<ul>
<li>find的相等是<code>operator==</code>，std::insert是<strong>等价</strong>，以<code>operator&lt;</code>为基础</li>
</ul>
<ul>
<li><strong>等价关系是以“在已排序的区间中对象值的相对顺序”为基础的</strong>。<em>不区分大小写？</em></li>
</ul>
<ul>
<li><em>没有完全看懂啊，lionel</em></li>
</ul>
<h4 id="20">20、<a class="headerlink" href="#20" title="Permanent link">&para;</a></h4>
<ul>
<li><code>set&lt;string *&gt; ssp;</code>是<code>set&lt;string *, less&lt;string*&gt;&gt; ssp;</code>，最精确的说，是<code>set&lt;string *, less&lt;string*&gt;, allocator&lt;string*&gt;&gt; ssp;</code>的缩写。
    + <strong>自己编写比较函数子类</strong></li>
</ul>
<h4 id="21">21、<a class="headerlink" href="#21" title="Permanent link">&para;</a></h4>
<h4 id="22">22、<a class="headerlink" href="#22" title="Permanent link">&para;</a></h4>
<ul>
<li>set和multiset时，Key的值是<code>const</code>的</li>
</ul>
<h4 id="23">23、<a class="headerlink" href="#23" title="Permanent link">&para;</a></h4>
<ul>
<li>如果只是单纯想查找用<strong>hash</strong>，<strong>关联容器是平衡二叉树</strong></li>
</ul>
<h4 id="24">24、<a class="headerlink" href="#24" title="Permanent link">&para;</a></h4>
<ul>
<li>map中的<code>operator[]</code>有问题啊</li>
</ul>
<h4 id="25">25、<a class="headerlink" href="#25" title="Permanent link">&para;</a></h4>
<ul>
<li>hash_set（标准库，没有啊）</li>
</ul>
<h3 id="part426-29">Part4、迭代器（26-29）<a class="headerlink" href="#part426-29" title="Permanent link">&para;</a></h3>
<p>0、
+ 为啥需要4种迭代器？iterator、const_iterator、reverse_iterator、const_reverse_iterator，<em>是不是废弃掉啦？</em></p>
<h4 id="26">26、<a class="headerlink" href="#26" title="Permanent link">&para;</a></h4>
<ul>
<li>iterator优先使用</li>
</ul>
<h4 id="27">27、<a class="headerlink" href="#27" title="Permanent link">&para;</a></h4>
<ul>
<li>把const_iterator转换成iterator，<em>为啥不要用const呢？</em></li>
</ul>
<h4 id="28">28、<a class="headerlink" href="#28" title="Permanent link">&para;</a></h4>
<h4 id="29">29、<a class="headerlink" href="#29" title="Permanent link">&para;</a></h4>
<ul>
<li><code>istream_iterator</code>使用<code>operator&gt;&gt;</code>函数来完成实际的读操作，而默认情况下<code>operator&gt;&gt;</code>函数会跳过空白字符。</li>
</ul>
<h3 id="part5">Part5、算法<a class="headerlink" href="#part5" title="Permanent link">&para;</a></h3>
<h4 id="30">30、确保目标区间足够大<a class="headerlink" href="#30" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>STL容器会自动扩充存储空间以容纳这些对象</strong>，但并不一定总是能正确管理，<em>如果user触发得不对，lionel</em></li>
<li><strong>插入型迭代器</strong></li>
</ul>
<h4 id="31">31、了解各种与排序有关的选择<a class="headerlink" href="#31" title="Permanent link">&para;</a></h4>
<ul>
<li>sort</li>
<li>qsort</li>
<li>partial_sort</li>
<li>nth_element</li>
<li>stable_sort</li>
<li>partiton</li>
<li><em>各种不同排序有其适合的场合，要注意，lionel</em></li>
</ul>
<h4 id="32removeerase">32、如果确实需要删除元素，则需要在remove这一类算法之后调用erase<a class="headerlink" href="#32removeerase" title="Permanent link">&para;</a></h4>
<h3 id="_1">备注<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<ul>
<li>前置知识《CPP Primer》5th的chap9顺序容器。</li>
<li>2021-11-25花了50min整理形成了第1版。</li>
</ul>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../20C%2B%2B/effectiveC%2B%2B/" class="btn btn-neutral float-left" title="《Effective C++》"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../../408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/" class="btn btn-neutral float-right" title="《操作系统导论》">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../../20C%2B%2B/effectiveC%2B%2B/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../../408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
