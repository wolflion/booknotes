## 《新编数据结构习题与解析》

+ chap11内排序（计划0821-0826完成的）

### chap9、图

#### 9.1、图的基本概念

##### 9.1.1、知识点

+ 1、图的基本术语

+ 2、图的存储结构

  + （1）邻接矩阵
    + 先定义**顶点**，【图里，一般都要存啥？】，*我一直以为只是个普通的二维数组呢？*

  ```cpp
  #define MAXV <最大顶点个数>
  typedef char ElemType;
  typedef struct {
      int no;  //顶点编号
      ElemType info;
  }VertexType;
  
  typedef struct {
      int edges[MAXV][MAXV];
      int n,e;             //顶点数和边数
      VertexType vexs[MAXV]; //存放顶点信息
  }MGraph;
  ```

  

  + （2）邻接表

```cpp
typedef char ElemType;
typedef int InfoType;
typedef struct ANode{
    int adjvex;
    struct ANode *nextarc;
    InfoType info;
}ArcNode; //边的节点类型

typedef struct Vnode{ //表头
    ElemType data;
    ArcNode *firstarc;
}VNode;

typdef VNode AdjList[MAXV];  //AdjList是邻接表类型

typedef struct {
    AdjList adjlist; //邻接表
    int n,e;
}AGraph;
```



+ 3、图的基本运算及实现算法

9.2、

### chap11、内排序

#### 11.1、插入（直接插入、希尔）

```cpp
typedef struct {
    int key;//关键字
    int data;//其它数据
}SqList;
```



##### 11.1.1、知识点

+ 直接插入
  + 思路：**前面是有序的**

```cpp
void InsertSort(SqList R[], int len){
    SqList tmp;
    for(int i=1;i<n;i++){
        tmp = R[i];
        int j=i-1; //因为i前面是有序的，j指向有序区的最后一个元素
        while(j>=0 && R[j].key > tmp.key){   //lionel，里面的for循环，就是为了在 有序区，找插入位置
            R[j+1] = R[j];  //不断往后移
            j--;//不断减减，找到合适的插入位置
        }
        R[j+1] = tmp;//找到j后，再j+1，把tmp插入进去
    }
}
```



+ 折半插入
  + 想法是，**在前面的有序区间中，用折半查找的方法**，找到j的位置
+ 希尔
  + 又叫缩小增量，可以用2个函数，也可以在原来的 直接插入 外面套一个while循环
  + **与待排序数据的顺序有关**，正序时效率最高，反序时效率最低

```cpp
void ShellSort(SqList R[], int n) {  //n就是len
    SqList tmp;
    int d = n/2;
    while(d>0){ //lionel，相当于套了一层，一直循环到d=1为止
        for(int i=d;i<n;i++){  //对所有相隔d位置的元素组进行排序
            tmp = R[i];
            int j=i-d;  //lionel，所有的原先是1的地方，变成了增量d
            while(j>=0 && R[j].key>tmp.key){
                R[j+d] = R[j];
                j-=d;
            }
            R[j+d] = tmp;
        }
        d=d/2;
    }
}
```



##### 11.1.2、习题

###### 一、单选

+ 1、直接插入排序最好情况下时间复杂度是`O(n)`，*正序，里层的while循环不需要插入*
+ 2、对n个记录的表进行直接插入排序，在最坏情况下需比较`n(n-1)/2`
  + 我用的是排除法，肯定是O(n方)，只能选D
  + 真实的情况：第2次需要1次比较，第3次需要2次比较，....第n次需要n-1次比较
+ 3、稳定的排序算法是**直接插入排序**
  + 这个肯定是稳定的，*其它的选项不确定*
+ 4、{8,9,10,4,5,6,20,1,2}只能是**直接插入排序**算法的两趟排序后的结果
  + 两趟排序后的有序区，不是**全局有序**
+ 5、
+ 6、
+ 7、在初始序列已基本有序的情况下，排序效率最高的是**直接插入排序**
  + 我本来想的是**希尔排序**，但选项没有，*两个答案都是正确的*，如果是多选的话
+ 8、不稳定的排序算法是**希尔排序**（*其它选项，不确定*）
+ 10、

###### 二、填空

+ 11、
+ 12、
+ 13
+ 14、{Q,H,C,Y,Q,A,M,S,R,D,F,X}，关键字递增，初始步长为4，则第一趟的结果**,**。
  + *lionel，疑问点在于，布长，怎么计*【第1个就是1，然后数4个？】
+ 15、

###### 三、简答

+ 16、直接插入排序与希尔排序算法的不同
  + 直接插入排序，是**稳定的**，采用顺序查找时，也适用于链式存储
  + 希尔排序，是**不稳定的**，不适用于链式存储
+ 17、希尔排序每一趟都要调用若干次直接插入排序，为什么希尔排序还比直接插入排序算法效率更高。
  + **按近正序时**效率很高？*lionel，我感觉答案没写对啊？*
+ 18、
+ 19、
+ 20、写出{4,5,1,2,8,6,7,3,10,9}的直接插入排序过程
+ 21、写出{4,5,1,2,8,6,7,3,10,9}的希尔排序过程

###### 四、算法

+ 22、创建一个带头节点的单链表，设计一个直接插入排序对这个单链表进行递增排序
+ 23、
+ 24、

#### 11.2、选择（简单选择、堆-优先队列）

##### 11.2.1、知识点

+ 简单选择
  + **有序区的均小于无序区的**，每次从无序区找一个第小的与R[i]交换，这样R[0...i]都有序了

```cpp
void SelectSort(SqList R[], int n){ //n就是len
    SqList tmp;
    int k;  //用k指出最小的，为啥不直接用min？lionel
    for(int i=0;i<n;i++){
        k=i;//lionel，哨兵？
        for(int j=i+1;j<n;j++){ //两层for循环，从无序区找最小的
            if( R[k].key > R[j].key)
                k=j;//用k指出每趟在无序区的最小元素
            
            if(i!=k){  //R[k]与R[i]交换，lionel，为啥这个时候交换？【因为i会不断加加，相当于前面的都是排序的】
                tmp = R[i];
                R[i] = R[k];
                R[k] = tmp;
            }
        }
    }
}
```



+ 堆排序（优先队列）
  + 筛选算法？【】搜了一下，感觉是**下沉**，*目前，能知道怎么构造，但例子怎么结合代码，还不太会，主要分不清楚，从0开始还是从1开始？*

```cpp
void Sift(SqList R[], int low, int high){  //把R[low...high]调整成堆
    int i=low,j=2*i;  //R[j]是R[i]的左孩子
    SqList tmp = R[i];
    
    while(j<=high){
        if(j<high && R[j].key < R[j+1].key)  //右孩子大，j指向右孩子
            j++;
        if(tmp.key<R[j].key){//双亲的根节点小于 孩子，需调整
            R[i] = R[j];  //R[j]调整到双亲结点上
            i=j;
            j=2*i;   //修改i和j，以便继续向下筛选  【lionel，就不太明白了】
        }else
            break;   //筛选结束
    }
    R[j]=tmp;  //被筛选节点的值，放入最终位置  【lionel，不太明白】
}


//建立堆
void HeapSort(SqList R[], int n){
    SqList tmp;
    int i;
    for(i=n/2;i>=1;i--)
        Sift(R,i,n);
    
    for(i =n;i>=2;i--){ //n-1次循环
        tmp = R[1];//每一个元素同当前区间内的R[1]对换
        R[1] = R[i];
        R[i] = tmp;
        Sift(R,1,i-1);  //lionel，其实还是不太懂
    }
}
```

##### 11.2.2、习题

###### 一、单选

+ 4、采用简单选择排序，关键字比较次数（**`O(n平方)`**），元素移动次数是（**O(n)**），*这个我不太熟悉呢，lionel*
+ 9、一组{15,9,7,8,20,-1,7,4}，用堆排序的筛选方法建立的初始堆是：`-1,4,7,8,20,15,7,9`，*这个我没做出来的
  + 我的答案是`20,15,7,8,9,-1,7,4`
+ 12、一组{84,47,25,15,21}进行排序，排序过程中变化如下：，采用的排序算法是**堆排序**，*自己按自己的想法没做出来*
  + （1）84，47，25，15，21
  + （2）21，47，25，15，84
  + （3）15，21，25，47，84
  + （4）15，21，25，47，84

###### 二、填空

###### 三、简答

###### 四、算法

#### 11.3、交换（冒泡、快速）

##### 11.3.1、知识点

+ 冒泡

```cpp
void BubbleSort(SqList R[], int n){
    int i,j,exchange;
    SqList tmp;
    for(i=0;i<n-1;i++){
        exchange=0;
        for(j=n-1;j>i;j--){ //lionel，是不是从最后往前，还是前往后，应该无所谓吧
            if(R[j].key<R[j-1].key){  //lionel，这才是核心，逐个比较
                tmp=R[j];
                R[j]=R[j-1];
                R[j-1]=tmp;
                exchang=1; //优化版本，如何不需要交换，就省了一轮
            }
        }
        if(exchange==0)  //本趟未发生交换时结束算法
            return ;
    }
}
```



+ 快速
  + 单次的分界**Partation**的实现方式有2种，见《趣学算法》

```cpp
void QuickSort(SqList R[], int s, int t){ //对R[s...t]的元素进行快速排序
    int i=s,j=t;
    SqList tmp;
    if(s<t){
        tmp=R[s];
        while(i!=j){
            while(j>i && R[j].key > tmp.key)
                j--;
            R[i]=R[j];
            while(j>i && R[i].key < tmp.key)
                i++;
            R[j]=R[i];
        }
        R[i] = tmp;
        QuickSort(R,s,i-1);
        QuickSort(R,i+1,t);
    }
}
```



##### 11.3.2、习题

###### 一、单选

###### 二、填空

###### 三、简答

+ 18、对序列{15,5,16,2,25,8,20,9,18,12}，给出采用快速排序法对该序列作升序排序的每一趟结果
  + 方法1【选中15为基准值pivlot】
    + 从右边开始，12小于15，与15交换，变成12,5,16,2,25,8,20,9,18,15
    + 换到左边开始，5是小于15的，继续下一个，16大于15了，就要与15交换（right指针没变），变成12,5,15,2,25,8,20,9,18,16
    + 换到右边开始，18大于15，9小于15，交换，12,5,9,2,25,8,20,15,18,16
    + 换到左边开始，left指向的是9，2也是小于15的，25大于15，再交换，12,5,9,2,15,8,20,25,18,16
    + 换到右边开始，right指向的是25，20是大于15的，8小于15，再交换，12,5,9,2,8,15,25,18,16
    + 换到左边开始，left指向的是8，8小于15，到下一个，发现left==right
  + 方法2【选中15为基准值pivlot】，**两边同时前进，遇到不符合的，就交换**
+ 22、

###### 四、算法

+ 23、设计一个**双向冒泡排序**，即在排序过程中交替改变扫描方向

#### 11.4、归并

+ 《算法4》对归并有几种场景，自底向上，自顶向下

##### 11.4.1、知识点

+ 手工模拟场景

+ 自底向上的情况

```cpp
void MergeSort(SqList R[], int n){
    int length;
    for(length=1;length<n;length=2*length)  //2个成一组
        MergePass(R,length,n);
}

//lionel，这个还没细看
void MergePass(SqList R[], int length, int n){
    int i;
    for(i=0;i+2*length-1<n;i=i+2*length) //lionel，没懂
        Merge(R,i,i+length-1,i+2*length-1);
    if(i+length-1<n)  //余下2个子表
        Merge(R,i,i+length-1,n-1); //归并2个子表
}

void Merge(SqList R[], int low, int mid, int high){
    
}
```



##### 11.4.2、习题

###### 一、单选

###### 二、填空

###### 三、简答

###### 四、算法

#### 11.5、基数

##### 11.5.1、知识点

##### 11.5.2、习题

###### 一、单选

###### 二、填空

###### 三、简答

###### 四、算法









##### 11.2.2、习题

###### 一、单选

###### 二、填空

###### 三、简答

###### 四、算法