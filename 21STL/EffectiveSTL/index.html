<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>《Effective STL》 - lionel的技术笔记</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u300aEffective STL\u300b";
        var mkdocs_page_input_path = "21STL\\EffectiveSTL.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> lionel的技术笔记
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../01daily/">daily</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">C++</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/effectiveC%2B%2B/">《Effective C++》</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">《Effective STL》</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#part1">Part1、容器</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1">1、慎重选择容器类型</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2">2、不要试图编写独立于容器类型的代码</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3">3、确保容器中的对象拷贝正确而高效</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4emptysize0">4、调用empty而不是检查size()是否为0</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5">5、区间成员函数优先于与之对应的单元素成员函数</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#6c">6、当心C++编译器最烦人的分析机制</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#7newdelete">7、如果容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#8auto_ptr">8、切勿创建包含auto_ptr的容器对象</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#9">9、慎重选择删除元素的方法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#10allocator">10、了解分配子（allocator）的约定和限制</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#11">11、理解自定义分配子的合理用法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#12stl">12、切勿对STL容器的线程安全性有不切实际的依赖</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#part2vectorstring">Part2、vector和string</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#13vectorstring">13、vector和string优先于动态分配的数组</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#14reverse">14、使用reverse来避免不必要的重新分配</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#15string">15、注意string实现的多样性</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#16vectorstringapi">16、了解如何把vector和string数据传给旧的API</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#17swap">17、使用“swap技巧”除去多余的容量</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#18-vectorbool">18、避免使用 vector&lt;bool&gt;</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#part319-25">Part3、关联容器（19-25）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#19equalityequivalence">19、理解相等（equality）和等价（equivalence）的区别</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#20">20、为包含指针的关联容器指定比较类型</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#21false">21、总是让比较函数在等值情况下返回false</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#22setmultiset">22、切勿直接修改set或multiset中的键</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#23vector">23、考虑用排序的vector替代关联容器</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#24mapoperatormapinsert">24、当效率至关重要时，请在map::operator[]与map::insert之间谨慎做出选择</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#25">25、熟悉非标准的散列容器</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#part426-29">Part4、迭代器（26-29）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#26iteratorconst_iteratorreverse_iteratorconst_reverse_iterator">26、iterator优先于const_iterator、reverse_iterator及const_reverse_iterator</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#27distanceadvanceconst_iteratoriterator">27、使用distance和advance将容器的const_iterator转换成iterator</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#28reverse_iteratorbaseiterator">28、正确理解由reverse_iterator的base()成员函数所产生的iterator的用法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#29istreambuf_iterator">29、对于逐个字符的输入请考虑使用istreambuf_iterator</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#part530-37">Part5、算法（30-37）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#30">30、确保目标区间足够大</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#31">31、了解各种与排序有关的选择</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#32removeerase">32、如果确实需要删除元素，则需要在remove这一类算法之后调用erase</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#33remove">33、对包含指针的容器使用remove这一类算法时要特别小心</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#34">34、了解哪些算法要求使用排序的区间作为参数</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#35mismatchlexicographical_compare">35、通过mismatch或lexicographical_compare实现简单的忽略大小写的字符串比较</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#36copy_if">36、理解copy_if算法的正确实现</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#37accumulatefor_each">37、使用accumulate或者for_each进行区间统计</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#part638-42">Part6、函数子、函数子类、函数及其他（38-42）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#38">38、遵循按值传递的原则来设计函数子类</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#39">39、确保判别式是“纯函数”</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#40">40、若一个类是函数子，则应使它可配接</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#41ptr_funmem_funmem_fun_ref">41、理解ptr_fun、mem_fun和mem_fun_ref的来由</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#42lesstoperator">42、确保less&lt;T&gt;与operator&lt;具有相同的语义</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#part7stl43-50">Part7、在程序中使用STL（43-50）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#43">43、算法调用优先于手写的循环</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#44">44、容器的成员函数优先于同名的算法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#45countfindbinary_searchlower_boundupper_boundequal_range">45、正确区分count、find、binary_search、lower_bound、upper_bound和equal_range</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#46stl">46、考虑使用函数对象而不是函数作为STL算法的参数</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#47write-only">47、避免产生“直写型”（write-only）的代码</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#48include">48、总是包含（#include）正确的头文件</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#49stl">49、学会分析与STL相关的编译器诊断信息</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#50stlweb">50、熟悉与STL相关的Web站点</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_1">参考书目</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_2">备注</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../C%2B%2B%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/">《C++泛型STL原理和应用》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../22C%2B%2Bmodern/%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8C%2B%2B11/">《深入应用C++11》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">基础知识</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">《操作系统导论》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">《大话设计模式》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网络编程</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">《TCP/IP网络编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">《Linux高性能服务器编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71/">《TCPIP详解卷1》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90/">《Linux内核网络栈源代码情景分析》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C/">《深入理解Linux网络》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">文件系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/Linux%E5%86%85%E6%A0%B8%E6%8E%A2%E7%A7%98/">《Linux内核探秘》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《文件系统技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">《存储技术原理分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">存储</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../12storage/ceph%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《ceph设计原理与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">视频</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/FFmpeg%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">《FFmpeg入门到精通》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">《WebRTC权威指南》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AE%9E%E6%97%B6%E4%BA%92%E5%8A%A8%E6%8A%80%E6%9C%AF/">《WebRTC音视频实时互动技术》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/%E6%96%B0%E4%B8%80%E4%BB%A3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%A0%81%E6%A0%87%E5%87%86-H.264_AVC/">《新一代视频压缩码标准-H.264_AVC》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">内核</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《Linux内核设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/">《深入Linux设备驱动程序内核机制》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">《深入理解Linux虚拟内存管理》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《深入理解Linux网络技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90-tcpip%E5%AE%9E%E7%8E%B0/">《Linux内核源代码剖析-TCP/IP实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/">《深入理解Linux内核》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">工具</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/">《Wireshark网络分析实战》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%283rd%29/">《Linux命令行与shell脚本编程大全(3rd)》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%883rd%EF%BC%89/">《python程序设计（3rd）》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">刷题</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../91leetcode/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/">《剑指offer专项突破》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网课</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/01Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/">《Linux高并发网络编程开发》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/%E4%BE%AF%E6%8D%B7/%E4%BE%AF%E6%8D%B7C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8660%E8%AE%B2/">《侯捷C++内存管理60讲》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/11NJU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">《NJU算法设计与分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">英语专</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../60English/00794%E7%BB%BC%E5%90%88%E8%8B%B1%E8%AF%AD%E4%B8%80%E4%B8%8A/">《综合英语(一)上》</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">lionel的技术笔记</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>C++ &raquo;</li>
      <li>《Effective STL》</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h2 id="effective-stl">《Effective STL》<a class="headerlink" href="#effective-stl" title="Permanent link">&para;</a></h2>
<h3 id="part1">Part1、容器<a class="headerlink" href="#part1" title="Permanent link">&para;</a></h3>
<h4 id="1">1、慎重选择容器类型<a class="headerlink" href="#1" title="Permanent link">&para;</a></h4>
<ul>
<li>标准STL序列容器：vector、string、deque、list</li>
<li>标准STL关联容器：set、multiset、map、multimap</li>
</ul>
<h4 id="2">2、不要试图编写独立于容器类型的代码<a class="headerlink" href="#2" title="Permanent link">&para;</a></h4>
<h4 id="3">3、确保容器中的对象拷贝正确而高效<a class="headerlink" href="#3" title="Permanent link">&para;</a></h4>
<ul>
<li>存入容器的是<strong>你所指定的对象的拷贝</strong>。</li>
</ul>
<h4 id="4emptysize0">4、调用empty而不是检查size()是否为0<a class="headerlink" href="#4emptysize0" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>empty对所有的标准容器都是常数时间操作</strong>。</li>
</ul>
<h4 id="5">5、区间成员函数优先于与之对应的单元素成员函数<a class="headerlink" href="#5" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>区间成员函数</strong>（range member function）：它们像STL算法一样，使用两个迭代器来确定该成员操作所执行的区间。</li>
</ul>
<h4 id="6c">6、当心C++编译器最烦人的分析机制<a class="headerlink" href="#6c" title="Permanent link">&para;</a></h4>
<h4 id="7newdelete">7、如果容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉<a class="headerlink" href="#7newdelete" title="Permanent link">&para;</a></h4>
<h4 id="8auto_ptr">8、切勿创建包含auto_ptr的容器对象<a class="headerlink" href="#8auto_ptr" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>C++11已经废弃了这个关键字<code>auto_ptr</code></strong>。</li>
</ul>
<h4 id="9">9、慎重选择删除元素的方法<a class="headerlink" href="#9" title="Permanent link">&para;</a></h4>
<ul>
<li>连续内存用<code>c.erase(remove(c.begin(),c.end(),1963),c.end());</code></li>
<li>关联容器用<code>c.erase(1963);</code></li>
</ul>
<h4 id="10allocator">10、了解分配子（allocator）的约定和限制<a class="headerlink" href="#10allocator" title="Permanent link">&para;</a></h4>
<h4 id="11">11、理解自定义分配子的合理用法<a class="headerlink" href="#11" title="Permanent link">&para;</a></h4>
<ul>
<li><code>allocator&lt;T&gt;</code></li>
</ul>
<h4 id="12stl">12、切勿对STL容器的线程安全性有不切实际的依赖<a class="headerlink" href="#12stl" title="Permanent link">&para;</a></h4>
<h3 id="part2vectorstring">Part2、vector和string<a class="headerlink" href="#part2vectorstring" title="Permanent link">&para;</a></h3>
<h4 id="13vectorstring">13、vector和string优先于动态分配的数组<a class="headerlink" href="#13vectorstring" title="Permanent link">&para;</a></h4>
<ul>
<li>使用了<code>new</code>的后遗症<ul>
<li>确保<code>delete</code>；</li>
<li>确保用对了<code>delete</code>，<code>delete[]</code>形式</li>
<li>确保只<code>delete</code>了一次；</li>
</ul>
</li>
<li><code>string</code>的实现使了<strong>引用计数</strong>技术，<em>这可能对于多线程带来性能问题</em>；<code>vector</code>的实现没有用。</li>
</ul>
<h4 id="14reverse">14、使用reverse来避免不必要的重新分配<a class="headerlink" href="#14reverse" title="Permanent link">&para;</a></h4>
<ul>
<li>相对于<code>array</code>而言，是<strong>可变增长</strong>，realloc操作分为4部分：<ul>
<li>分配一个当前容量某个倍数的新内存。（一般是2）</li>
<li>元素拷贝到新内存中</li>
<li>析构旧内存的对象</li>
<li>释放旧内存</li>
</ul>
</li>
<li>理解以下4个成员函数：<ul>
<li><code>size()</code>：容器里有多少个元素</li>
<li><code>capacity()</code>：容器有多大</li>
<li><code>resize(n)</code>：强迫到n的大小（不够的话，自己申请；多的话，就析构掉部分）</li>
<li><code>reserve(n)</code>：强迫到n的大小（<strong>n不会小于当前的大小</strong>）</li>
</ul>
</li>
<li>体会一下这两段代码的区别：</li>
</ul>
<pre class="highlight"><code class="language-cpp">vector&lt;int&gt; v;
for(int i=0;i&lt;=1000;++i)  v.push_back(i);  // 1000是2的10次方

// reserve
vector&lt;int&gt; v1;
v1.reserve(1000);
for(int i=0;i&lt;=1000;++i)  v.push_back(i);</code></pre>
<h4 id="15string">15、注意string实现的多样性<a class="headerlink" href="#15string" title="Permanent link">&para;</a></h4>
<ul>
<li><em>不同的STL库，对于string的具体实现有差异</em>。</li>
</ul>
<h4 id="16vectorstringapi">16、了解如何把vector和string数据传给旧的API<a class="headerlink" href="#16vectorstringapi" title="Permanent link">&para;</a></h4>
<ul>
<li><code>char*</code>与<code>string</code>的互换：<code>s.c_str()</code></li>
<li><code>&amp; *v.begin()</code>才与<code>&amp;v[0]</code>等价。<strong><code>v.begin()</code>返回值是一个迭代器，不是指针</strong>。</li>
<li><strong>练习题</strong>：<ul>
<li>用C API中的元素初始化一个<code>vector</code>和<code>string</code></li>
</ul>
</li>
</ul>
<h4 id="17swap">17、使用“swap技巧”除去多余的容量<a class="headerlink" href="#17swap" title="Permanent link">&para;</a></h4>
<ul>
<li>本例中的代码：</li>
</ul>
<pre class="highlight"><code class="language-cpp">string s;
// ... // 让s变大，然后再删除它的大部分字符
string(s).swap(s);  //对s做shrink-to-fit

string s1;
// ... // 使用s1
string().swap(s1);//清除s并把它的容量变为最小</code></pre>
<ul>
<li>C11新特性支持<code>shrink_to_fit()</code>：<strong>将capacity()减少为与size()相同大小</strong>。</li>
</ul>
<h4 id="18-vectorbool">18、避免使用 <code>vector&lt;bool&gt;</code><a class="headerlink" href="#18-vectorbool" title="Permanent link">&para;</a></h4>
<ul>
<li><code>vector&lt;bool&gt;</code>有两点不对<ul>
<li>1、它不是一个STL容器（并不支持<code>operator[]</code>）</li>
<li>2、它不存储<code>bool</code></li>
</ul>
</li>
<li><strong>这个是尝试失败的试验品</strong>，建议用<code>bitset</code></li>
</ul>
<h3 id="part319-25">Part3、关联容器（19-25）<a class="headerlink" href="#part319-25" title="Permanent link">&para;</a></h3>
<ul>
<li>有哪些特性：（自动排序，不允许有重复数据）</li>
<li><em>有序列容器比，关联容器，一般是key,value关联起来组成的，个人看的一些理解，用来记忆一下，lionel，没找到官方的</em></li>
</ul>
<h4 id="19equalityequivalence">19、理解相等（equality）和等价（equivalence）的区别<a class="headerlink" href="#19equalityequivalence" title="Permanent link">&para;</a></h4>
<ul>
<li>find的相等是<code>operator==</code>，std::insert是<strong>等价</strong>，以<code>operator&lt;</code>为基础</li>
</ul>
<ul>
<li><strong>等价关系是以“在已排序的区间中对象值的相对顺序”为基础的</strong>。<em>不区分大小写？</em></li>
</ul>
<ul>
<li><em>没有完全看懂啊，lionel</em></li>
</ul>
<h4 id="20">20、为包含指针的关联容器指定比较类型<a class="headerlink" href="#20" title="Permanent link">&para;</a></h4>
<ul>
<li><code>set&lt;string *&gt; ssp;</code>是<code>set&lt;string *, less&lt;string*&gt;&gt; ssp;</code>，最精确的说，是<code>set&lt;string *, less&lt;string*&gt;, allocator&lt;string*&gt;&gt; ssp;</code>的缩写。
    + <strong>自己编写比较函数子类</strong></li>
</ul>
<h4 id="21false">21、总是让比较函数在等值情况下返回false<a class="headerlink" href="#21false" title="Permanent link">&para;</a></h4>
<h4 id="22setmultiset">22、切勿直接修改set或multiset中的键<a class="headerlink" href="#22setmultiset" title="Permanent link">&para;</a></h4>
<ul>
<li>set和multiset时，Key的值是<code>const</code>的</li>
</ul>
<h4 id="23vector">23、考虑用排序的vector替代关联容器<a class="headerlink" href="#23vector" title="Permanent link">&para;</a></h4>
<ul>
<li>如果只是单纯想查找用<strong>hash</strong>，<strong>关联容器是平衡二叉树</strong></li>
</ul>
<h4 id="24mapoperatormapinsert">24、当效率至关重要时，请在map::operator[]与map::insert之间谨慎做出选择<a class="headerlink" href="#24mapoperatormapinsert" title="Permanent link">&para;</a></h4>
<ul>
<li>map中的<code>operator[]</code>有问题啊</li>
</ul>
<h4 id="25">25、熟悉非标准的散列容器<a class="headerlink" href="#25" title="Permanent link">&para;</a></h4>
<ul>
<li>hash_set（标准库，没有啊）</li>
</ul>
<h3 id="part426-29">Part4、迭代器（26-29）<a class="headerlink" href="#part426-29" title="Permanent link">&para;</a></h3>
<p>0、
+ 为啥需要4种迭代器？iterator、const_iterator、reverse_iterator、const_reverse_iterator，<em>是不是废弃掉啦？</em></p>
<h4 id="26iteratorconst_iteratorreverse_iteratorconst_reverse_iterator">26、iterator优先于const_iterator、reverse_iterator及const_reverse_iterator<a class="headerlink" href="#26iteratorconst_iteratorreverse_iteratorconst_reverse_iterator" title="Permanent link">&para;</a></h4>
<ul>
<li>iterator优先使用</li>
</ul>
<h4 id="27distanceadvanceconst_iteratoriterator">27、使用distance和advance将容器的const_iterator转换成iterator<a class="headerlink" href="#27distanceadvanceconst_iteratoriterator" title="Permanent link">&para;</a></h4>
<ul>
<li>把const_iterator转换成iterator，<em>为啥不要用const呢？</em></li>
</ul>
<h4 id="28reverse_iteratorbaseiterator">28、正确理解由reverse_iterator的base()成员函数所产生的iterator的用法<a class="headerlink" href="#28reverse_iteratorbaseiterator" title="Permanent link">&para;</a></h4>
<h4 id="29istreambuf_iterator">29、对于逐个字符的输入请考虑使用istreambuf_iterator<a class="headerlink" href="#29istreambuf_iterator" title="Permanent link">&para;</a></h4>
<ul>
<li><code>istream_iterator</code>使用<code>operator&gt;&gt;</code>函数来完成实际的读操作，而默认情况下<code>operator&gt;&gt;</code>函数会跳过空白字符。</li>
</ul>
<h3 id="part530-37">Part5、算法（30-37）<a class="headerlink" href="#part530-37" title="Permanent link">&para;</a></h3>
<h4 id="30">30、确保目标区间足够大<a class="headerlink" href="#30" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>STL容器会自动扩充存储空间以容纳这些对象</strong>，但并不一定总是能正确管理，<em>如果user触发得不对，lionel</em></li>
<li><strong>插入型迭代器</strong></li>
</ul>
<h4 id="31">31、了解各种与排序有关的选择<a class="headerlink" href="#31" title="Permanent link">&para;</a></h4>
<ul>
<li>sort</li>
<li>qsort</li>
<li>partial_sort</li>
<li>nth_element</li>
<li>stable_sort</li>
<li>partiton</li>
<li><em>各种不同排序有其适合的场合，要注意，lionel</em></li>
</ul>
<h4 id="32removeerase">32、如果确实需要删除元素，则需要在remove这一类算法之后调用erase<a class="headerlink" href="#32removeerase" title="Permanent link">&para;</a></h4>
<h4 id="33remove">33、对包含指针的容器使用remove这一类算法时要特别小心<a class="headerlink" href="#33remove" title="Permanent link">&para;</a></h4>
<h4 id="34">34、了解哪些算法要求使用排序的区间作为参数<a class="headerlink" href="#34" title="Permanent link">&para;</a></h4>
<h4 id="35mismatchlexicographical_compare">35、通过mismatch或lexicographical_compare实现简单的忽略大小写的字符串比较<a class="headerlink" href="#35mismatchlexicographical_compare" title="Permanent link">&para;</a></h4>
<h4 id="36copy_if">36、理解copy_if算法的正确实现<a class="headerlink" href="#36copy_if" title="Permanent link">&para;</a></h4>
<h4 id="37accumulatefor_each">37、使用accumulate或者for_each进行区间统计<a class="headerlink" href="#37accumulatefor_each" title="Permanent link">&para;</a></h4>
<h3 id="part638-42">Part6、函数子、函数子类、函数及其他（38-42）<a class="headerlink" href="#part638-42" title="Permanent link">&para;</a></h3>
<h4 id="38">38、遵循按值传递的原则来设计函数子类<a class="headerlink" href="#38" title="Permanent link">&para;</a></h4>
<h4 id="39">39、确保判别式是“纯函数”<a class="headerlink" href="#39" title="Permanent link">&para;</a></h4>
<h4 id="40">40、若一个类是函数子，则应使它可配接<a class="headerlink" href="#40" title="Permanent link">&para;</a></h4>
<h4 id="41ptr_funmem_funmem_fun_ref">41、理解ptr_fun、mem_fun和mem_fun_ref的来由<a class="headerlink" href="#41ptr_funmem_funmem_fun_ref" title="Permanent link">&para;</a></h4>
<ul>
<li><em>不太会啊</em>，43用到了mem_fun_ref</li>
</ul>
<h4 id="42lesstoperator">42、确保<code>less&lt;T&gt;</code>与operator&lt;具有相同的语义<a class="headerlink" href="#42lesstoperator" title="Permanent link">&para;</a></h4>
<h3 id="part7stl43-50">Part7、在程序中使用STL（43-50）<a class="headerlink" href="#part7stl43-50" title="Permanent link">&para;</a></h3>
<h4 id="43">43、算法调用优先于手写的循环<a class="headerlink" href="#43" title="Permanent link">&para;</a></h4>
<ul>
<li>自己手写for循环，与调用<code>for_each()</code>算法</li>
</ul>
<ul>
<li>调用算法通常是更好的选择，它往往优先于任何一个手写循环，理由有3个：<ul>
<li>效率</li>
<li>正确性</li>
<li>可维护性</li>
</ul>
</li>
<li>STL有70个算法名称，<strong>知道（或查找到）每个算法的所做的事情</strong>，<em>现在是不是更多啦，在哪找？cppreference，lionel</em></li>
</ul>
<h4 id="44">44、容器的成员函数优先于同名的算法<a class="headerlink" href="#44" title="Permanent link">&para;</a></h4>
<ul>
<li>原因有2个：【算法和成员函数虽然有同样的名称，但它们所做的事情往往不完全相同】<ul>
<li>一，成员函数往往速度更快</li>
<li>二，成员函数通常与容器（特别是关联容器）结合得更加紧密</li>
</ul>
</li>
</ul>
<h4 id="45countfindbinary_searchlower_boundupper_boundequal_range">45、正确区分count、find、binary_search、lower_bound、upper_bound和equal_range<a class="headerlink" href="#45countfindbinary_searchlower_boundupper_boundequal_range" title="Permanent link">&para;</a></h4>
<h4 id="46stl">46、考虑使用函数对象而不是函数作为STL算法的参数<a class="headerlink" href="#46stl" title="Permanent link">&para;</a></h4>
<h4 id="47write-only">47、避免产生“直写型”（write-only）的代码<a class="headerlink" href="#47write-only" title="Permanent link">&para;</a></h4>
<h4 id="48include">48、总是包含（#include）正确的头文件<a class="headerlink" href="#48include" title="Permanent link">&para;</a></h4>
<h4 id="49stl">49、学会分析与STL相关的编译器诊断信息<a class="headerlink" href="#49stl" title="Permanent link">&para;</a></h4>
<h4 id="50stlweb">50、熟悉与STL相关的Web站点<a class="headerlink" href="#50stlweb" title="Permanent link">&para;</a></h4>
<h3 id="_1">参考书目<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<h3 id="_2">备注<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<ul>
<li>前置知识《CPP Primer》5th的chap9顺序容器。</li>
<li>2021-11-25花了50min整理形成了第1版。</li>
</ul>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../20C%2B%2B/effectiveC%2B%2B/" class="btn btn-neutral float-left" title="《Effective C++》"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../C%2B%2B%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/" class="btn btn-neutral float-right" title="《C++泛型STL原理和应用》">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../../20C%2B%2B/effectiveC%2B%2B/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../C%2B%2B%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
