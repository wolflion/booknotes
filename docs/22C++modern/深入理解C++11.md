## 《深入理解C++11》

### chap2、保证稳定性和兼容性

#### 2.1、保持与C99兼容

##### 2.1.1、预定义宏

+ `_STDC_HOSTED_`
+ `_STDC_`
+ `_STDC_VERSION_`
+ `_STDC_ISO_10646`

##### 2.1.2、`_func_`预定义标识符

+ `const char* hello(){return __func__;}`

##### 2.1.3、_Pragma操作符

+ `_Pragma(字符串字面量)`与`#pragma`功能相同

##### 2.1.4、变长参数的宏定义以及__VA_ARGS__

+ 变长参数的宏定义:指宏定义中参数列表的最后一个参数为省略号。
+ 预定义宏`__VA_ARGS__`则可以在宏定义的实现部分替换省略号所代表的字符串。
+ `#define PR(...) printf(__VA_ARGS__)`

##### 2.1.5、宽窄字符串的练接

+ 窄字符（char）与宽字符（wchar_t），会自动转换后再与宽字符运算。

#### 2.2、long long整型

+ 要了解平台上long long大小的方法就是查看<climits>（或<limits.h>）中的宏。
+ 2-2-1.cpp

#### 2.3、扩展的兼容性

#### 2.5、宏_cplusplus

#### 2.5、静态断言

##### 2.5.1、断言：运行时与预处理时

+ 在通常情况下，**断言**就是将一个返回值总是需要为真的判别式放在语句中，用于排除在设计的逻辑上不应该产生的情况。

+ 用宏`NDEBUG`来禁用assert宏。

+ `#error`预处理指令

  + ``` #ifndef _COMPLEX_H
        #error "Never use <bits/cmathcalls.h> directly; include <complex.h> instead."
        #endif
    ```

##### 2.5.2、静态断言与static_assert

+ **断言assert宏只有在程序运行时才能起作用。而#error只在编译器预处理时才能起作用**。
+ 2-5-2.cpp

#### 2.6、noexcept修饰符与noexcept操作符

+ noexcept修饰符
  + `void excpt_func() noexcept;`
  + `void excpt_func() noexcept(常量表达式)`

#### 2.7、快速初始化成员变量

+ C++11用`{}`

+ 2-7-1.cpp

#### 2.8、非静态成员的sizeof

+ **C++11中，非静态成员的sizeof操作是合法的**，C++98时则不行

#### 2.9、扩展的friend语法

+ **为类模板声明友元**

+ 2-9-1.cpp
+ 2-9-3.cpp

#### 2.10、final/override控制

+ final关键字作用：**使派生类不可覆盖它所修饰的虚函数**

+ 虚函数描述符override：**如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数**，否则代码将无法通过编译。

#### 2.11、模板函数的默认模板参数

#### 2.12、外部模板

##### 2.12.1、为什么需要外部模板

+ a.c中和b.c中都有`int i;`定义时，链接器在链接a.o和b.o时，会报错
  + b.c中可以直接`extern int i;`，这样生成的目标文件a.o和b.o中只有i这个符号的一份定义。
    + a.o中i是真实存在的
    + b.o中，只是记录了i符号会引用其他目标文件中数据区中的名为i的数据

##### 2.12.2、显式的实例化与外部模板的声明

+ 模板声明：`template<typename T> void fun(T){}`

+ 显式实例化：`template void fun<int>(int);`
+ 外部模板的声明：`extern template void fun<int>(int);`
  + **不能用于静态函数（即文件域函数）**，但可以用于**类静态成员函数**

#### 2.13、局部和匿名类型作模板实参

+ C++98中，局部的类型和匿名的类型都不做模板类的实参
+ **C/C++中，即使是匿名类型的声明，也需要独立的表达式语句**

#### 2.14、本章小结

### chap3、通用为本，专用为末

#### 3.1 继承构造函数

+ **基类的非虚函数则无法再被派生类使用**。
+ 如果派生类要使用基类的构造函数，通常需要在构造函数中显式声明。
  + ```struct A{A(int i){}};   struct B:A{B(int i):A(i){}};```
+ 基类只有一个构造函数 [3-1-1.cpp]()
+ 基类有多个构造函数 [3-1-2.cpp]()
+ 通过using声明[3-1-3.cpp]()
+ 改造3-1-2.cpp [3-1-4.cpp]()
+ **C++11标准继承构造函数被设计为跟派生类中的各种类默认函数（默认构造、析构、拷贝构造等）一样，都是隐式声明的**。
+ 同时使用继承构造函数和成员变量初始化两个C++11的特性[3-1-5.cpp]()
+ 对于继承构造函数来讲，参数的默认值是不会被继承的。[3-1-6.cpp]()  **参数默认值会导致多个构造函数版本的产生**
+ 继承函数“冲突”的情况 [3-1-7.cpp]()
+ [3-1-8.cpp]

#### 3.2 委派构造函数  86/336

+ 重复代码的构造函数 [3-2-1.cpp]()
+ C++11的写法[3-2-2.cpp]()
+ C++11调用基准版本的构造函数[3-2-3.cpp]()
  + **委派构造函数（delegating constructor）**就是指委派函数将构造的任务委派给了目标构造函数（“基准版本”）来完成这样一种类构造的方式。
+ **在C++中，构造函数不能同时“委派”和使用初始化列表，所以委派构造函数要给变量赋初值，初始化代码必须放在函数体中**。
+ [3-2-4.cpp]
+ **链状委托构造** [3-2-5.cpp]()
+ 委派构造一个很实际的应用就是使用构造函数产生目标构造函数。 [3-2-6.cpp]()
+ 在委派构造函数中使用try [3-2-7.cpp]()

#### 3.3 右值引用：移动语义和完美转发  92/336

##### 3.3.1、指针成员与拷贝构造

+ 类中包含了一个指针成员的话，**特别小心拷贝构造函数的编写**
+ 也就是深拷贝与浅拷贝的问题
  + 区别在于**自己实现，拷贝构造函数**，`HasPtrMem(const HasPtrMem& h) :d(new int(*h.d)) {}`

##### 3.3.2、移动语义

+ 3-3-3.cpp，多调了几次
+ 3-3-4.cpp，**“偷走”临时变量中资源的构造函数**，就被称为“移动构造函数”
  + 会把原来的内存置为nullptr

##### 3.3.3、左值、右值与右值引用

+ **表3-1**（C++11中引用类型及其可以引用的值类型），98/237，P79

##### 3.3.4、std::move，强制转化为右值

+ 相当于类型转换，`static_cast<T&&> (lvalue);`

##### 3.3.5、移动语义的一些其他问题

+ C++11中，拷贝/移动构造函数实际上有3个版本
  + `T Object(T &)`
  + `T Object(const T &)`
  + `T Object(T &&)`

##### 3.3.6、完美转发

+ **perfect forwarding**，在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另外一个函数。

+ **表3-2**（C++11中的引用折叠规则）

#### 3.4、显式转换操作符

#### 3.5、列表初始化

##### 3.5.1、初始化列表

##### 3.5.2、防止类型收窄

#### 3.6 POD类型  124/336

+ C++11将POD（Plain Old Data）划分为
  + 平凡的（trivial）
    + 1）拥有平凡的默认构造函数、析构函数
    + 2）拥有平凡的拷贝构造函数和移动构造函数
    + 3）拥有平凡的拷贝赋值运算符和移动赋值运算符
    + 4）不能包含虚函数以及虚基类
  + 标准布局的（standard layout）
    + 1）所有非静态成员有相同的访问权限
    + 2）在类或者结构体继承时，满足以下两种情况之一：
      + 派生类中有非静态成员，且只有一个仅包含静态成员的基类
      + 基类有非静态成员，而派生类没有非静态成员
    + 3）类中第一个非静态成员的类型与其基类不同
    + 4）没有虚函数和虚基类
    + 4）所有非静态数据成员均符合标准布局类型，其基类也符合标准布局
+ [3-6-1.cpp]
+ POD的好处
  + 1）字节赋值
  + 2）提供对C内存布局兼容
  + 3）保证了静态初始化的安全有效

#### 3.7、非受限联合体

+ C++98中，**非POD类型、联合体不能拥有静态或引用类型的成员**
+ 3-7-1.cpp，不是POD类型的原因，是**结构体里定义了构造函数**

#### 3.8、用户自定义字面量

#### 3.9、内联名字空间

#### 3.10、模板的别名

+ 除了`typedef`，还可以用`using`，例`using uint = unsigned int;`

#### 3.11、一般化的SFINEA规则

+ **SFINEA**（Substitution failure is not an error），匹配失败不是错误，**重载的模板的参数进行展开的时候，如果展开导致了一些类型不匹配，编译器并不会报错**

#### 3.12、本章小结

### chap4、新手易学，老兵易用

#### 4.1、右尖括号>的改进

+ C++98中会将`>>`优先解析为右移。C++11能智能识别是不是右移。

+ 右移操作的时候，最好还是用括号括起来。比如`(1>>5)`

+ 4-1-1.cpp

  ```cpp
  template <int i> class X{};
  template <class T> class Y{};
  Y<X<1> > x1;//compile success
  Y<X<2>> x2; // compile failure
  // g++ -c 4-1-1.cpp
  ```

+ 代码清单4-2

  ```cpp
  template <int i> class X {};
  X <1 >> 5> x;  // C++98这个>>是位移操作，C++11报错
  ```

#### 4.2、auto类型推导

##### 4.2.1、静态类型、动态类型与类型推导

+ 静态类型和动态类型的区别在于对变量进行类型检查的时间点。**静态检查主要发生在编译阶段；动态类型检查主要发生在运行阶段**。

+ [4-3.cpp]

+ `auto`早期C/C++标准的解释，具有自动存储期的局部变量。**auto声明变量的类型必须由编译器在编译时期推导而得**。

+ [4-2-2.cpp]

  ```cpp
  int main(){
      double foo();
      auto x = 1;    //int  【本来是const int，const被省了】
      auto y = foo(); // double
      struct m { int i; }str;
      auto str1 = str;  // struct m
      auto z;  // 无法推导，无法通过编译
      z = x;
  }
  ```

  // g++ -std=c++11 4-2-2.cpp

+ **auto并非一种“类型”声明，而是一个类型声明时的“占位符”**。

##### 4.2.2、auto的优势

+ 1、在拥有初始化表达式的复杂类型变量声明时简化代码。
  + `std::vector<std::string>::iterator i=`可以简写成`auto i=`
+ 2、免除程序员在一些类型声明时的麻烦，或者避免一些在类型声明时的错误。
  + *可能存在精度被扩展的情况*，**但不能解决所有问题**
  + [4-2-6.cpp]
+ 3、其“自适应”性能够在一定程度上支持泛型的编程。
  + [4-2-7.cpp]
+ 4、其它好处

##### 4.2.3、auto的使用细则

+ auto可以与指针和引用结合起来使用
  + [4-2-9.cpp]
+ C++11中只保留了**auto作为类型指示符的用法**，`auto int i=1;`就会报错

#### 4.3、decltype

##### 4.3.1、typeid与decltype

+ C++98对动态类型支持就是C++中的运行时类型识别（RTTI）。

+ RTTI的机制是为每个类型产生一个type_info类型的数据，程序员可以在程序中使用typeid随时查询一个变量的类型，typeid就会返回变量相应的type_info数据。

+ [4-3-1.cpp]

+ **类型推导是随着模板和泛型编程的广泛使用而引入的**。

+ [4-3-2.cpp]

+ **decltype的类型推导并不是像auto一样是从变量声明开始的初始化表达式获得变量的类型，decltype总是以一个普通的表达式为参数，返回该表达式的类型。

  ```cpp
  int i;
  decltype(i) j = 0;
  ```

##### 4.3.2、decltype的应用

+ decltype与typedef/using的合用

```cpp
using size_t = decltype(sizeof(0));
using ptrdiff_t = decltype((int*)0-(int*)0);
using nullptr_t = decltype(nullptr);
```

##### 4.3.3、decltype推导四规则

+ null

```cpp
int i;
decltype((i)) b;  // b int &，无法编译通过
```

+ 依序判断以下四规则：

  + 如果e是一个没有带
  + 否则，假设e的类型是T，如果e是一个
  + 否则，假设e的类型是T，如果e是一个
  + 否则，假设e的类型是T，则decltype(e)为T。

##### 4.3.4、cv限制符的继承与冗余的符号

+ [4-3-12.cpp]

#### 4.4、追踪返回类型

##### 4.4.1、追踪返回类型的引入

##### 4.4.2、使用追踪返回类型的函数

+ 4-4-1.cpp，*的好处在哪，我都没懂*

#### 4.5、基于范围的for循环

+ `for_each`模板函数，**使用了迭代器的概念**，因为含有自增操作
  + `for_each(arr,arr+sizeof(arr)/sizeof(arr[0]),action1);  int action1(int &e){ e*=2;}`
+ `for(int &e:arr)  //第一部分是范围内用于迭代的变量，第二部分则表示将被迭代的范围`
  + **for循环迭代的范围是可确定的**，数组大小不确定的话，不能使用基于范围的for循环
+ [4-5-5.cpp]
  + 注意**迭代器**是指针，要用的话必须加星`*`

#### 4.6、本章小结

### chap5、提高类型安全

#### 5.1、强类型枚举

##### 5.1.1、枚举：分门别类与数值的名字

+ 当程序中需要“数值的名字”的时候，我们常常可以使用以下3种方式来实现
  + 第一种：宏
  + 第二种：匿名枚举  `enum {Male, Female};`
  + 第三种：静态常量  `const static int Male = 0;`

##### 5.1.2、有缺陷的枚举类型

+ [5-1-1.cpp]
+ [5-1-2.cpp]
+ [5-1-3.cpp]
+ [5-1-4.cpp]

##### 5.1.3、强类型枚举以及C++11对原有枚举类型的扩展

+ 非强类型作用域，允许隐式转换为整型，占用存储空间及符号性不确定，都是**枚举类的缺点**。
+ **枚举类**，也叫“强类型枚举”。`enum class Type{General,Light,Medium,Heavy};`
+ **匿名的enum class可能什么都做不了** [5-1-7.cpp]

#### 5.2、堆内存管理：智能指针与垃圾回收

##### 5.2.1、显式内存管理

+ 野指针：
+ 重复释放：
+ 内存泄漏：

##### 5.2.2、C++11的智能指针

+ C++98中，通过一个模板类型"auto_ptr"实现。
  + `auto_ptr(new int);`，**缺点是，拷贝时返回一个左值、不能调用`delete[]`**
+ C++11中改用unique_ptr、shared_ptr及weak_ptr等智能指针来自动回收堆分配的对象。
+ [5-2-1.cpp]
+ [5-2-2.cpp]

##### 5.2.3、垃圾回收的分类

+ 1、基于引用计数（reference counting garbage collector）的垃圾回收器
+ 2、基于跟踪处理（tracing garbage collector）的垃圾回收器
  + 标记-清除（Mark-Sweep）
  + 标记-整理（Mark-Compact）
  + 标记-拷贝（Mark-Copy）

##### 5.2.4、C++与垃圾回收

+ C/C++垃圾回收库-Boehm

##### 5.2.5、C++11与最小垃圾回收支持

+ `get_pointer_safety()`原型
+ `declare_reachable()`，显式地通知垃圾回收器某一个对象应被认为可达的。
+ `undeclare_reachable<int>`，*这个没怎么用过*

##### 5.2.6、垃圾回收的兼容性

+ 只回收new的，malloc分配的不回收

#### 5.3、本章小结

+ C++11也想搞**全面的垃圾回收**，但目前只能**最小垃圾回收支持**

### chap6、提高性能及操作硬件的能力  

#### 6.1、常量表达式

##### 6.1.1、运行时常量性与编译时常量性

+ **const是运行时常量**
  + 6-01-01.cpp
  + 6-01-02.cpp
+ `constexpr`是**编译时期常量**，即常量表达式

##### 6.1.2、常量表达式函数

+ 常量表达式函数的情况
  + 函数体只有单一的return返回语句
  + 函数必须返回值（不能是void函数）
  + 在使用前必须已有定义
  + return返回语句表达式中不能使用非常量表达式的函数、全局数据，且必须是一个常量表达式

+ 6-01-03.cpp

##### 6.1.3、常量表达式值

+ `const int i=3;`与`constexpr int j=1;`有什么区别
  + 如果i在全局名字空间中，编译器一定会为i产生数据。
  + 而对于j，如果不是有代码显式地使用了它的地址，编译器可以选择不为它生成数据，而仅将其当做编译时期的值
+ 常量表达式的构造函数也有使用上的约束
  + 函数体必须为空
  + 初始化列表只能由常量表达式来赋值
+ 6-01-05.cpp

##### 6.1.4、常量表达式的其他应用

+ 6-01-06.cpp

#### 6.2、变长模板

##### 6.2.1、变长函数和变长的模板参数

##### 6.2.2、变长模板：模板参数包和函数参数包

##### 6.2.3、变长模板：进阶

#### 6.3、原子类型与原子操作

##### 6.3.1、并行编程、多线程与C++

##### 6.3.2、原子操作与C++11原子类型

##### 6.3.3、内存模型，顺序一致性与memory_order

#### 6.4、线程局部存储

#### 6.5、快速退出：quick_exit与at_quick_exit

#### 6.6、本章小结

### chap7、

#### 7.1、指针空值-nullptr

##### 7.1.1、指针空值：从0到NULL，再到nullptr

+ [7-1-1.cpp]
+ [7-1-2.cpp]

##### 7.1.2、nullptr和nullptr_t

+ nullptr是指针空值常量
+ nullptr_t是指针空值类型
+ [7-1-3.cpp]

##### 7.1.3、一些关于nullptr规则的讨论

+ nullptr类型数据所占用的内存空间大小跟void*相同，`sizeof(nullptr_t) == sizeof(void*)`
+ nullptr是一个编译时期的常量，它的名字是一个编译时期的关键字，能够为编译器所识别。`(void*)0`只是一个强制转换表达式，其返回的也是一个void*指针类型。

#### 7.2、默认函数的控制

##### 7.2.1、类与默认函数

##### 7.2.2、

#### 7.3、lambda函数   261/336

##### 7.3.1、lambda的一些历史

+ 希腊字母表中位于第11位，**lambda则是被用来表示一种匿名函数**。

##### 7.3.2、C++11中的lambda函数

+ `[capture](parameters) mutable ->return-type{statement}`，具体`auto totalChild = [](int x, int y) ->int{return x + y; };`

##### 7.3.3、lambda与仿函数

+ **仿函数**简单地说，就是重定义了成员函数operator()的一种自定义类型对象。**不是函数名称，而是对象名称**。

##### 7.3.4、lambda的基础使用

+ [7-3-7.cpp]
+ lambda函数等同于一个“局部函数”。

##### 7.3.5、关于lambda的一些问题及有趣的实验

+ [7-3-9.cpp]

##### 7.3.6、lambda与STL

+ [7-3-13.cpp]

##### 7.3.7、更多的一些关于lambda的讨论

### chap8、融入实际应用

#### 8.1、对齐支持

##### 8.1.2、C++11的alignof和alignas

+ alignof的操作数表示一个定义完整的自定义类型或者内置类型或者变量，返回的值是一个std::size_t类型的整型常量。**也是一个与平台相关的值**
+ 对齐描述符alignas，**既可以接受常量表达式，也可以接受类型作为参数**

#### 8.2、通用属性

##### 8.2.2、C++11的通用属性

##### 8.2.3、预定义的通用属性

+ `[[noreturn]]`和`[[carries_dependency]]`

#### 8.3、Unicode支持

#### 8.4、原生字符串字面量

#### 8.5、本章小结

### 最后

+ 2019年3月就零星看了些，**没有形成知识网**，2023年11月准备花1个月整理一下。