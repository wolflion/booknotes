## 《提高C++性能的编程技术》

### chap1、跟踪实例

+ 定义一个简单的Trace类将诊断信息打印到日志文件中

```cpp
#ifdef TRACE
Trace t("myFunction");
t.debug("some information message");
#endif
```

+ **使用ifdef的不足之处在于，必须重新编译程序来打开或关闭跟踪**。
+ `t.debug("x="+itoa(x));`，存在性能问题，**即使关闭了跟踪，仍然要创建string参数来传递给debug()函数**
  + 为"x="创建一个临时string对象
  + 调用itoa()
  + 从itoa()返回的字符指针创建一个临时的string对象
  + debug()调用返回后销毁全部三个string临时对象

#### 1.1、初步跟踪的实现

##### 1.1.1、到底怎么了？

+ 有几个公认的基本原则：
  + I/O的开销是高昂的
  + 函数调用的开销是要考虑的一个因素，应将短小的、频繁调用的函数内联
  + 复制对象的开销是高昂的。**最好选择传递引用，而不是传递值**。

##### 1.1.2、恢复计划

#### 1.2、要点

+ 不要把精力浪费在计算结果根本不会被使用的地方。

### chap2、构造函数和析构函数

+ 继承和复合与**代码重用**有关，可重用代码会在某种特定场合下计算某些不需要的数据。

#### 2.1、继承

#### 2.2、符合

2.3、缓式构造

2.4、冗余构造

2.5、要点

### chap3、虚函数

#### 3.1、虚函数的构造

+ 在以下几个方面，虚函数可能会造成性能损失：
  + 构造函数必须初始化vptr
  + 虚函数是通过指针间接调用的
  + 内联是在编译时决定的
+ *无法内联*

#### 3.2、模板和继承

+ **消除动态绑定的一种方法**是用**基于模板的设计**来替代继承。

##### 3.2.1、

##### 3.2.2、

##### 3.2.3、模板

+ 模板把计算 从执行期间提前到编译期间来做，并且在编译时使用内联，因此提高了性能。

3.3、要点

### chap4、返回值优化

+ **只要能跳过对象的创建和消除**就可以提高性能。

#### 4.1、按值返回机制

+ c1,c2,c3都是Complex对象，`c3=c1+c3;`，编译器通常使用的是**创建临时对象`__result`，并把它作为第三个参数传给`Complex::operator+()`

#### 4.2、返回值优化

+ RVO消除了局部对象retVal，并且省去了构造函数和析构函数的计算。
+ 两个版本的`operator+`，4个版本呢

#### 4.3、计算性构造函数

+ 当编译器无法执行RVO时，可按计算性构造函数的形式来实现。

4.4、要点

### chap5、临时对象

+ 编译器总是悄无声息地生成临时对象

#### 5.1、对象定义

5.2、类型不匹配

5.3、按值传递

5.4、按值返回

#### 5.5、使用op=()消除临时对象

+ `s5 = s1+s2+s3+s4;//产生3个临时对象`，改成`s5 = s1;  s5+=s2; s5+=s3; s5+=s4;`

5.6、要点

chap6、单线程内存池

### chap15、可扩展性

#### 15.1、对称多处理器架构

+ 解决总线竞争的办法是每个处理器使用大型缓存。

#### 15.2、Amdahl定律

+ 矩阵乘法由三个步骤组成
  + 初始化
  + 乘法
  + 显示

#### 15.3、多线程和同步

+ 不合适的交叉执行线程被称为**竞争条件**
+ 为了解决竞争条件，要保证这些汇编代码是原子执行的，称这些代码块为**临界区**
+ 一旦A线程进入临界区，B进程只能等待A退出后再进入，称**AB两个线程是同步的（串行化的）**，同时**该临界区是互斥的**
+ 变量x可以被多个线程访问，称它为**共享数据**，为了共享数据的安全，**使用锁（一个标记、比特位或整型）**与共享数据相关联
+ 临界区由锁来保护时，称它的执行是顺序执行的
+ *什么是同步，（让多条线程按照某个顺序执行 【它们之间会相互协调】）-搜的，lionel*
  + 互斥锁（同一时刻只有一个线程）
  + 条件变量（线程间协调，条件满足时唤醒）
  + 信号量（共享资源的数量）

#### 15.4、将任务分解为多个子任务

#### 15.5、缓存共享数据

#### 15.10、惊群现象

+ 当锁最后变得可用时，将会发生什么呢？
  + 只有一个线程被唤醒，它一般是等待队列上优先级最高的线程
  + 所有的线程都被唤醒，这会导致**惊群现象**（Thundering Herd）
+ *对于分布式系统，也有惊群，就是某个节点负载过大，导致其它服务也会负载太大，-搜的，lionel*
+ *LT模式下的惊群，是不是不以杜绝，只能减少？-搜的，lionel*
+ 我们描述服务器有**接收-服务-记录**三个阶段时，**在接收阶段使用单线程**就是为试图避免“惊群现象”
+ **当服务器线程接受新的TCP/IP连接时，必须执行accept()调用**。告诉TCP/IP调用线程会在一个特定的TCP/IP端口接受下一个可用连接

#### 15.11、读/写锁

+ 线程对共享数据进行读访问必须满足以下条件之一：
  + 没有其他线程访问数据
  + 所有访问数据的线程都是读者线程

#### 15.12、要点

+ 减少或者消除顺序化的代码，**步骤**
  + 任务分解
  + 代码移出
  + 利用缓存
  + 无共享

### 最后

#### 履历

+ 2023-12-13看到人家的推荐，觉得是本好书，于是赶紧读起来。