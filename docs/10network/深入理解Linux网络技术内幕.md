## 《深入理解Linux网络技术内幕》

+ *是不是看看2.2或2.4的代码内核*
+ 本书框架
  + P1、基础背景（1-3），**先记一下**
    + 1、简介
    + 2、关键数据结构
      + sk_buffer，net_devcie结构，*要不要记它们呢，感觉也没必要*
    + 3、用户空间与内核的接口
      + ioctl知道，netlink（*后面看书知道的*），
  + P2、系统初始化（4-8），**基础，先记一下**【想办法，自己再融合一下】
    + 4、通知链是个基础，*相对本节是个独立的*
    + 5、网络设备初始化（*是整个吗*）
    + 6、PCI层（毕竟网卡是pci口的），**PCI设备驱动注册，网络唤醒，电源管理**
    + 7、*本节标题不太懂*
    + 8、设备的注册和初始化
      + *这个地方跟net_deive会有什么关系呢*
  + P3、传输和接收（9-13），*投了一点，不太开窍，算是流程方面吧*
  + P4、桥接（14-17），*未投，没开窍*
  + P5、IPv4（18-25），*已投，有感觉*  【核心是rfc791】
    + 18、概念（报头、选项、分段/重组、检验和）
      + rfc791里确实是写的这些
    + 19、Linux原理与功能（IP数据结构、封包的处理过程，IP选项）
      + 后两点，rfc791里有，*第1个数据结构，不太明白*
    + 20、转发和本地传递（*未接触过*）
    + 21、传输（*未接触过*）
      + **与邻居子系统衔接**，这个比较重要，*自认为*
    + 22、处理分段（分段与重组）
      + rfc791上有例子
    + 23、其它主题
      + *有点松散，未看*
    + 24、L4和Raw IP处理
      + *未看*
    + 25、ICMPv4
      + *有单独的rfc*
  + P6、邻居子系统（26-29），*2024-01投了，未开窍*
  + P7、路由（30-36），**算是应用的重点，最后再看吧*

### chap1、简介

#### 1.1、基本术语

+ RX（接收），TX（传输）

#### 1.2、常见编码模式

+ 内存缓存
  + kmalloc和kfree
  + skb_init()
  + kmem_cache_create/kmem_cache_destroy
  + kmem_cache_alloc/kmem_cache_free
+ 缓存和hash表
+ 引用计数
  + xxx_hold/xxx_release
  + xxx_put有时也是释放
+ 垃圾收集
  + 异步
  + 同步
+ 函数指针和虚拟函数表（VFT）
  + **指向一个数据结构的一组函数指针**通常就被称为VFT
+ goto语句
+ 向量定义
+ 条件指示指令（#ifdef及其系列指令）
+ 条件检查的编译期间最优化
  + likely或unlikely宏
+ 互斥
  + 回转锁（Spin lock）
  + 读-写回转锁
  + 读取（拷贝）更新（Read-Copy-Update,RCU）
+ 主机和网络之间的尾端转换
  + 小尾端（*小弟弟*），**最低字节存储在最低内存地址**
+ 捕获bug
+ 统计数据
+ 测量时间

#### 1.3、用户空间工具

+ iputils
+ net-tools
+ IPROUTE2

#### 1.4、浏览源代码

+ cscope
+ **死代码**（已经不在使用了）

#### 1.5、当功能以补丁形式提供时

### chap2、关键数据结构

#### 2.1、套接字缓冲区：sk_buff结构

##### 0

##### 2.1.1、网络选项以及内核结构

+ `struct sk_buff{}`

##### 2.1.2、布局字段

+ `struct sk_buff_head{}`，**哑元元素**
+ sk_buff其它感兴趣的字段
  + struct sock *sk
  + unsigned int len
  + unsigned int data_len
  + unsigned int mac_len
  + atomic_t users
  + unsigned int truesize
  + unsigned int *head
  + unsigned char *end
  + unsigned char *data
  + unsigned char *tail
  + void (*destructor)(...)

##### 2.1.3、通用字段

+ **即与内核无关**

##### 2.1.4、功能专用字段

##### 2.1.5、管理函数

+ 0
+ 分配内存：alloc_skb和dev_alloc_skb
  + net/core/skbuff.c中
+ 释放内存：kfree_skb和dev_kfree_skb
+ 数据预留及对齐：skb_reserve, skb_put,skb_push以及skb_pull
+ skb_shared_info结构和skb_shinfo函数
+ 缓冲区的克隆和拷贝
+ 列表管理函数

#### 2.2、net_device结构

##### 0

##### 2.2.1、标识符

+ int ifindex  **dev_new_index注册时分派**
+ int iflink  **（虚拟）隧道设备**
+ unsigned short dev_id

##### 2.2.2、配置

+ 0
+ 接口类型与端口

##### 2.2.3、统计数据

##### 2.2.4、设备状态

##### 2.2.5、列表管理

##### 2.2.6、链路层多播

##### 2.2.7、流量管理

##### 2.2.8、功能专用

##### 2.2.9、通用

##### 2.2.10、函数指针（或VFT）

#### 2.3、本章涉及的文件

+ include/linux
  + if.h
  + if_packet.h
  + skbuff.h
  + netdevice.h
  + slab.h
  + if_arp.h
+ kernel
  + time.c
  + dma.c
+ mm
  + slab.c
+ drivers
  + 3c59x.c
  + tulip.c
  + sys9000.c
+ net/core
  + skbuff.c

### chap3、用户空间与内核的接口

#### 3.1、概论

+ 把内部信息传输给用户空间，除了**系统调用**外，还有3种
  + procfs **虚拟文件系统**，/proc文件系统
  + sysctl /proc/sys目录
  + sysfs  /sys文件系统

#### 3.2、procfs与sysctl

##### 3.2.1、procfs

##### 3.2.2、sysctl：目录/proc/sys

+ 0
+ ctl_table初始化的实例
+ 在/proc/sys中注册文件
+ 核心网络文件和目录

#### 3.3、ioctl

#### 3.4、Netlink

+ 对应的rfc 3549
+ `socket()`中使用的是`PF_NETLINK`协议族

#### 3.5、配置改变串行化

### chap4、通知链

#### 4.1、使用通知链的原因

#### 4.2、概论

+ **通知链就是一份简单的函数列表**

+ 就每条通知链而言，都有被动端（被通知者）和主动端（通知者），也就是**发布-订阅**（publish-and-subscriber）模型
  + 被通知者（notified）就是要求接收某事件的子系统，而且会提供回调函数予以调用
  + 通知者（notifier）就是感受到一个事件并调用回呼函数的子系统

#### 4.3、定义链

+ `struct notifer_block{};`

#### 4.4、链注册

+ notifier_chain_register + 包裹函数
+ notifer_chain_unregister + 包裹函数
+ notifer_call_chain
+ **对通知链的访问受到notifier_lock锁的保护**。

#### 4.5、链上的通知事件

#### 4.6、网络子系统的通知链

+ 定义了至少10种，主要有
  + inetaddr_chain，**本地接口上的IPv4地址的插入、删除以及变更**的通知信息
  + netdev_chain，**网络设备注册状态**的通知信息

##### 包裹函数

+ 大多数通知链都有一组包裹函数，可以用于注册和删除

##### 范例

#### 4.7、通过/proc文件系统的调整

#### 4.8、本章涉及的函数和变量

+ 函数和宏
  + 前2个是 注册和删除回调处理程序， 第3个是  送出特定种类事件的所有通知信息
  + notifier_chain_register + 包裹函数
  + notifer_chain_unregister + 包裹函数
  + notifer_call_chain
+ 数据结构
  + struct notifier_block

#### 4.9、本章涉及的文件和目录

+ usr/src/linux
  + net
    + /core/dev.c
    + /ipv4/devinet.c
  + kernel/sys.c
  + include/linux/netfilter.h

### chap5、网络设备初始化

#### 5.1、系统初始化概论

+ 各种初始化中，感兴趣的有3个
  + 引导期间选项
  + 中断和定时器
  + 初始化函数

#### 5.2、设备注册和初始化

+ 初始化的阶段
  + 硬件初始化
  + 软件初始化
  + 功能初始化

#### 5.3、NIC初始化的基本目标

#### 5.4、设备与内核之间的交互

#### 5.5、初始化选项

#### 5.6、模块选项

#### 5.7、设备处理层初始化：net_dev_init

#### 5.8、用户空间辅助程序

#### 5.9、虚拟设备

#### 5.10、通过/proc文件系统调整

#### 5.11、本章涉及的函数的变量

#### 5.12、本章涉及的文件和目录

### chap6、PCI层和网络接口卡

#### 6.1、本章涉及的数据结构

#### 6.2、PCI NIC设备驱动程序的注册

#### 6.3、电源管理和网络唤醒

#### 6.4、PCI NIC驱动程序注册范例

#### 6.5、大蓝图

#### 6.6、通过/proc文件系统调整

#### 6.7、本章涉及的函数的变量

#### 6.8、本章涉及的文件和目录

### chap7、组件初始化的内核基础架构

#### 7.1、引导期间的内核选项

#### 7.2、模块初始化代码

#### 7.3、优化宏卷标

#### 7.4、内存最优化

#### 7.5、通过/proc文件系统调整

#### 7.6、本章涉及的函数和变量

#### 7.7、本章涉及的文件和目录

### chap8、设备注册和初始化

#### 8.1、设备注册之时

#### 8.2、设备除名之时

#### 8.3、分配net_device结构

#### 8.4、NIC注册和除名的架构

### chap9、中断和网络驱动程序

+ *lionel，本章讲的是，处理L2层的帧的函数，是由中断事件驱动的*

#### 9.1、决策与流量方向

+ 网络协议栈所走向路径，会根据，封包会分为几种情况，**接收的、传输的、转发的**，而不同。
+ 虚拟设备呢，*lionel想一下*
+ 图9.2怎么看懂，*lionel*

#### 9.2、接收到帧时通知驱动程序

+ 设备与内核使用两种技术来交换数据，**轮询和中断**

##### 9.2.1、轮询

##### 9.2.2、中断

##### 9.2.3、在中断期间处理多帧

+ **当驱动程序运行时中断功能会关闭**
+ *lionel，为何采用NAPI*

##### 9.2.4、定时器驱动的中断事件

##### 9.2.5、组合

##### 9.2.6、范例

+ drivers/net/3c59x.c中的`vortex_interrupt()`

#### 9.3、中断处理函数

##### 9.3.1、下半部函数存在的原因

9.3.2、下半部解决方案

9.3.3、并发和上锁

9.3.4、抢占功能

9.3.5、下半部函数

##### 9.3.6、微任务

+ include/linux/interrupt.h中的`tasklet_struct`结构

9.3.7、软IRQ初始化

9.3.8、未决软IRQ的处理

9.3.9、依体系结构处理软IRQ

9.3.10、微任务的处理

##### 9.3.11、网络代码如何使用软IRQ

+ 在net_dev_init中注册
  + `open_softirq(NET_TX_SOFTIRQ, net_tx_action, NULL);`，处理出去的流程
  + `open_softirq(NET_RX_SOFTIRQ, net_rx_action, NULL);`，处理进来的流程

#### 9.4、softnet_data结构

+ **每个CPU都有其队列，用来接收进来的帧**
+ include/linux/netdevice.h中的

##### 9.4.1、softnet_data的字段

##### 9.4.2、softnet_data的初始化

+ 每个CPU的softnet_data结构是由dev.c中的`net_dev_init`在引导期间执行初始化的

### chap10、帧的接收

#### 10.1、与其他功能交互

#### 10.2、设备的开启与关闭

+ net_device->state中的`__LINK_STATE_START`标识

#### 10.3、队列

+ 回环设备，不需要队列就能工作
+ **流量控制（QoS层）会为每个设备都定义一个队列**

#### 10.4、通知内核帧已接收：NAPI和netif_rx

##### 0、

##### 10.4.1、NAPI简介

+ NAPI背后的主要想法：**混合使用中断事件和轮询，而不使用纯粹的中断事件驱动模型**。

##### 10.4.2、NAPI所用之net_device字段

10.4.3、net_rx_action和NAPI

10.4.4、新旧驱动程序接口

10.4.5、操作poll_list

#### 10.5、设备驱动程序与内核间的旧接口：netif_rx的第一部分

10.5.1、net_rx的初始任务

10.5.2、管理队列以及下半部调度

#### 10.6、拥塞管理

##### 10.6.1、netif_rx中的拥塞管理

##### 10.6.2、平均队列长度及拥塞等级计算

#### 10.7、处理NET_RX_SOFTIRQ：net_rx_action

##### 10.7.1、积压的处理：process_backlog轮询虚拟函数

##### 10.7.2、入口帧的处理

### chap11、帧的传输

#### 11.1、传输的开启和关闭

##### 11.1.1、设备调度以准备传输

##### 11.1.2、队列规则接口

##### 11.1.3、dev_queue_xmit函数

##### 11.1.4、处理NET_TX_SOFTIRQ：net_tx_action

### chap12、中断事件一般性参考数据

12.1、统计数据

12.2、通过/proc和sysfs文件系统调整

#### 12.3、本章涉及的函数和变量

#### 12.4、本章涉及的文件和目录

### chap13、协议处理函数

#### 13.1、网络协议栈概论

#### 13.2、执行正确的协议处理函数

#### 13.3、协议处理函数的组织

#### 13.4、协议处理函数的注册

#### 13.5、Ethernet与IEEE802.3帧

#### 13.6、通过/proc文件系统进行调整

#### 13.7、本章涉及的函数和变量

#### 13.8、本章涉及的文件和目录

### chap14、桥接：概念

### chap15、桥接：生成树协议

### chap16、桥接：Linux实现

chap17、桥接：其它主题

### chap18、IPv4：概念  413（431/1016）

+ 本章说明IP协议的作用（*我的理解就是，分段和组装吧，然后再配合一些ip options的处理规则？*）

#### 18.1、IP协议：大蓝图

+ **图18.1**，IP内核协议栈的关键函数，（涉及到**邻居子系统**Neighboring和**流量控制子系统**Traffic Control）
+ IP协议的任务
  + 健康检查（校验和不准确，就被丢掉）
  + 防火墙（**封包生存期中调用**，Netfilter子系统）
  + 处理选项
  + 分段/重组（**不同的网络，MTU大小不一定一样，64kB**）
  + 接收、传输以及转发操作（*rfc里提到了recv和send，但没具体讲怎么实现*）

#### 18.2、IP报头

+ *先不看*

#### 18.3、IP选项

+ *为何要有IP选项，现在的使用度还多不多？*

##### 0、

+ 单字节
+ 多字节

##### 18.3.1、End of Option List和No Operation选项

##### 18.3.2、“Source Route"选项

##### 18.3.3、Record Route选项

18.3.4、“Timestamp“选项

18.3.5、Router Alert选项

#### 18.4、封包的分段/重组

+ 最大尺寸是64KB，*分段，要分成尺寸相等的吗？MF和OFFSET字段，在rfc791里看到过，但不熟悉*
  + *图18-10，为啥`offset=n*mtu/4，不太理解其中细节`

##### 18.4.1、分段对较高分层的效应

+ 每个片段都要包含L2和L3报头。
+ **理论上，较高分层不知道L3层何时决定把封包分段**
+ *为何MTU设成一个相当安全的小值576？*

##### 18.4.2、分段/重组所用的IP报头字段

+ DF
+ MF
+ OFFSET，片段偏移量
+ ID，封包ID

##### 18.4.3、分段/重组的问题实例

+ **分段比较简单**（只需选出适当的值以匹配MTU），*重点是组装，正好这个过程，我没看*

###### 重新传输

###### 把片段和其IP封包相关联

###### IP ID生成范例

###### 无法解决的重组问题范例：NAT

##### 18.4.4、路径MTU发现

+ 涉及跨LAN的情况，会存在不同的MTU大小，**封包传输至指定目的地址而不用被分段的最大尺寸**称为**路径MTU**（Path MTU）

#### 18.5、检验和

+ *这部分，rfc791有讲，但自己还没怎么看*
+ 校验和比较弱，依靠**L2 CRC或者SSL/IPSec MACs（Message Authentication Codes）消息鉴定码**

+ **IP协议的校验和只包括IP报头**
+ 触发校验和更新需求的情况
  + 递减TTL
  + 封包调整（包括NAT）
  + IP选项的处理
  + 分段

##### 18.5.1、用于校验和计算的API

+ 用于计算或更新IP校验和的主要函数
  + ip_compute_sum
  + ip_fast_ssum

##### 18.5.2、对L4校验和所做的修改

### chap19、IPv4：Linux的原理和功能  442（460/1016）

#### 19.1、主要IPv4数据结构

+ *这些结构从哪来的？*

##### 19.1.1、sk_buff和net_device结构里与检验和相关的字段

+ *这部分没太看懂，是不是因为没看rfc791的checksum有关*

###### net_device结构

###### sk_buff结构

+ 取决于skb是指向已接收封包还是已传输出的封包而定

#### 19.2、封包的一般性处理

+ *封包，我还没看rfc791呢*

##### 19.2.1、协议初始化

+ `ip_init()`，**IPv4功能无法从内核中删除**

##### 19.2.2、和Netfilter互动

+ *有许多钩子*

##### 19.2.3、与路由子系统的交互

+ IP层用于查询路由表的三个函数：
  + ip_route_input，决定输入封包的命运
  + ip_route_output_flow，传输封包前使用
  + dst_pmtu，给定一个路由表缓存项目

##### 19.2.4、处理输入IP封包

+ *太长了，没看*
+ 介绍**ip_rcv**的功能
  + 在net/ipv4/ip_input.c文件中

##### 19.2.6、ip_rcv_finish函数

+ 在net/ipv4/ip_input.c文件中

+ 处理的工作：
  + 1、决定封包是否必须本地传递或转发（**转发，就要找到出口设备和下个跳点**）
  + 2、分析和处理一些IP选项。

#### 19.3、IP选项

##### 19.3.0、0

+ 处理IP选项相当耗时，因此IP选项一直用得不多
+ api定义在 net/ipv4/ip_options.c中，**并非一个封包的所有IP选项都必须在其所有片段中重复**
  + ip_options_compile
  + ip_options_build

##### 19.3.1、选项的处理

+ **入口IP封包的选项首先会由ip_options_compile()解析**
+ 图19-3

##### 19.3.2、选项的解析

+ **解析**：是指把IP选项从存储在IP封包报头里的格式中抽取出来，然后将其存储在一个名为ip_options的结构中，使得程序代码更方便处理。

###### 选项：严格和松散源路由

###### 选项：Record Route

###### 选项：Timestamp

###### 选项：Router Alert

###### 处理解析错误

### chap20、IPv4：转发和本地传递 469（487/1016）

+ *这一节，我觉得，我没在哪看过，先不看吧*

#### 20.1、转发

##### 20.1.0、0

+ 转发分割成两个函数
  + ip_forward
  + ip_forward_finish
+ 转发的步骤：
  + 1、处理IP选项
  + 2、确定封包可以被转发
  + 3、递减IP报头的TTL字段，然后，TTL字段变为零，就丢弃该包
  + 4、根据路径相关MTU，必要时处理分段工作
  + 5、把封包传送至外出设备

##### 20.1.1、ICMP

##### 20.1.2、ip_forward函数

+ 由ip_rcv_finish调用

##### 20.1.3、ip_forward_finish函数

##### 20.1.4、dst_output函数

+ 以抵达目的地主机
+ **会调用虚拟函数output**

#### 20.2、本地传递

+ 重组工作是在ip_defrag函数内进行的
+ ip_local_deliver_finish函数

### chap21、IPv4：传输  476（494/1016）

+ 讨论**L3层的封包传输**，传输可以由L4层进行，也可以作为转发的最后阶段而被调用。
+ 中央传递封包的函数是dst_output
+ 本章讨论的是在dst_output之前，在此阶段，内核的任务
  + 查询下一个跳点
  + 初始化IP报头
  + 处理选项
  + 分段
  + 校验和
  + 由Netfilter检查
  + 更新统计数据

#### 21.1、进行传输的重要参数

+ 分段是由**两组函数处理的**，如下
  + ip_queue_xmit，**把IP报头加入已经创建好的数据片段中**
  + ip_push_pending_frames及相关函数

##### 21.1.1、多播流量

##### 21.1.2、本地流量相关的套接字数据结构

##### 21.1.3、ip_queue_xmit函数

+ `int ip_queue_xmit(struct sk_buff *skb, int ipfragok)`

###### 设定路径

###### 构建IP报头

##### 21.1.4、ip_append_data函数

+ 21.1.4.1、针对ip_append_data的基本内存分配和缓冲区组织
+ 21.1.4.2、针对ip_append_data（有分散/聚集IO）的内存分配和缓冲区组织
+ 21.1.4.3、处理片段缓冲区的重要函数
+ 21.1.4.4、缓冲区的后续处理
+ 21.1.4.5、设定上下文
+ 准备产生片段
+ 把数据拷贝到片段：getfrag
+ 缓冲区分配
+ 主要循环
+ L4校验和

##### 21.1.5、ip_append_page函数

##### 21.1.6、ip_push_pending_frames函数

##### 21.1.7、整合传输函数

##### 21.1.8、raw套接字

+ 使用`setsockopt()`中的**IP_HDRINCL**选项

#### 21.2、衔接邻居子系统

+ ip_finish_output只是一个简单的包裹函数，**内含一个Netfilter钩子**，一切就绪后，**调用dev_queue_xmit函数，做真正的传输工作**

### chap22、IPv4：处理分段  515（533/1016）

+ ip_fragment函数（net/ipv4/ip_output.c）
+ ip_defrag函数（net/ipv4/ip_fragment.c）
+ **IP层如何认出一个封包是另一个较大封包的一个片段？**

#### 22.1、IP分段

+ **无论是本地产生的封包还是转发封包都会调用dst_output函数**
+ ip_fragment的输入数据可以是
  + 完整的已转发封包
  + 原来的主机或者路上路由器已分段的已转发封包
  + 由本地函数所建的缓冲区
+ ip_fragment必须能够处理下列2种情况：
  + 必须切成小块的大数据块
  + 不需要再分段的数据片段链表或数组

##### 22.1.1、牵涉IP分段的函数

+ 分段程序所用的2个辅助函数：
  + ip_dont_fragment，决定IP封包是否可以分段
  + ip_options_fragment，修改第一个片段的IP报头，使其可以被后续片段循环利用

##### 22.1.2、ip_fragment函数

+ 功能是**把等待传输的缓冲区转变成实际的封包**

##### 22.1.3、慢速分段

##### 22.1.4、快速分段

+ **当ip_fragment看见输入的skb缓冲区的frag_list指针不为NULL时，就会尝试快速法**。
+ 协议规定的健康检查
  + 每个片段的尺寸不应该超过PMTU
  + 只有最后一个片段的L3有效载荷的尺寸可以不是8字节的倍数
  + 每个片段在头部必须有足够空间来容纳稍后L2报头的新增

#### 22.2、IP重组

+ **路由器通常只让封包通过，只是偶尔也需要重组**，路由器需要重组的2种情况：
  + 1、IP报头中包含Router Alert选项，强迫路由器去处理该封包
  + 2、Netfilter必须查看封包，才能决定该对封包做什么事

##### 22.2.1、IP分段hash表的组织

##### 22.2.2、重组的重要议题

+ 片段必须存储于内核内存中，直到它完全被网络子系统处理完，但是内存很昂贵。**一定要有种方式去限制内存的使用**
+ 存储大量信息最有效的结构就是hash表。
+ 网络联机时常使用不可靠的媒介，所以，分段可能会遗失。

##### 22.2.3、涉及重组的函数

##### 22.2.4、新ipq实例的初始化

22.2.5、ip_defrag函数

##### 22.2.6、ip_frag_queue函数

22.2.6.1、处理重迭

22.2.6.2、L4校验和

##### 22.2.7、垃圾收集

22.2.7.1、hash表重新组织

### chap23、IPv4：其它主题

#### 23.1、长效IP端点信息

23.2、选择IP报头的ID字段

23.3、IP统计资料

23.4、IP配置

23.5、IP-over-IP

23.6、IPv4：问题出在哪儿？

23.7、通过/proc文件系统做调整

23.8、本部分涉及的数据结构

23.9、本部分涉及的函数和变量

23.10、本部分涉及的文件和目录

### chap24、L4协议和Raw IP的处理

#### 24.1、可用的L4协议

#### 24.2、L4协议的注册

24.3、L3到L4的传递：ip_local_deliver_finish

24.4、IPv4 vs IPv6

24.5、通过/proc文件系统做调整

24.6、本部分涉及的函数和变量

24.7、本部分涉及的文件和目录

### chap25、因特网控制消息协议（ICMPv4）

#### 25.1、ICMP报头

25.2、ICMP有效载荷

25.3、ICMP类型

25.4、ICMP协议的应用程序

25.5、大蓝图

25.6、协议的初始化

25.7、本章涉及的数据结构

25.8、传输ICMP消息

25.9、接收ICMP消息

25.10、ICMP统计资料

25.11、把错误通知传给传输层

25.12、通过/proc文件系统做调整

25.13、本部分涉及的函数和变量

25.14、本部分涉及的文件和目录

### chap26、邻居子系统：概念

+ RFC2461

#### 26.1、邻居是什么？

+ 如果一台主机和你的计算机连接在同一个LAN上，那么**它就是你的邻居（neighbor）**，而且它有相同的L3网络配置。
  + 另一个定义是，**一台主机到其邻居必须有且仅一个L3跃点，并且它的L3路由表必须提供可以直接和其邻居通信的一条路径**。【*简单的说，没有借助网关和路由器*】

#### 26.2、需要邻居协议的原因

##### 26.2.1、L3地址何时需要被转换为L2地址

+ 2层（Ethernet、802.11无线、点对点连接），3层（IP），**3层协议传输数据时，不必关心使用哪种物理介质**

##### 26.2.2、共享介质

+ 在共享介质中，任一主机发出的任何帧都会被直接连接到该介质上的所有主机收到。
+ 在共享介质中使用的链路层协议**需要定义一种寻址机制**，以便发送方可以指定每个帧的接收方，接受方也可以识别发送方。
+ CSMA/CD

##### 26.2.3、为何没有足够的静态地址

+ **L2地址是绑定到NIC上的**，L3地址可以分配给任一物理接口

##### 26.2.4、特殊情况

+ 有些时候L3地址到L2地址的映射不需要任何协议就能完成
  + 仅有一台主机就能把数据发送到点对点介质上

##### 26.2.5、Solicitation请求和应答

+ Solicitation请求
+ Solicitation应答

#### 26.3、Linux实现

+ *大蓝图，lionel，自己要理解一下*

##### 26.3.1、邻居协议

+ 2个邻居协议
  + IPv4中的ARP协议
  + IPv6中的（Neighbor Discovery）ND
+ 为了减少系统开销和所有邻居协议使用的相似服务间的代码重复，Linux提供了**通用基础结构**，服务有：
  + 1、为每个协议提供一个缓存来存放L3到L2转换的结果
  + 2、
  + 3、
  + 4、
  + 5、

#### 26.4、邻居协议代理

+ 若一台主机将发往另一台的主机流量拦截下来，并且代替后者处理这些流量，那么**这台主机就是一个代理**。
+ 如果主机和应用程序不需要精确配置成从代理提供的服务获益，这种代理称为**透明代理**

##### 26.4.1、使用代理的条件

#### 26.5、何时发送和处理Solicitation请求

#### 26.6、邻居状态和网络不可到达性探测（NUD）

##### 26.6.1、可到达性

##### 26.6.2、NUD状态之间的转换

+ 基础状态
+ 派生状态
+ 初态

##### 26.6.3、可到达性确认

### chap27、邻居子系统：基础结构

#### 27.1、主要的数据结构

+ `include/net/neighbour.h`
+ negighbour
+ neigh_table
+ neigh_parms
+ neigh_ops
+ hh_cache
+ rtable
+ dst_entry

#### 27.2、L3协议和邻居协议间的通用接口

##### 0

+ **Linux内核有个通用邻居层，通过一个虚拟函数表**（Virtual Function Table），将L3协议和主要的L2传输函数连接起来
+ **邻居子系统的VFT是由neigh_ops结构实现的**

##### 27.2.1、neigh->ops的初始化

##### 27.2.2、neigh->output和neigh->nud_state的初始化

+ 普通状态改变函数
+ neigh->output使用的函数

##### 27.2.3、邻居信息的更新：neigh_update

+ 0
  + `net/core/neighbour.c`
+ neigh_update优化
+ neigh_update初始化
+ 链路层地址的改变
+ 通知arpd

#### 27.3、邻居基础结构的一般任务

##### 27.3.1、缓存

+ 邻居层实现了两种形式的缓存
  + 邻居映射
  + L2帧头

##### 27.3.2、定时器

+ 状态转移时的定时器
+ 失败的solicitation请求的定时器
+ 垃圾回收定时器
+ Proxy定时器

#### 27.4、邻居结构的引用计数

#### 27.5、创建一个邻居项

##### 0

##### 27.5.1、函数neigh_create的参数

27.6、删除邻居

27.7、担任代理

27.8、L2帧头缓存

27.9、协议初始化和清理

27.10、与其他子系统的交互

27.11、邻居协议和L3传输函数的交互

27.12、排队

27.13、入口排列

### chap28、邻居子系统：地址解析协议（ARP）

#### 28.1、ARP封包格式

##### 28.1.1、ARP封包中的目的地址类型

+ ARP对每个类型的处理
  + 单播（Unicast）
  + 广播（Broadcast）
  + 多播（Multicast）

#### 28.2、ARP事务范例

#### 28.3、无端ARP

##### 28.3.1、L2地址发生变化

##### 28.3.2、重复地址检测

##### 28.3.3、虚拟IP

#### 28.4、多个网络接口的应答

+ Linux有个不同寻常的设计，**它认为一个IP地址属于一个主机，而不是属于一个接口**，尽管IP地址是绑定在特定接口上的

#### 28.5、调整ARP选项

28.5.1、编译选项

28.5.2、/proc选项

#### 28.6、初始化ARP协议

##### 28.6.1、arp_tbl表

#### 28.7、初始化neighbour结构

##### 28.7.1、基本的初始化顺序

28.8、传输和接收ARP封包

+ arp_send
+ arp_rcv

##### 28.8.1、发送ARP包：arp_send的介绍

#### 28.9、处理入口ARP封包

##### 28.9.1、普通处理的初始化

##### 28.9.2、处理ARPOP_REQUEST封包

##### 28.9.3、处理ARPOP_REPLY封包

##### 28.9.4、普通处理的结尾

#### 28.10、ARP代理

28.10.1、目的NAT（DNAT）

##### 28.10.2、ARP代理服务器作为路由器

#### 28.11、实例

#### 28.12、外部事件

28.12.1、收到的事件

28.12.2、产生的事件

28.12.3、网络唤醒（Wake-on-LAN）事件

#### 28.13、ARPD

28.13.1、内核方面

28.13.2、用户空间方面

#### 28.14、逆向地址解析协议（RARP）

#### 28.15、ND（IPv6）对ARP（IPv4）的改进

+ ND的一些改进
  + 1、ND是ICMPv6提供的函数。ICMPv6是一个强大的覆盖了ICMPv4、ARP和其他功能的协议

### chap29、邻居子系统：其他问题

#### 29.1、邻居的系统管理

29.2、使用/proc文件系统调整邻居性能

29.3、本部分涉及的数据结构

29.4、本部分涉及的文件和目录

### chap30、路由：概念 781（799/1016）

+ 图30-1，路由子系统与其它主要网络子系统间的关系
+ 针对IPv4网络的路由

#### 30.1、路由器、路由与路由表

+ **转发信息库FIB**（Forwarding Information Base），被简单称为**路由表**（routing table）
+ 一条路由所需要的最少的参数集合
  + 目的网络，**路由表被用于往目的地转发流量**
  + 出口设备，与路由项匹配的封包应当从该设备发送出去
  + 下一跳网关，当目的网络和本地主机不是直连时，需要通过其他的路由器来转发

##### 非路由多接口主机（Nonrouting Multihomed Hosts）

##### 各种路由配置

##### 本书这一部分要回答的问题

+ 1、如果假定一台路由器转发包，内核是如何知道能否转发？
+ 2、路由是在全局使能使用还是只在一对接口之间使用？
+ 3、是否存在可调整的参数，能够显著影响Linux路由器的性能？
+ 4、路由表的结构是什么？
+ 进阶1、利用什么算法来查找转发包所需的信息？
+ 进阶2、路由表除了用于转发流量外，还有其他的用途吗？
+ 进阶3、内核与运行在用户空间中的动态路由协议之间是如何交互的？

#### 30.2、路由的基本元素

+ 名词概念
  + 可路由地址与不可路由地址

##### Scope

+ 路由的scope表示到目的网络的距离
+ IP地址的scope表示该IP地址距离本地主机有多远，某种程序上也告诉你该地址的所有者距离本地主机有多远
+ *怎么理解scope？*
+ scope的使用

##### 默认网关

##### 定向广播（Directed Broadcasts）

+ 定向广播的目的地是远端子网的广播地址

##### 主地址与辅助地址

#### 30.3、路由表

+ **路由表**是路由子系统的核心，它是由一个**路由数据库**组成，IPv4的其他子系统通过各种函数可以使用该数据库，最重要的函数是**路由查找**

##### 特殊路由

+ 在默认情况下，Linux使用两张路由表：
  + 一张表用于本地地址
  + 一张表用于所有其他的路由，其数据项可由用户手工配置或路由协议动态插入

##### 路由类型与动作

+ 当一个封包与路由表中的某条路由相匹配时，默认动作是根据从路由表得到的该路由的转发信息，即**下一跳路由器地址和出口设备来转发该封包**

##### 路由缓存

+ Linux将路由缓存分成两部分
  + 一个是与协议相关的缓存，**表示缓存框架的部分**，其中每个元素被定义为一个由具体协议字段组成的集合
  + 一个是与协议无关的缓存，通常被称为DST

##### 路由表与路由缓存

##### 路由缓存的垃圾回收

+ 垃圾回收负责清理路由子系统中**不再被使用的数据结构**
+ 垃圾回收机制有两种：
  + 同步回收：**当路由子系统认为需要释放内存时，立即进行清理**
  + 异步回收：

#### 30.4、查找

+ 路由缓存查找是从一张简单的hash表中寻找完全匹配项。

##### 最长前缀匹配

+ 到达同一目的地存在多条路由，*需要此算法*

#### 30.5、封包接收与封包传输

+ 路由类型可以是本地提交或转发，所以路由要发出的封包和要接收的封包时都需要路由表

+ 路由的其它好处（图30-9）
  + ARP封包不进行路由
  + IP-over-IP是一个简单的隧道协议，它可以将普通IP封包封装到一个更大的IP封包中

### chap31、路由：高级路由  806（824/1016）

+ 与QoS负责的流量控制子系统，防火墙程序（Netfilter）相互作用

#### 31.1、策略路由背后的概念

+ 策略路由背后的主要思想是**允许用户除了可以根据目的IP地址配置路由外，还可以根据其他多个参数来配置路由**
+ 在路由器RT上配置路由有两种可能的方式
  + 单路由表法
  + 一种是在Linux中使用的方法（多路由表方法）

##### 策略路由查找

+ 当使用策略路由时，为目的地查找路由可分为两个步骤：
  + 1、根据配置策略选择要用的路由表，这个额外任务不可避免地增加了路由查找时间
  + 2、从选择的路由表中查找路由

##### 选择路由表

+ 内核可以基于以下参数作为在选择路由表时所用的策略：
  + 源IP地址与/或目的IP地址
  + 入口设备
  + TOS
  + Fwmark

#### 31.2、多路径路由背后的概念

+ **多路径**是指管理员可以为一条路由的目的地指定多个下一跳

##### 选择下一跳

+ 根据**加权循环算法（weighted round-robin algorithm）**来选择下一跳

##### 支持多路径缓存

+ 一些有用的算法
  + 随机算法（Random）
  + 加权随机算法
  + 循环法（Round robin）
  + 设备循环算法（Device round robin）

+ 加权随机算法

+ 设备循环算法

##### 基于流、基于连接和基于封包的流量分配

+ 给定一条多路径路由，
  + 基于流Per flow
  + 基于连接Per connection
+ 均衡算法

#### 31.3、与其他内核子系统的交互

##### 基于路由表的分类器

##### 策略路由与基于防火墙的分类器

#### 31.4、路由协议守护进程

+ 根据下面三种方式将路由插入到内核的路由表中：
  + 通过用户命令静态配置（如ip route、route）
  + 通过路由协议
  + 由于配置不理想而由内核接收和处理的ICMP重定向消息

#### 31.5、Verbose监控

#### 31.6、ICMP_REDIRECT消息

##### 共享介质

##### 发送ICMP_REDIRECT消息

##### 处理入口ICMP_REDIRECT消息

#### 31.7、反向路径过滤

### chap32、路由：Linux的实现  833（851/1016）

+ 本节内容（先提到**主要数据结构**）再描述
  + 如何定义路由scope和IP地址scope
  + 如何初始化路由子系统
  + 哪些外部事件需要通知路由子系统，以便更新路由信息

#### 32.1、内核选项

+ 分为2类
  + 一类是永远支持，比如通过`/proc`来配置或开启的选项
  + 另一类是**重新编译内核时可以添加或删除的选项**
    + CONFIG_WAN_ROUTER选项

##### 基本选项

+ IP：多播路由（CONFIG_IP_MROUTE）

##### 高级选项

##### 最近去掉的选项

+ 2.4系统中内核支持，而在2.6系列中被去掉的
  + IP：快速网络转换（CONFIG_IP_ROUTE_NAT）
  + 快速交换（CONFIG_NET_FASTROUTE）

#### 32.2、主要的数据结构

+ **rt开头（route）路由，fib开头（Forwarding Information Base）转发信息库，fn开头（function）功能**

##### 链表与hash表

#### 32.3、路由scope与地址scope

##### 路由scope

+ 保存在**fib_alias数据结构内的fa_scope字段**

##### 地址scope

+ 保存在**in_ifaddr结构内的ifa_scope字段**

##### 路由scope与下一跳scope之间的关系

+ **路由下一跳（fib_bh结构）的scope总是由内核来设定**

#### 32.4、主IP地址与辅助IP地址

+ **IPv4的辅助地址在其in_ifaddr数据结构内带有IFA_F_SEDONDARY标识**，没有这个标识的，就认为是主IP地址

#### 32.5、常用的辅助程序与宏

#### 32.6、全局锁

+ fib_hash_lock（读写旋转锁rwlock）**保护所有的路由表**
+ fib_info_lock
+ fib_rules_lock
+ rt_flush_lock

#### 32.7、路由子系统初始化

+ net/ipv4/route.c中的`ip_rt_init()`，**被net/ipv4/ip_output.c中的ip_init调用**
+ ip_rt_init函数功能
  + 初始化数据结构和全局变量

#### 32.8、外部事件

+ 路由子系统尤其对两类事件感兴趣
  + 网络设备状态的变化
  + 网络设备上IP配置的变化

##### 辅助程序

##### IP配置改变

+ **只要设备的IP配置发生变化，路由子系统就收到一个通知，并运行fib_inetaddr_event来处理该通知**

###### 添加一个IP地址（fib_add_ifaddr）

###### 删除一个IP地址（fib_del_ifaddr）

##### 设备状态改变

+ 路由子系统向netdev_chain通知链注册三个不同的处理函数来处理设备状态的变化：
  + fib_netdev_event更新路由表

###### 对路由表的影响

###### 对策略数据库的影响

###### 对IP配置的影响

#### 32.9、与其他子系统的交互

##### Netlink通知

##### 策略路由与基于防火墙的分类器

##### 路由协议守护进程

### chap33、路由：路由缓存  864（882/1016）

+ 路由缓存**减少路由表查找的时间**。路由缓存的核心是**与协议无关的目的缓存（Protocol Independent Destination Cache DST）**
+ **缓存的主要工作**：存储使路由子系统能够找到封包目的地的信息，并将这些信息通过一组函数提供给上层协议。

#### 33.1、路由缓存初始化

+ 在ip_rt_init中初始化
+ **缓存容量取决于主机中可用的物理内存的大小**

#### 33.2、Hash表的组织

+ 在IPv4中，hash表bucket的类型是`rt_hash_bucket`，该结构**只包含一个指向冲突元素链表的指针和一个锁**
+ **缓存中的元素类型为rtable**

#### 33.3、主要的缓存操作

+ **缓存中与协议无关的（DST）部分是一组dst_entry数据结构**

##### 缓存锁

##### 缓存表项的内存分配和引用计数

##### 添加元素到缓存中

##### 将路由缓存绑定到ARP缓存

+ **大多数路由缓存表项要被绑定到该路由下一跳地址对应的ARP缓存表项**

##### 缓存查找

+ 路由子系统提供了**两个不同路由查找函数**，一个用于入口路由，一个用于出口路由
  + ip_route_input
  + ip_route_output_key

###### 入口查找

###### 出口查找

#### 33.4、多路径缓存

##### 注册一个缓存算法

##### 路由缓存与多路径之间的接口

##### 辅助函数

##### 几种路由算法之间的共性

##### 随机算法

##### 加权随机算法

##### 循环算法

##### 设备循环算法

#### 33.5、DST与调用协议间的接口

##### IPsec变换与dst_entry的使用

##### 外部事件

#### 33.6、刷新路由缓存

#### 33.7、垃圾回收

##### 同步清理

##### rt_garbage_collect函数

##### 异步清理

##### 过期标准

##### 删除DST表项

##### 调整和控制垃圾回收的变量

#### 33.8、出口ICMP REDIRECT限速

### chap34、路由：路由表  901（919/1016）

#### 34.1、路由Hash表的组织

34.2、路由表初始化

34.3、路由的添加与删除

34.4、策略路由及其对路由表定义的影响

### chap35、路由：查找

35.1、查找函数的高层概述

35.2、辅助函数

35.3、路由表查找：fn_hash_lookup

35.4、fib_lookup函数

35.5、为接收和发送设置函数

35.6、输入和输出路由函数的一般结构

35.7、输入路由

35.8、输出路由

35.9、多路径对下一跳选择的影响

35.10、策略路由

35.11、源路由

#### 35.12、策略路由与基于路由表的分类器

### chap36、路由：相关主题

36.1、用户空间配置工具

36.2、统计数据

36.3、通过/proc文件系统调整

36.4、开启和关闭转发

36.5、本书此部分中的数据结构功能

36.6、本部分涉及的函数和变量

36.7、本部分涉及的文件和目录