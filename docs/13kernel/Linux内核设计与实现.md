## 《Linux内核设计与实现》

### chap3、进程管理

+ Linux内核如何管理每个进程：它们在内核中如何被列举，如何创建，最终又如何消亡。

#### 3.1、进程
+ **Linux系统的线程实现非常特别：它对线程和进程并不特别区分**。
+ 在现代操作系统中，进程提供两种虚拟机制：**虚拟处理器和虚拟内存**
+ 进程是处于执行期的程序以及相关的资源的总称。
+ fork()，然后`exec()`创建新的地址空间，并把新的程序载入其中。**fork()实际是由clone()系统调用实现的**。程序通过exit()系统调用退出执行。父进程通过wait4()系统调用查询子进程是否终结。
#### 3.2、进程描述符及任务结构
+ linux/sched.h中的`struct task_struct{};`，**在32位机器上，它大约有1.7KB**。
+ 任务队列的双向循环链表
+ 进程描述符，包含一个具体进程的所有信息，能完整地描述一个正在执行的程序
	+ 它打开的文件
	+ 进程的地址空间
	+ 挂起的信号
	+ 进程的状态
	+ 还有其它
##### 3.2.1、分配进程描述符
+ Linux通过slab分配器分配task_struct结构，asm/thread_info中的`struct thread_info{};`
+ 每个任务的thread_info结构在它的内核栈的尾端分配。结构中task域中存放的是指向该任务实际task_struct的指针。
##### 3.2.2、进程描述符的存放

+ PID的最大默认值设置为32768，linux/threads.h中定义
+ 通过修改`/proc/sys/kernel/pid_max`来提高上限
+ **通过current宏查找到当前正在运行进程的进程描述符的速度就显得尤为重要**，`current_thread_info()`实现，不同的平台上有不同的实现。

##### 3.2.3、进程状态

+ 五大状态
	+ 运行
	+ 可中断
	+ 不可中断
	+ 被其他进程跟踪的进程
	+ 进程停止执行

##### 3.2.4、设置当前进程状态
+ `set_task_state()`
+ linux/sched.h中的实现
##### 3.2.5、进程上下文

+ **当一个程序调执行了系统调用或者触发了某个异常，它就陷入了内核空间**。此时，我们称内核”代表进程执行“并处于进程上下文中。

##### 3.2.6、进程家族树

+ 内核在系统启动的最后阶段启动init进程。该进程读取系统的初始化脚本（initscript）并执行其他的相关程序，最终完成系统启动的整个过程。
+ **init进程的进程描述符是作为init_task静态分配的**。
+ `list_entry()`

#### 3.3、进程创建
+ **产生（spawn）进程的机制：** 首先在新的地址空间里创建进程，读入可执行文件，最后开始执行。
+ Unix采用了与众不同的实现方式，**把上述步骤分解到两个单独的函数中去执行：fork()和exec()**
  + fork()
  + exec()负责读取可执行文件并将其载入地址空间开始运行。
##### 3.3.1、写时拷贝

+ 传统的fork()系统调用直接把所有的资源复制给新创建的进程。
+ Linux的fork()使用写时拷贝（copy-on-write）页实现。**写时拷贝是一种可以推迟甚至免除拷贝数据的技术**
+ **fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符**

##### 3.3.2、fork()
+ **Linux通过`clone()`系统调用实现`fork()`**
+ kernel/fork.c中的`do_fork()`中的`copy_process()`
+ copy_process()完成的工作:
  + 1) 调用dup_task_struct()为新进程创建一个内核栈、thread_info结构和task_struct，这些值与当前进程的值相同。
  + 2) 检查并确保新创建这个子进程后，当前用户所拥有的进程数目没有超出给它分配的资源的限制
  + 7)
  + 8)最后，copy_process()做扫尾工作并返回一个指向子进程的指针
##### 3.3.3、vfork()

+ **除了不拷贝父进程的页表项外，vfork()系统调用和fork()的功能相同**。
+ vfork()系统调用的实现是通过向clone()系统调用传递一个特殊标志来进行的
	+ 1) 在调用copy_process()时，task_struct的vfork_done成员被置为NULL
	+ 5)回到do_fork()，父进程醒来并返回

#### 3.4、线程在linux中的实现
##### 0、
##### 3.4.1、创建线程
+ **调用`clone()`需要传递一些参数标志来指明需要共享的资源**
##### 3.4.2、内核线程
+ 内核线程和普通的进程间的区别在于，**内核线程没有独立的地址空间（实际上指向地址空间的mm指针被设置为NULL）**
#### 3.5、线程终结
##### 0、
+ kernel/exit.c中的`do_exit()`
##### 3.5.1、删除进程描述符
+ 当最终需要释放进程描述符时，`release_task()`会被调用，完成以下工作：
	+ 1、
	+ 2、`_exit_signal()`释放目前僵死进程所使用的所有剩余资源，并进行最终统计和记录
##### 3.5.2、孤儿进程造成的进退维谷
#### 3.6、小结

### chap4、进程调度
#### 4.1、多任务
+ 多任务系统可以划分为两类：
	+ 非抢占式多任务
	+ 抢占式多任务：**强制挂起的动作**
+ 非抢占式多任务模式下，**进程主动挂起自己的操作称为让步（yielding）**
#### 4.2、Linux的进程调度
#### 4.3、策略
##### 4.3.1、I/O消耗型和处理器消耗型的进程
##### 4.3.2、进程优先级
+ Linux采用两种不同的优先级范围：
	+ 第一种是用nice值
	+ 第二种是实时优先级
##### 4.3.3、时间片
##### 4.3.4、调度策略的活动
#### 4.4、Linux调度算法
##### 4.4.1、调度器类
##### 4.4.2、Unix系统中的进程调度
##### 4.4.3、公平调度
#### 4.5、Linux调度的实现
+ kernel/sched_fair.c
+ 关注四个组成部分
	+ 时间记账
	+ 进程选择
	+ 调度器入口
	+ 睡眠和唤醒
##### 4.5.1、时间记账
+ 1、调度器实体结构
	+ linux/sched.h中的`struct sched_entity{};`
+ 2、虚拟实时
##### 4.5.2、进程选择
##### 4.5.3、调度器入口
+ kernel/sched.c中的`schedule()`
##### 4.5.4、睡眠和唤醒
#### 4.6、抢占和上下文切换
+ **上下文切换**：从一个可执行进程切换到另一个可执行进程，定义在kernel/sched.c中的`context_switch()`负责，`schedule()`会调用`context_switch()`，它完成了两项基本的工作：
	+ asm/mmu_context.h中的`switch_mm()`，把虚拟内存从上一个进程映射切换到新进程中。
	+ asm/system.h中的`switch_to()`，从上一个进程的处理器状态切换到新进程的处理器状态
+ **内核必须知道在什么时候调用schedule()**
	+ need_resched标志
##### 4.6.1、用户抢占
+ 用户抢占在以下情况时产生：
	+ 从系统调用返回用户空间时
	+ 从中断处理程序返回用户空间时
##### 4.6.2、内核抢占
+ 内核抢占发生在
	+ 中断处理程序正在执行，且返回内核空间之前
#### 4.7、实时调度策略
+ Linux提供了两种调度策略：**SCHED_FIFO和SCHED_RR**
+ kernel/sched_rt.c
#### 4.8、与调度相关的系统调用
##### 4.8.1、与调度策略和优先级相关的系统调用
+ `sched_setscheduler()`
+ `sched_setparam()`设置进程的实时优先级
##### 4.8.2、与处理器绑定有关的系统调用
+ `sched_getaffinity()`
##### 4.8.3、放弃处理器时间
+ Linux通过`sched_yield()`，提供了一种让进程显式地将处理器时间让给其他等待执行进程的机制。
+ 内核，可以直接调用yield()，先要确定给定进程确实处于可执行状态，然后再调用`sched_yield()`
+ 用户空间的应用程序直接使用`sched_yield()`系统调用就可以了

#### 4.9、小结

### chap5、系统调用

#### 5.1、与内核通信
+ 系统调用在用户空间进程和硬件设备之间添加了一个中间层。**中间层**的3个作用：
#### 5.2、API、POSIX和C库
+ POSIX是个标准
+ C库：实现了Unix系统的主要API，包括标准C库函数和系统调用接口
+ 接口设计格言：**提供机制而不是策略**，*这个没懂，lionel*
#### 5.3、系统调用
##### 0、
+ 系统调用在出现错误的时候C库会把错误码写入errno全局变量。通过调用`perror`库函数，把该变量翻译成用户可以理解的错误字符串。
+ `SYSCALL_DEFINE0`-这个在2.6.18里没找到啊，直接在`/include/linux/syscalls.h`中定义了`asmlinkage long sys_getpid(void);`，实现怎么在time.c了呢？
	+ asmlinkage是个**编译指令**，通知编译器仅从栈中提取该函数的参数
	+ 返回值是long的原因，兼容32位和64位
	+ 系统调用的命名规则是`sys_`开头
##### 5.3.1、系统调用号
+ **进程不会提及系统调用的名称**，通过系统调用号来关联，**一旦分配就不会再有任何变更**
+ 所有已经注册过的系统调用的列表，存储在sys_call_table中。*2.6里搜了一下在arch/x86_64/kernel/syscall.c*
+ *问题1：何时删除系统调用号呢？ 问题2：系统调用号存在哪？*
+ 其它
	+ `sys_ni_syscall()`
##### 5.3.2、系统调用的性能
#### 5.4、系统调用处理程序
##### 0、
+ 通知内核的机制是靠**软中断**实现的：通过引发一个异常
+ x86系统上预定义的软中断是**中断号128，`int $0x80`指令**，名称叫`system_call()`
+ entry_64.S中用汇编编写
+ sysenter的指令
##### 5.4.1、指定恰当的系统调用
+ 在x86上，**系统调用号是通过eax寄存器传递给内核的**。*eax寄存器是啥？lionel，问题1，什么时候传给eax寄存器的，用什么方式传的？*
+ *表项是64位存放的，所以要乘4，不太懂啥意思，lionel*
##### 5.4.2、参数传递
+ x86-32系统上，**ebx，ecx，edx，esi和edi按照顺序存放前5个参数**。
#### 5.5、系统调用的实现
##### 5.5.1、实现系统调用
+ *通过思考这个过程，去想一下，日常的接口怎么设计？lionel*
##### 5.5.2、参数验证
+ `copy_from_user()`和`copy_to_user()`
+ 书上以`kernel/sys.c`中的`sys_reboot()`为例，说了些要注意的权限问题
+ `CAP_SYS_BOOT`，权限的定义在`/include/linux/capability.h`中，*以CAP开头，是因为capability.h的命名*
#### 5.6、系统调用上下文
##### 0、
+ *问题，为何可以休眠，是比较重要的呢*
##### 5.6.1、绑定一个系统调用的最后步骤
+ 注册
	+ 1、在系统调用表的最后加入一个表项，`entry.S`
	+ 2、支持各种体系结构，系统调用号都必须定义于`<asm/unistd.h>`
	+ 3、**系统调用必须被编译进内核映像（不能被编译成模块）**，放在`kernel/`下的一个相关文件就可以了，比如sys.c
##### 5.6.2、从用户空间访问系统调用
+ `_syscalln`，n的范围是0-6，表示**需要传递给系统调用的参数个数**。
+ *lionel，这个没具体看，想实践一下，怎么编进内核，怎么写了跟内核交互，系统调用*
##### 5.6.3、为什么不通过系统调用的方式实现
+ 系统调用有好处（创建容易且使用方便，性能高），但有问题：
+ 替代方法：（*不太懂*）
	+ 实现一个设备节点，并对此实现`read()`和`write()`
		+ 像信号量这样的某些接口
		+ 把增加的信息作为一个文件放在sysfs的合适位置

#### 5.7、小结

### chap6、内核数据结构

#### 6.1、链表
##### 0、
##### 6.1.1、单向链表和双向链表
##### 6.1.2、环形链表
##### 6.1.3、沿链表移动
+ **只能是线性移动**
##### 6.1.4、Linux内核中的实现
+ 0、
	+ **linux内核，将链表节点塞入数据结构，不是将数据结构塞入链表**。
+ 1、链表数据结构
	+ linux/list.h
+ 2、定义一个链表
+ 3、链表头
##### 6.1.5、操作链表
+ 0、
+ 1、向链表中增加一个节点
	+ `list_add()`
+ 2、从链表中删除一个节点
	+ `list_del()`
+ 3、移动和合并链表节点
	+ `list_move()`
	+ `list_move_tail()`
	+ `list_empty()`
##### 6.1.6、遍历链表
+ 0、
+ 1、
+ 2、
+ 3、反向遍历链表
	+ `list_for_each_entry_reverse()` 
+ 4、遍历的同时删除
	+ `list_for_each_entry_safe()`
+ 5、其它链表方法
#### 6.2、队列
##### 0、
+ `linux/kfifo.h`
##### 6.2.1、kfifo
+ kfifo对象维护了两个偏移量：入口偏移和出口偏移（**下一次出队列时的位置**）
+ enqueue
+ dequeue
##### 6.2.2、创建队列
+ 动态创建`kfifo_alloc()`
+ 静态创建
##### 6.2.3、推入队列数据
+ `kfifo_in()`
##### 6.2.4、摘取队列数据
+ `kfifo_out()`
##### 6.2.5、获取队列数据
+ `kfifo_size()`
##### 6.2.6、重置和撤销队列
+ `kfifo_reset()`
##### 6.2.7、队列使用举例
+ *未看，lionel*
#### 6.3、映射
##### 0、
##### 6.3.1、初始化一个idr
##### 6.3.2、分配一个新的UID
+ 第一步，告诉idr你需要分配新的UID，允许其在必要时调整后备树的大小
+ 第二步，才是真正请求新的UID
##### 6.3.3、查找UID
+ `idr_find`
##### 6.3.4、删除UID
+ `idr_move`
##### 6.3.5、撤销idr
+ `idr_destroy`
#### 6.4、二叉树
##### 6.4.1、二叉搜索树（BST）
##### 6.4.2、自平衡二叉搜索树
+ 1、红黑树
+ 2、rbtree
	+ linux/rbtree.h
	+ lib/rbtree.c
#### 6.5、数据结构以及选择
+ 遍历数据，就使用链表
+ 如果需要存储大量数据，并且检索迅速，那么红黑树最好
#### 6.6、算法复杂度
##### 6.6.1、算法
##### 6.6.2、大O符号
##### 6.6.3、大xita符号
##### 6.6.4、时间复杂度
#### 6.7、小结

### chap7、中断和中断处理
+ 让硬件在需要的时候再向内核发出信号，**这就是中断**
#### 7.1、中断
+ 中断使得硬件得以发出通知给处理器
+ **中断值通常被称为中断请求（IRQ）线**。
+ **异常**
	+ 异常也常常称为同步中断。
#### 7.2、中断处理程序
+ 中断处理程序（interrupt handler）、中断服务例程（interrupt service routine）
#### 7.3、上半部和下半部的对比
+ 中断处理程序是上半部（top half）-接收到一个中断，它就立即开始执行，但只做有严格时限的工作。
+ **能够被允许稍后完成的工作会推迟到下半部（bottom half）**
#### 7.4、注册中断处理程序
+ linux/interrupt.h中的`request_irq()`注册一个中断处理程序
##### 7.4.1、中断处理程序标志
+ 第3个参数：
	+ IRQF_DISABLED
+ 第4个参数：name，是与中断相关的设备的ASCII文本表示
+ 第5个参数：dev，用于共享中断线
##### 7.4.2、一个中断例子
##### 7.4.3、释放中断处理程序
+ `free_irq()`
#### 7.5、编写中断处理程序
+ `static irqreturn_t intr_handler(int irq, void *dev)`
##### 7.5.1、共享的中断处理程序
##### 7.5.2、中断处理程序实例
#### 7.6、中断上下文
+ **进程上下文**是一种内核所处的操作模式
#### 7.7、中断处理机制的实现
#### 7.8、/proc/interrupts
+ `show_interrupts()` 
#### 7.9、中断控制
##### 7.9.1、禁止和激活中断
##### 7.9.2、禁止指定中断线
##### 7.9.3、中断系统的状态
+ asm/system.h中的宏`irqs_disable()`
+ linux/hardirq.h中的`in_interrupt()`
#### 7.10、小结

### chap8、下半部和推后执行的工作
+ 局限包括：
	+ 1、中断处理程序以异步方式执行
#### 8.1、下半部
##### 0、
+ 下半部的任务：**执行与中断处理密切相关但中断处理程序本身不执行的工作**。
##### 8.1.1、为什么要用下半部
##### 8.1.2、下半部的环境
+ 1、”下半部“的起源
+ 2、任务队列
+ 3、软中断和tasklet
+ 4、混乱的下半部概念
#### 8.2、软中断
+ kernel/softirq.c
##### 8.2.1、软中断的实现
+ **软中断**是编译期间静态分配的。linux/interrupt.h中的`softirq_action{};`
+ 1、软中断处理程序
+ 2、执行软中断
##### 8.2.2、使用软中断
+ 1、分配索引
+ 2、注册你的处理程序
+ 3、触发你的软中断
#### 8.3、tasklet
+ **tasklet是利用软中断实现的一种下半部机制**。
##### 8.3.1、tasklet的实现
+ 1、tasklet结构体
+ 2、调度tasklet
##### 8.3.2、使用tasklet
+ 1、声明你自己的tasklet
+ 2、编写你自己的tasklet处理程序
+ 3、调度你自己的tasklet
+ 4、ksoftirqd
##### 8.3.3、老的BH机制
+ 2.6已经废弃
#### 8.4、工作队列
##### 0、
##### 8.4.1、工作队列的实现
+ 1、表示线程的数据结构
	+ 工作者线程用`struct workqueue_struct{};`
+ 2、表示工作的数据结构
	+ linux/workqueue.h中的`struct work_struct{};`
##### 8.4.2、使用工作队列
+ 1、创建推后的工作
+ 2、工作队列处理函数
+ 3、对工作进行调度
+ 4、刷新操作
+ 5、创建新的工作队列
##### 8.4.3、老的任务队列机制
#### 8.5、下半部机制的选择
+ tasklet和软中断，两者很接近。**工作队列，靠内核线程实现**
#### 8.6、在下半部之间加锁
+ 任何在工作队列中被共享的数据也需要使用锁机制。
#### 8.7、禁止下半部
+ **先得到一个锁然后再禁止下半部的处理**。
+ 如果需要禁止所有的下半部处理（明确点说，就是所有软中断和所有tasklet），可以调用`local_bh_disable()`。
+ 由于软中断和tasklet是异步发生的（就是说，在中断处理返回的时候），所以，内核代码必须禁止它们。
#### 8.8、小结
+ 下半部中相当程度地用到了同步和并发。

### chap9、内核同步介绍
#### 9.1、临界区和竞争条件
##### 0、
+ 临界区
+ 竞争条件race coditions
##### 9.1.1、为什么我们需要保护
##### 9.1.2、单个变量
#### 9.2、加锁
##### 0、
+ *lionel，没太看懂啊*
##### 9.2.1、造成并发执行的原因
+ 内核中有类似可能造成并发执行的原因。它们是
	+ 中断
	+ 软中断和tasklet
	+ 内核抢占
	+ 睡眠及与用户空间的同步
	+ 对称多处理
##### 9.2.2、了解要保护些什么
#### 9.3、死锁
#### 9.4、争用和扩展性
#### 9.5、小结

### chap10、内核同步方法 （158/353）
#### 10.1、原子操作
##### 10.1.1、原子整数操作
+ linux/types.h中`atomic_t`类型，占用32位中的24位。
##### 10.1.2、64位原子操作
+ `atomic64_t`类型
##### 10.1.3、原子位操作
+ asm/bitops.h
#### 10.2、自旋锁
##### 0、
+ **自旋锁（spin lock）最多只能被一个可执行线程持有**，浪费处理器时间
##### 10.2.1、自旋锁方法
+ asm/spinlock.h或linux/spinlock.h
##### 10.2.2、其他针对自旋锁的操作
+ `spin_lock_init()`初始化动态创建的自旋锁
##### 10.2.3、自旋锁和下半部
#### 10.3、读写-自旋锁
#### 10.4、信号量
##### 0、
+ **睡眠锁**，信号量会将其推进一个等待队列，然后让其睡眠。
##### 10.4.1、计数信号量和二值信号量
##### 10.4.2、创建和初始化信号量
+ asm/semaphore.h
##### 10.4.3、使用信号量
#### 10.5、读写-信号量
+ linux/rwsem.h
#### 10.6、互斥体
##### 0、
+ **互斥体是一种互斥信号**
##### 10.6.1、信号量和互斥体
##### 10.6.2、自旋锁和互斥体
#### 10.7、完成变量
+ linux/completion.h中`DECLARE_COMPLETION(mr_comp);`
+ `init_completion()`
#### 10.8、BLK：大内核锁
+ linux/smp_lock.h
#### 10.9、顺序锁
+ `seqlock_t`
#### 10.10、禁止抢占
#### 10.11、顺序和屏障
#### 10.12、小结

### chap11、定时器和时间管理（183/353）
#### 11.1、内核中的时间概念
#### 11.2、节拍率：HZ
##### 0、
+ asm/param.h
##### 11.2.1、理想的HZ值
##### 11.2.2、高HZ的优势
##### 11.2.3、高HZ的劣势
#### 11.3、jiffies
##### 0、
+ **全局变量jiffies用来记录自系统启动以来产生的节拍的总数**。
+ linux/jiffies.h中的`extern unsigned long volatile jiffies;`
##### 11.3.1、jiffies的内部表示
##### 11.3.2、jiffies的回绕
##### 11.3.3、用户空间和HZ
#### 11.4、硬时钟和定时器
##### 11.4.1、实时时钟
+ 实时时钟（RTC）是用来持久存放系统时间的设备。**靠主板上的微型电池**
##### 11.4.2、系统定时器
#### 11.5、时钟中断处理程序
#### 11.6、实际时间
+ kernel/time/timekeeping.c中的`struct timespec xtime;`
#### 11.7、定时器
##### 0、
##### 11.7.1、使用定时器
+ linux/timer.h
##### 11.7.2、定时器竞争条件
##### 11.7.3、实现定时器
#### 11.8、延迟执行
##### 11.8.1、忙等待
##### 11.8.2、短延迟
+ linux/delay.h和asm/delay.h中，**处理ms、ns和ms级别的延迟函数**，`void udelay(unsigned long usecs);`
##### 11.8.3、schedule timeout()
+ 1、schedule timeout()的实现
+ 2、设置好超时时间，在等待队列上睡眠
#### 11.9、小结
+ **只要你编写驱动程序，就需要处理内核定时器**

### chap12、内存管理

#### 12.1、页
+ **MMU**（是硬件），以页为单位进行处理。
+ 大多数32位体系结构支持4KB的页，而64位体系结构一般会支持8KB的页。
+ `struct page{};`，include/linux/mm.h
+ **page结构与物理页相关，而并非与虚拟页相关**。
#### 12.2、区
+ **内核把页划分为不同的区（zone）**,Linux主要使用了四种区
	+ ZONE_DMA
	+ ZONE_DMA32
	+ ZONE_NORMAL
	+ ZONE_HGHEM
+ `struct zone {};`
#### 12.3、获得页
##### 0、
+ `alloc_pages()`
+ `page_address()`
##### 12.3.1、获得填充为0的页
+ `get_zeroed_page()`
##### 12.3.2、释放页
+ `free_page()`
+ **内核是完全相信自己的**
#### 12.4、kmalloc
##### 0、
+ **以字节为单位，确保页在物理地址上是连续的**，实现在include/linux/slab.h中
##### 12.4.1、gfp_mask标志
+ 标志分为**3种**
+ 1、行为修饰符
+ 2、区修饰符
+ 3、类型标志
##### 12.4.2、kfree
#### 12.5、vmalloc
+ **分配的内存虚拟地址是连续的，而物理地址无须连续**
#### 12.6、slab层
##### 0、
##### 12.6.1、slab层的设计
##### 12.6.2、slab分配器的接口
+ `kmem_cache_create()`
#### 12.7、在栈上的静态分配
##### 0、
+ **32位和64位体系结构的页面大小分别是4KB和8KB，所以通常它们的内核栈的大小分别是8KB和16KB**。
##### 12.7.1、单页内核栈
##### 12.7.2、在栈上光明正大地工作
#### 12.8、高端内存的映射
##### 0、
+ **在高端内存中的页不能永久地映射到内核地址空间上**。
##### 12.8.1、永久映射
+ `kmap()`
##### 12.8.2、临时映射
+ `kmap_atomic()`
#### 12.9、每个CPU的分配
+ 每个CPU的数据存放在一个数组中。
+ 内核抢占会引起下面提及的两个问题：
	+ 如果你的代码被其他
	+ 如果另一个
#### 12.10、新的每个CPU接口
##### 0、
+ **percpu**，简化了创建和操作每个CPU的数据。
##### 12.10.1、编译时的每个CPU数据
##### 12.10.2、运行时的每个CPU数据
#### 12.11、使用每个CPU数据的原因
+ 首先，**减少了数据锁定**
+ 第二个好处，**使用每个CPU数据可以大大减少缓存失效**
#### 12.12、分配函数的选择
+ 连续的物理页：**使用某个低级页分配器或kmalloc()**
	+ GFP_ATOMIC：进行不睡眠的高优先级分配
	+ GFP_KERNEL：如果有必要，进程可以睡眠
+ 不需要物理上连续的页，**仅仅需要虚拟地址上连续的页**，就使用vmalloc 【**vmalloc相对kmalloc，有一定的性能损失**】，把物理内存块映射到连续的逻辑地址空间上。
+ 如果你想从高端内存进行分配，使用alloc_pages()。**为了获得真正的指针，应该调用kmap()，把高端内存映射到内核的逻辑地址空间**。
+ 创建和撤销很多大的数据结构，考虑建立**slab高速缓存**。slab层会给每个处理器维持一个对象高速缓存（空闲链表），这种高速缓存会极大地提高对象分配和回收的性能。**为你把事先分配好的对象存放到高速缓存中**
#### 12.13、小结
+ 在内核中分配内存并非总是轻而易举，因为你必须小心地**确保分配过程遵从内核特定的状态约束**。
+ **分配内存相对复杂**是内核开发和用户开发的最大区别之一。

### chap13、

#### 13.1、通用文件系统接口

#### 13.2、文件系统抽象层

#### 13.3、Unix文件系统

+ 4种与文件系统相关的传统抽象概念
  + 文件：可以看作有序的字节串（unix把目录也看作文件）
  + 目录项：路径中的每一部分称作**目录条目**，也叫**目录项**
  + 索引节点：文件信息按照索引形式存储在单独的块中，**控制信息存储在超级块中**。
  + 安装点（mount point）

#### 13.4、VFS对象及其数据结构

+ VFS采用**面向对象**的设计原理，不过是用C语言实现的
+ VFS中有四个主要的对象类型：（这里对象是指**结构体**）
  + 超级块对象：代表一个具体的已安装文件系统
    + super_operations
  + 索引节点对象：代表一个具体文件
    + inode_operations
  + 目录项对象：代表一个目录项，是路径的一个组成部分
    + dentry_operations
  + 文件对象：代表由进程打开的文件
    + file_operations
+ 每个主要对象都包含一个**操作对象**，操作对象作为一个结构体指针来实现的

#### 13.5、超级块对象

+ `struct super_block{};`这个定义在linux/fs.h
+ **创建、管理和撤销超级块对象**代码位于fs/super.c

#### 13.6、超级块操作

+ 最重要的一个域`s_op`

#### 13.7、索引节点对象

#### 13.8、索引节点操作

#### 13.9、目录项对象

##### 13.9.1、目录项状态

##### 13.9.2、目录项缓存

#### 13.10、目录项操作

#### 13.11、文件对象

#### 13.12、文件操作

#### 13.13、和文件系统相关的数据结构

#### 13.14、和进程相关的数据结构

#### 13.15、小结

### chap14、块I/O
#### 0、
+ 系统中能够**随机（不需要按顺序）访问**固定大小数据片（chunks）的硬件设备称为**块设备**，这些固定大小的数据片就称作**块**（磁盘）
#### 14.1、剖析一个块设备
+ 块设备中最小的可寻址单元是**扇区**，最常见是512字节。
+ 块大小【**文件系统的最小寻址单元**】一般是扇区的2倍。
#### 14.2、缓冲区和缓冲区头
+ linux/buffer_head.h中的`struct buffer_head{};`
+ **缓冲区头**的目的在于描述磁盘块和物理内存缓冲区（在特定页面上的字节序列）之间的映射关系。
+ 缓冲区头的弊端
	+ 1、是一个很大且不易控制的数据结构体
	+ 2、它仅能描述单个缓冲区
#### 14.3、bio结构体
##### 0、
+ linux/bio.h中的`struct bio{};` 代表了正在现场的（活动的）以片断（segment）链表形式组织的块I/O操作。**一个片段是一小块连续的内存缓冲区**。
##### 14.3.1、I/O向量
+ bi_io_vec域指向一个`bio_vec`结构体数组，结构形式为`<page,offset,len>`，片段所在的物理页、块在物理页中的偏移位置、从给定偏移量开始的块长度
##### 14.3.2、新老办法对比
+ **利用bio结构体代替buffer_head结构**还有以下好处：
	+ bio结构体很容易处理高端内存
#### 14.4、请求队列
+ linux/blkdev.h中的`reques_queue{}`，**包含一个双向请求链表以及相关控制信息**。
#### 14.5、I/O调度程序
##### 14.5.1、I/O调度程序的工作
+ 两种方法减少磁盘寻址时间：**合并与排序**
+ 合并：
##### 14.5.2、Linux电梯
+ *加入尾部太多的话，会导致饥饿问题？lionel*
+ 一个请求加入队列中时，有可能发生四种操作，依次是：
	+ 1）如果队列中已存在一个对相邻磁盘扇区操作的请求，那么新请求将和这个已经存在的请求合并成一个请求
	+ 2）如果队列中存一个驻留时间过长的请求，那么新请求将被插入到队列尾部，以防止其他旧的请求饥饿发生
	+ 3）如果队列中以扇区方向为序存在合适的插入位置，那么新的请求将被插入到该位置，保证队列中的请求是以被访问磁盘物理位置为序进行排序的
       + 4）如果队列中不存在合适的请求插入位置，请求将插入到队列尾部
##### 14.5.3、最终期限I/O调试程序
+ block/deadline-iosched.c
+ deadline，解决电梯中的饥饿问题
+ **写-饥饿-读（writes-starving-reads）**
+ 有3个队列
	+ 读请求FIFO队列
	+ 写请求FIFO队列
	+ 排序队列
+ **降低了系统吞吐量**
##### 14.5.4、预测I/O调度程序
+ block/as-ioshed.c
+ **在保持良好的读响应的同时也能提供良好的全局吞吐量**，最主要的改进是**它增加了预测启发（anticipation-heuristic）能力**。
##### 14.5.5、完全公正的排队I/O调度程序
+ block/cfq-iosched.c
+ （Complete Fair Queuing，CFQ），**根据引起I/O请求的进程组织的**，即每一个提交I/O的进程都有自己的队列。
+ 以时间片轮转调度队列，从每个队列中选取请求数（默认值为4，可配置），然后进行下一轮调度。
##### 14.5.6、空操作的I/O调度程序
+ block/noop-iosched.c
+ **不进行排序，也不进行其他形式的预寻址操作**，忘不了执行合并
##### 14.5.7、I/O调度程序的选择
+ 内核命令行选项 `elevator=as` ，表示启用 **预测I/O**
#### 14.6、小结

### chap15、进程地址空间
#### 15.1、地址空间
+ 内存区域可以包含各种内存对象：
	+ 可执行文件代码的内存映射，称为**代码段（text section）**
#### 15.2、内存描述符
##### 0、
+ 内存描述符**表示进程的地址空间**，linux/sched.h中的`struct mm_struct{};`
+ **所有的mm_struct结构体都通过自身的mmlist域连接在一个双向链表中，该链表的首元素是init_mm内存描述符，它代表init进程的地址空间**。需要使用kernel/fork.c中的`mmlist_lock`锁来防止并发访问
##### 15.2.1、分配内存描述符
+ *没太完全明白，lionel*
##### 15.2.2、撤销内存描述符
+ kernel/exit.c中的`exit_mm()`函数，常规的撤销工作
##### 15.2.3、mm_struct与内核线程
#### 15.3、虚拟内存区域
##### 0、
+ linux/mm_types.h中的`vm_area_struct`，**指定地址空间内连续区间上的一个独立内存范围**。
##### 15.3.1、VMA标志
+ 是个位标志
##### 15.3.2、VMA操作
+ linux/mm.h中的`vm_operations_struct`结构体
##### 15.3.3、内存区域的树型结构和内存区域的链表结构
+ mmap域使用单独链表连接所有的内存区域对象
+ mm_rb域使用红-黑树连接所有的内存区域对象
##### 15.3.4、实际使用中的内存区域
+ **`pmap`工具查看给定进程的内存空间和其中所含的内存区域**
#### 15.4、操作内存区域
+ linux/mm.h中
##### 15.4.1、find_vma()
##### 15.4.2、find_vma_prev()
##### 15.4.3、find_vma_intersection()
+ 返回第一个和指定地址区间相交的VMA
#### 15.5、mmap和do_mmap：创建地址空间
+ linux/mm.h中的`do_mmap()`，**将一个地址区间加入到进程的地址空间中**
+ file指定的文件，具体映射的是文件中从偏移offset处开始，长度为len字节的范围内的数据。如果file参数是NULL并且offset参数也是0，那么就代表这次映射没有和文件有关，称为**匿名映射（anonymous mapping）**
#### 15.6、nummap和do_nummap：删除地址区间
+ linux/mm.h中的`do_mummap()`从特定的进程地址空间中删除指定地址区间
#### 15.7、页表
+ 页表定义在asm/page.h中
+ 顶级页表是**页全局目录（PGD）**，它包含一个pgd_t类型数组，
+ 二级页表是**中间页目录（PMD）**，它是个pmd_t类型数组，其中的表项**指向PTE中的表项**。
+ 最后一级的页表简称**页表**，其中包含了pte_t类型的页表项，**该页表指向物理页面**
+ （translate lookaside buffer，TLB），**一个将虚拟地址映射到物理地址的硬件缓存**。
#### 15.8、小结

### chap16、页高速缓存和页回写

#### 16.1、缓存手段
##### 16.1.1、写缓存
+ 缓存一般被实现成下面三种策略之一:
	+ 第一种：不缓存（nowrite）
	+ 第二种：写透缓存（write-through cache）：**写操作将自动更新内存缓存，同时也更新磁盘文件**。
	+ 第三种：回写，**脏页链表**
##### 16.1.2、缓存回收
+ 1、最近最少使用
+ 2、双链策略
#### 16.2、Linux页高速缓存
##### 16.2.1、address_space对象
+ linux/fs.h中的`struct address_space{};`
##### 16.2.2、address_space操作
+ linux/fs.h中的`struct address_space_operations{};`
##### 16.2.3、基树
+ lib/radix-tree.c
+ linux/radix_tree.h
##### 16.2.4、以前的页散列表
#### 16.3、缓冲区高速缓存
+ **内核提供了`bread()`实现从磁盘读一个块的底层操作**。
#### 16.4、flusher线程
##### 16.4.1、膝上型计算机模式
##### 16.4.2、历史上的bdflush、kupdated和pdflush
##### 16.4.3、避免拥塞的方法：使用多线程
#### 16.5、小结


### chap17、设备与模块
+ 设备类型：在所有Unix系统中为了统一普通设备的操作所采用的分类
+ 模块：Linux内核中用于按需加载和卸载目标码的机制
+ 内核对象：内核数据结构中支持面向对象的简单操作，还支持维护对象之间的父子关系
+ sysfs：表示系统中设备树的一个文件系统
#### 17.1、设备类型
+ 3种设备类型:
	+ 块设备：blkdev
	+ 字符设备：cdev
	+ 网络设备：ethernet devices
+ **杂项设备（miscellaneous device）**：miscdev
+ **伪设备（pseudo device）**
#### 17.2、模块
##### 17.2.1、Hello，World
##### 17.2.2、构建模块
##### 17.2.3、安装模块
+ `/lib/modules/version/kernel`
+ 命令：`make modules_install`
##### 17.2.4、产生模块的依赖性
+ `depmod -A`
+ 模块依赖关系信息存放在`/lib/modules/version/modules.dep`
##### 17.2.5、载入模块
+ `insmod`
##### 17.2.6、管理配置选项
##### 17.2.7、模块参数
+ `module_param()`宏
##### 17.2.8、导出符号表
+ `EXPORT_SYMBOL()`
#### 17.3、设备模型
##### 0、
+ 2.6增加了新特性：**统一设备模型（device model）**，提供了一个独立的机制专门来表示设备，并描述其在系统中的拓扑结构
##### 17.3.1、kobject
+ linux/kobject.h中的`struct kobject{};`
##### 17.3.2、ktype
+ linux/kobject.h中的`struct kobj_type{};`
##### 17.3.3、kset
+ linux/kobject.h中的`struct kset{};`
##### 17.3.4、kobject、ktype和kset的相互关系
##### 17.3.5、管理和操作kobject
##### 17.3.6、引用计数
+ 1、递增和递减引用计数
+ 2、kref
#### 17.4、sysfs
##### 0、
##### 17.4.1、sysfs中添加和删除kobject
+ `kobject_add()`
##### 17.4.2、向sysfs中添加文件
+ 1、
+ 2、创建新属性
+ 3、删除新属性
##### 17.4.3、内核事件层
+ `kobject_uevent()`

#### 17.5、小结