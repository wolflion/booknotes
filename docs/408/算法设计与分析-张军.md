## 《算法设计与分析》

+ 作者**张军**，因为叫这本书的比较多，这本书也许不出名，但正好自己有，就努力就把它全书读懂吧
+ 配合《趣学算法》一起看
+ 2023-08-10左右意识到自己比较大的问题，**如何用代码去定义这些ADT，比如图的存储，这涉及到一些遍历的算法，虽然有思路，但还是要依靠具体的ADT去存东西的**，争取在2023年突破掉（不管是有意识去记，还是慢慢去理解，争取消化掉）
+ 各种疑问
  + Q1，疑问在于，这些伪代码怎么去对应真实的代码的if或者各种判断
  + Q2，有些场景自己能做出填空或计算题，比如**哈夫曼树**，但代码肯定是写不出来的的，以及**Dijkstra、Prim、Kruskal**
+ 各种整理
  + 一、绪论：**组合问题**怎么定义？
  + 五、贪心：用在 **图**（最短距离）和**组合**（背包问题）
  + 六、动规：用在**查找**，**图**，**组合**（背包、最长公共子序列）
    + 最长公共子序列，这个我应该OK了，*尝试刷些题目看看*

### chap1、绪论

1.1、算法的基本概念

#### 1.2、算法设计与分析的重要问题类型

1.2.1、排序问题

1.2.2、查找问题

1.2.3、图问题

##### 1.2.4、组合问题

+ **Combinatorial Problem**，从离散的空间中寻找到一个对象，使之能够满足特定的标准。
  + 旅行商问题（Travelling Sales Problem）
  + 车辆路由问题 （Vehicle Routing Problem）

1.2.5、数值问题

1.2.6、几何问题

#### 1.3、算法复杂性分析基础

1.3.1、算法复杂性分析的原理

1.3.2、渐近符号

#### 1.5、习题

### chap2、基本数据结构

#### 2.1、数据结构的概念

#### 2.2、线性结构

#### 2.2.1、线性表

+ 2020-11-05就写过笔记，**有哪些常用的ADT方法** 【知道思路后再写代码（集合的并、删除重复元素）】
+ 顺序存储【**静态分配、动态分配**】
  + 顺序线性表逆置
  + 找最大最小值和位置

```cpp
#define ListSize 100
typedef int DataType;
typedef struct {
    DataType data[ListSize]; //分配的大小  【等价于 DataType *elem;】
    int length; //实际存储个数
}SeqList;
```



+ 链式存储（单链表）
  + **先整节点**

```cpp
//节点,包含{元素和指针}
typedef struct node{
    DataType data;
    struct node *next;
}ListNode;

typedef ListNode* LinkList;//是不是就指向头节点了？
```

+ 双向链表
  + **节点的差别**，多了一个指针

```cpp
//节点,包含{元素和指针}
typedef struct dlnode{
    DataType data;
    struct dlnode *next,*prior;
}DLNode;

typedef DLNode* DoubleLinkList;//lionel，是不是这样？
```



2.2.2、栈

2.2.3、队列

##### 2.2.4、串

+ *kmp，后面学一下，lionel*

#### 2.3、树形结构

##### 2.3.1、树的定义与性质

+ 树的性质
  + 1、

##### 2.3.2、二叉树

+ 1、定义和性质
  + 满二叉树
  + 完全二叉树
  + 二叉排序树
  + 平衡二叉树
  + 二叉树的基本性质（*这个要记一下，其它书上也都有，应该都是一样的，lionel*）
    + 1、第i层上最多有2的(i-1)次方个结点
    + 2、如果高度为h，至多有2的h次方，再-1个结点
    + 3、
    + 4、完全二叉树有n个节点，高度h=log2n取最少，再加1
    + 5、
+ 2、存储结构
  + 顺序存储
  + 链式存储
+ 3、二叉树的遍历
  + 先序
  + 中序
  + 后序

##### 2.3.3、多叉树

#### 2.4、图状结构

+ 图的遍历，*这个我自己的笔记，单独写过*

##### 2.4.1、图的定义

##### 2.4.2、图的存储结构

+ 2022-08-09写过笔记，*因为也消化了，只是后面没用，也许就忘记了*

+ 1、矩阵存储
  + 描述
    + 2维数组，是边就写1，或者写**权值**
    + 行是：v0，v1，v2，v3，v4
    + 列是：v0，v1，v2，v3，v4
    + v0到v0，肯定就0，v0到v1是不是有边，**有边就1，或者权值**
+ 2、邻接表（也就是**链接存储**）
  + 描述
    + v0连了谁，就指向谁，一直到结束
    + v1连了谁
    + v2连了谁
    + v3连了谁
    + v4连了谁
  + 如果有向图，**出边**（邻接表），**入边**（逆邻接表）
+ 3、带权图

##### 2.4.3、图的遍历

+ 1、BFS
+ 2、DFS  （*有了递归了，可以不栈去存*）
  + [深度优先搜索两种实现方法java模板 递归和栈以及使用栈的潜在问题](https://blog.csdn.net/usualheart/article/details/108103136)

```cpp
DFS(G,s)
    1 visit(s)
    2 visited[s] <- TRUE
    3 for each v 属于 adj[s]
        do if visited[v] == FALSE
            then DFS(G,v)
```



#### 2.5、集合与字典（set与map）*感觉叫这个比较好*

+ 之前看了一下人家的面试题，map和set有啥区别？【*虽然STL的读书笔记里有写，但2者的区别，自己还没有完全搞得特别明白*】

##### 2.5.1、集合（Set）

+ 集合的3大特性
  + 确定性
  + 无序性
  + 互异性
+ 集合的三种基本运算

##### 2.5.2、字典（dictory）

+ 集合的特殊形式，**每个元素，由Key和Value组合，这个组合称为**【关联association】，难怪叫*关联容器*
+ 字典的**散列存储**（hash）

#### 2.6、本章小结

2.7、习题

### chap3、蛮力

+ Q1：**图、数值**一般不用蛮力？

3.1、算法设计思想

#### 3.2、排序问题

##### 3.2.1、选择排序

+ 思想：从第一个元素开始扫描，找到最小的，与第一个位置的元素交换
+ 过程：84，53，68，96，32，38，16进行选择排序
  + 第一趟：找到最小的16，与第一个位置交换，即16，53，68，96，32，38，84
  + 第二躺：**在剩下的里面**，找到最小的32，与剩下的第一个位置交换，16，32，68，96，53，38，84
  + 以此类推

+ 伪代码，*并没有完全理解，lionel*

```cpp
SELECTION-SORT(A)
    for i<-0 to n-2   //不太懂的是这个，为啥只到n-2次，lionel
        do min = i
            for j<- i+1 to n-1   //lionel，这个表示遍历完剩下的，找到最小的下标，先记下来，最后统一交换【为了减少交换次数】
                do if A[j] < A[min]
                    then min <- j
            SWAP(A[i],A[min])
```

##### 3.2.2、冒泡（交换）

+ 思想：从第一个元素开始，不断比较相邻的两个元素
+ 过程：84，53，68，96，32，38，16进行冒泡排序
+ 伪代码

```cpp
SELECTION-SORT(A)
    for i<-0 to n-2
        do for j<-0 to n-2-i  //lionel，这个不太理解
            do if A[j+1] < A[j]
                then SWAP(A[j+1],A[j])
```



#### 3.3、查找问题

##### 3.3.1、顺序查找

+ 思想：
+ 过程：
+ 伪代码：

```cpp
SEQUENTIAL-SEARCH(A)
    for i<-0 to n-1
        do if A[i]=T
            then return i
    return -1
```



3.3.2、串匹配

#### 3.4、组合问题

3.4.1、旅行商问题

3.4.2、背包问题

3.4.3、任务分配问题

#### 3.5、几何问题

3.5.1、最近点对问题

3.5.2、凸包问题

3.6、本章小结

3.7、习题

### chap4、分治

+ Q1：**图、数值**一般不用分治？

4.1、算法设计思想

#### 4.2、排序问题

##### 4.2.1、归并排序

+ 思想
+ 举例：对5，3，7，2，4，8，6，1进行归并排序，写出其主要操作过程

+ 伪代码

```cpp
//封装为2个函数
```



##### 4.2.2、快速排序

+ 思想
+ 举例：对5，3，7，2，4，8，6，1进行快速排序，写出其主要操作过程

+ 伪代码

```cpp
//先高层，再低层，即封装成1个函数，partition()，再递归

QUICK-SORT(A,l,r)
    if l<r
        then s <- PARTITION(A,l,r)
        QUICK-SORT(A,l,s-1)
        QUICK-SORT(A,s-1,r)

//再求这个
PARTITION(A,l,r)
i<-l+1
j<-r
k<-A[l]  //取第一个为基准
while i<j
    do while i<r and A[i]<k  //lionel，也好理解，左边的全部小于k时，把i++
        do i<-i+1
       while A[j]>k //右边的全大于k的时候，j++
        do j<-j-1
       if i<j         //lionel,这个不太理解了，这个if是啥意思？【遇到了第1个大于或小于它的就交换，不然后面的永远执行不下去了】
        then SWAP(A[i],A[j])
SWAP(A[l],A[j])//lionel，这个地方是交换基准值
return j
```



#### 4.3、查找问题

##### 4.3.1、折半查找

+ 伪代码

```cpp
BINARY-SEARCH(A,T)
l<-0
r<-n-1
    while l<=r  //lionel,这是核心，我一般会忘记用while
        do m <- (l+r)/2
            if T = A[m]
                then return m
            else if T < A[m]
                then r<-m-1   //在数组位置m的左边
            else l<-m+1   //在数组位置m的右边
return -1
```



4.3.2、二叉树遍历算法

#### 4.4、组合问题

4.4.1、最大子段和问题

4.4.2、棋盘覆盖问题

#### 4.5、几何问题

4.5.1、最近点对问题

4.5.2、凸包问题

4.6、本章小结

4.7、习题

#### 《趣学算法》一书中的题

### chap5、贪心

+ **排序、查找、数值、几何**不用贪心

5.1、算法设计思想

5.1.1、贪心算法的设计思想

5.1.2、贪心算法的求解过程

#### 5.2、图问题

##### 5.2.3、哈夫曼树

+ *lionel，这个逻辑我会，但代码写不出来*

#### 5.3、组合问题

+ Q1，我不是很能理解，把背包规为**组合问题**，难道是*离散空间里的最优解？ lionel*

##### 5.3.1、背包问题

+ 0-1背包，**物品不可拆分**
+ 部分背包，**可以只装入部分**
+ 伪代码（*部分背包了*）

```cpp
KNAPSACK-GREEDY(w,A,n)  //w是最大承重量，A是n个物品有序序列【weight和in（有多少重量放入背包）2个属性】，n个物品
    1 i<-w  //lionel，不懂为啥要赋值给i  【看完懂了，主要是每次要减去一些放入的，然后才是剩下的，第一次是 最大的】
    2 for j <- 1 to n
        do if i = 0   //表示最大承重为0
            break;
           else if A[j].weight <= i  //当前的重量小于最大承重
               then A[j].in <- A[j].weight
               else
                   A[j].in <- i
                i <- i-A[j].in //表示每次还剩多少【最大承重量】
```



+ *最终可能不是最优解*，但把问题简化为**线性的问一下，每个物品，存，存不存2种判断**

##### 5.3.2、活动安排问题

+ **每次选结束时间最早的**
+ 伪代码

```cpp
ACTIVITY-ASSIGN-GREEDY(m, s, f, n)  //n是活动数目，s是start,f是finish，m是编号
    A <- {m[1]},pre <- 1   //lionel，不太懂，直接给把编号1放入到集合里，还预设了一个变量pre？
    for i <- 2 to n
        do if(s[i]>=f[pre]) //只要是开始时间  大于 当前的结束时间，就属于处理逻辑，【其它场景，直接抛弃，不处理了？lionel】
            then A <- A U {m[i]}  //把当前这个i放入到集合里
                 pre <- i //更新pre变量
    return A
```



+ other

##### 5.3.3、多机调度问题

+ 问题描述：n个作业（job）要分配到m台机器（Machine）上，每个作业的时间（Time）
+ *这个自己还没看，其实应该不难，这个要想一下？*

5.4、本章小结

5.5、习题

### chap6、动态规划

#### 其它书籍

+ 2022-08-26，看了《算法图解》chap6的内容（背包、最长公共子串），*当时并没有完全理解*【要想一下 背包 问题，感觉那个二维图，我还是没真的懂】

6.1、算法设计思想

6.2、查找问题中的动态规划算法

#### 6.3、图问题中的动态规划算法

6.3.1、多段图的最短路径问题

6.3.2、多源最短路径问题：Floyd算法

#### 6.4、组合问题中的动态规划算法

##### 6.4.1、0/1背包问题

##### 6.4.2、最长公共子序列问题

+ 最长公共子序列（Longest Common Subsequence）LCS
+ 我的思路：
  + 两层for循环，二维数组L[i,j]分别代表a串，b串的长度组成的数组，初始化为0
  + 如果相等就好说，`L[i,j]的值=L[i-1,j-1]的值+1`，即可
  + 要是不相等，就取**左边或上面的那个最大值**`L[i,j] = max(L[i-1,j],L[i,j-1])`，*当时看了没懂啥意思，回来总结时懂了*
+ 伪代码

```cpp
LCS(L,a,b,n,m)
    for i <- 0 to n
        do L[i,0] <- 0
    for j <- 0 to m
        do L[0,j] <- 0   //为什么不直接2层for循环给 n*m 的
            
    //这时开始2层for循环了
    for i <- 1 to m 
        do for j <- 1 to n
            do if a[i] = b[j]
                then L[i,j] = L[i-1,j-1] + 1
               else
                L[i,j] = max(L[i-1,j],L[i,j-1]) 
    return L[n,m] //lionel，这个return到底在哪？   其实无所谓，返回的是数组里面的最后一个值
```



6.5、本章小结

6.6、习题

### chap7、回溯

#### 7.3、组合问题中的回溯算法

##### 7.3.1、0/1背包问题

##### 7.3.2、八皇后问题

+ 看《趣学算法》里的代码实现比较简单，*但那个数组的定义，没太搞明白，把2维的压缩了一下*
+ 伪代码
  + *还是没太看懂，想结合，代码再看一下呢*

```cpp
//判断是不是
CONSTRAIN(v,k)        // v表示个数组，具体表示啥？k表示啥？第几层？几层又是怎么划分的呢？
    for i <- 1 to k-1
        do if(v[i]==v[k] or abs(v[i]-v[k])==abs(i-k))
            then return FALSE
    return TRUE  //思路是，只要不是false，最终都是true
            
N_QUEENS()
    INITIVAL(v)
    l <- 0
    while l >= 0
        do for every node n[i] in the l th layer
            do v[l] <- n[i]
                if CONSTRAIN(v,l)
                    then if v is complete solution
                        then SAVE_SOLUTION(v)
                        else
                            l <- l+1
                    else
                        l <- l-1
```

7.3.3、图着色问题

7.4、本章小结

7.5、习题

#### 《趣学算法》chap5中的题

##### 5.5、N皇后问题