### chap8、文件系统

#### 8.1、概述

+ VFS在系统启动时建立，在系统关闭时消亡。
+ Minix为例
  + 文件系统开头，**通常为一个扇区**，存入引导程序
  + 超级块，存储磁盘设备上文件系统结构的信息，并说明各部分的大小
  + i节点位图：描述磁盘上每个i节点的使用情况。除了位0，i节点位图中每个比特位依次代表盘上i节点区中的一个i节点。
  + 逻辑块位图：磁盘上每个逻辑块的使用情况。除了位0，其它位依次表示盘上逻辑块区中的一个逻辑块。
  + i节点：反映的是**文件的元数据**
  + 逻辑块编号：**保存文件的数据**。每个文件有且仅有一个i节点，但可以有0，1或多个逻辑块

#### 8.2、文件系统对象

##### 8.2.1、

+ fs/filesystem.c中register_filesystem()
+ include/linux/fs.h中的`struct file_system_type{};`

##### 8.2.2、

+ include/linux/fs.h中的`struct super_block{};`

##### 8.2.3、

+ include/linux/fs.h中的`struct inode{};`
+ 以ext2为例，`struct ext2_inode_info{};`

##### 8.2.4、

+ **inode反映的是文件系统对象的元数据，而dentry则表示文件系统对象在文件系统树中的位置**。dentry和inode是多对一的关系，每个dentry只有一个inode，由d_inode指向；而一个inode可能对应多个dentry（例如硬链接），它将这些dentry组成以i_dentry的链表，每个dentry通过d_alias加入所属inode的i_dentry链表中。
+ include/linux/dcache.h中`struct dentry{};`

##### 8.2.5、

+ include/linux/mount.h中的`struct vfsmount{};`

#### 8.3、装载文件系统

+ 装载的4个要素：**vfsmount、super_block、根dentry、根inode**。

##### 8.3.1、

+ fs/namespace.c中的`sys_mount()`
+ `sys_mount()`->`do_mount()`->`do_new_mount()`

##### 8.3.2、

+ `sys_mount()`->`do_mount()`->`do_new_mount()`->`do_kern_mount()`
+ `sys_mount()`->`do_mount()`->`do_new_mount()`->`do_kern_mount()`->`vfs_kern_mount()`

+ **构建文件系统装载实例**，即构建vfsmount，super_block，根dentry和根inode之间的关系。

##### 8.3.3、 

+ `sys_mount()`->`do_mount()`->`do_new_mount()`->`do_kern_mount()`->`vfs_kern_mount()`->`minix_get_sb()`->`get_sb_bdev()`

##### 8.3.4、

+ `sys_mount()`->`do_mount()`->`do_new_mount()`->`do_kern_mount()`->`vfs_kern_mount()`->`minix_get_sb()`->`get_sb_bdev()`->`minx_fill_super()`

##### 8.3.5、

+ `sys_mount()`->`do_mount()`->`do_new_mount()`->`do_add_mount()`【fs/namespace.c中】

#### 8.4、路径查找

+ 用户空间表示文件使用的是路径名字符串，内核中对文件的操作需要依据**超级块、inode、dentry以及vfsmount等**。

+ include/linux/path.h

+ 某个目录下查找给定名字的文件，有三个动作：

  + 1、读出目录的内容，找到该文件对应的项，获得其i节点编号
  + 2、从i节点表中找到该编号的inode，它直接或间接指向包含文件数据的逻辑块
  + 3、读取这些逻辑块即能获得该文件的内容

+ include/linux/namei.h中的`struct nameidata{};`

  ##### 8.4.1、

+ fs/namei.c中的`path_lookup()`

  + *2.6.18代码还是有点的*

    ##### 8.4.2、逐个分量解析

+ `link_path_walk()`，**重点**

  ##### 8.4.3、解析单个分量

+ `do_lookup()`

  ##### 8.4.4、上溯通过装载点

+ `follow_dotdot()`

  ##### 8.4.5、下溯通过装载点

+ `follow_mount()`

  ##### 8.4.6、处理符号链接

+ `do_follow_link()`

#### 8.5、打开文件

+ 将路径名转换为**内核中唯一定位的`<vfsmount,dentry>`二元组**

+ 文件描述符，**指的是file结构的对象**

+ 每个进程可以打开多个文件，将它们组织成打开文件表的形式，实际上是指向文件描述符的指针数组，**数组索引即为文件句柄**。

+ 打开文件表在内核中对应fdtable结构中，include/linux/fdtable.h中的`struct fdtable{};`

+ include/linux/fs.h中的`struct file{};`

+ include/linux/fdtable.h中的`struct files_struct{};`

  ##### 8.5.1、open系统调用的处理流程

+ 分配一个文件描述符，正确设置`f_mapping（文件地址空间）`和`f_op（文件操作表）`，在打开文件表中找到一个用于保存它的文件句柄。

+ sys_open()->do_sys_open()->do_filp_open()->do_last()->namidata_to_filp()->`__dentry_open()`，lionel，这个要花时间去串一下代码注释，2月17日晚上逐行读一下

#### 8.6、读文件（重点）

+ **地址空间（Address Space）** 的引入，将对象在磁盘中（可能不连续的）数据以及页面为单位连续地呈现出来。

+ include/linux/fs.h中的`struct address_space{};`

+ 地址空间的属主对象被定义为属主对象的inode。**对于常规文件或目录文件，这就是文件对应的inode描述符**。

+ radix树，**树的根节点为地址空间的page_tree域**，文件inode地址空间保存的是数据块。

+ **VFS通过调用write_begin通知具体文件系统，准备写文件的字节begin~end到给定的页面**。

+ include/linux/mm_types.h中的`struct page{};`

  ##### 8.6.1、

+ sys_read()->vfs_read()->do_sync_read()->generic_file_aio_read()->do_generic_file_read() 【mm/filemap.c】

##### 8.6.2、基于缓冲页面构造I/O请求

+ **缓冲页面**：是指将页面划分为一个个的缓冲块（Buffer Block），以缓冲块为单位进行I/O。
+ 管理缓冲块的数据结构为`buffer_head`，被称作**缓冲头**
+ I/O的基本单位已经换成bio，而buffer_head仅被用来提取块映射（通过get_block_t调用），用于跟踪页面的状态（通过page_mapping），以及用于封装bio提交以向后兼容（例如submit_bh）
+ *706/792，把书中的内容提了一下*，lionel，把之前的疑惑

##### 8.6.3、直接针对页面构造I/O请求

+ Linux为基于磁盘的文件系统提供另一种策略，构造尽可能大的bio向下层提交。对应的函数为`mpage_readpage()`，实际上ext3文件系统readpage方法实现为`ext3_readpage()`【fs/ext3/inode.c】就是直接调用mpage_readpage函数

8.7、写文件

8.8、冲刷文件

#### 8.9、块设备文件

##### 8.9.1、块设备的主inode和次inode

##### 8.9.2、对块设备文件的操作转换为对块设备的操作

##### 8.9.3、对块设备文件的读/写作用于块设备之上

#### 8.10、文件系统编程模式

+ 实施步骤如下：
  + 1、定义超级块结构
  + 2、定义inode结构
  + 3、实现各种类型文件的inode操作表
  + 4、实现各种类型文件的file操作表
  + 5、实现各种类型文件的address_space操作表
  + 6、实现超级块操作表
  + 7、实现dentry操作表
  + 8、定义文件系统类型
  + 9、模块加载和卸载方法

