### PartII：Concurrency并发

#### chap25、并发的对话

+ 吃一个桃子？

#### chap26、并发：简介

##### 26.3、问题的核心：自由安排

##### 26.4、原子性

#### chap27、插曲：线程API

##### 27.1、线程创建

##### 27.2、线程完成

+ 如果你想等待线程完成，会发生什么情况？你需要做一些特别的事情来等待完成。

+ `pthread_join(pthread_t, )`
  + 第1个参数，用于指定要等待的线程
  + 第2个参数，指向你希望得到的返回值

##### 27.3、锁

+ 通过**锁来互斥进入临界区**的那些函数

##### 27.4、条件变量

+ **当线程之间必须发生某种信号时，如果一个线程在等待另一个线程继续执行某些操作**，条件变量就很有用。
+ **要使用条件变量，必须另外有一个与此条件相关的锁**。
+ `int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);`**使调用线程进入休眠状态**，因此等待其它线程发出信号，通常当程序中的某些内容发生变化时，现在正在休眠的线程可能会关心它。

##### 27.5、编译和运行

+ 增加`-pthread`标记，例：`gcc -o main main.c -Wall -pthread`

##### 27.6、小结

+ `man -k pthread`
+ **线程难的部分不是API，而是如何构建并发程序的棘手逻辑**。

#### chap28、锁

##### 28.1、锁的基本思想

+ 锁为程序员提供了最小程度的调度控制。通过给临界区加锁，可以保证临界区内只有一个线程活跃。**锁将原本由操作系统调度的混乱状态变得更为可控**。

```c++
lock_t mutex;//some globally-allocated lock 'mutex'
...
lock(&mutex);
balance = balance + 1;
unlock(&mutex);
```

##### 28.2、pthread锁

+ POSIX库将锁称为**互斥量（mutex）**，因为它被用来提供线程之间的互斥。即当一个线程在临界区，它能够阻止其他线程进入直到本线程离开临界区。

##### 28.3、实现一个锁

+ 怎样实现一个锁？
+ **我们需要硬件和操作系统的帮助来实现一个可用的锁**。

##### 28.4、评价锁

##### 28.5、控制中断

##### 28.6、测试并设置指令（原子交换）

##### 28.7、实现可用的自旋锁

##### 28.8、评价自旋锁

##### 28.9、比较并交换

##### 28.10、链接的加载和条件式存储指令

##### 28.11、获取并增加

##### 28.12、自旋过多：怎么办

##### 28.13、简单方法：让出来吧，宝贝

##### 28.14、使用队列：休眠替代自旋

##### 28.15、不同操作系统，不同实现

##### 28.16、两阶段锁

##### 28.17、小结

#### chap29、基于锁的并发数据结构

##### 29.1、并发计数器

##### 29.2、并发链表

##### 29.3、并发队列

##### 29.4、并发散列表

##### 29.5、小结

#### chap30、条件变量

##### 30.1、定义和程序

##### 30.2、生产者/消费者（有界缓冲区）问题

##### 30.3、覆盖条件

#### chap31、信号量

##### 31.1、信号量的含义

##### 31.2、二值信号量（锁）

##### 31.3、信号量用作条件变量

##### 31.4、生产者/消费者（有界缓冲区）问题

##### 31.5、读者-写者锁

##### 31.6、哲学家就餐问题

##### 31.7、如何实现信号量

##### 31.8、小结

#### chap32、常见并发问题

##### 32.1、有哪些类型的缺陷

##### 32.2、非死锁缺陷

##### 32.3、死锁缺陷

##### 32.4、小结

#### chap33、基于事件的并发（进阶）

##### 33.1、基本想法：事件循环

##### 33.2、重要API：select()（或poll()）

##### 33.3、使用select()

##### 33.4、为何更简单？无须锁

##### 33.5、一个问题：阻塞系统调用

##### 33.6、解决方案：异步I/O

##### 33.7、另一个问题：状态管理

##### 33.8、什么事情仍然很难

#### chap34、并发的总结对话

### Part3、持久性

#### chap35、关于持久性的对话

## 履历

+ 2022年27W（7.5-7.）看Part2并发的chap26，但习题没做和练习，只是有个概念