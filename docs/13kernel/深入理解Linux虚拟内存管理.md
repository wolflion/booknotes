## 《深入理解Linux虚拟内存管理》

+ 200页是理论的，后面的附录，是代码方面
+ 目录 在（10/674）
### chap2、描述物理内存   （28/674）
#### 0、
+ 每个簇都被认为是一个节点，在linux中的`struct pg_data_t`体现了这一概念
+ 在内存中，每个节点被分成很多的称为**管理区（zone）** 的块，用于表示内存中的某个范围。一个管理区由一个`struct zone_struct`描述，并被**定义为`zone_t`**
+ 管理区分为几段:
	+ ZONE_DMA，内存的首部16MB
	+ ZONE_NORAML，16~896MB
	+ ZONE_HIGHMEM，896~末尾
+ 系统的内存划分成大小确定的许多块，这些块也称为**页面帧**。每个物理页面帧由一个`struct page`描述，所有的结构都存储在一个**全局mem_map数组中**，该数组通常存放在`ZONE_NORMAL`的首部。
+ 图2.1，**节点、管理区和页面的关系**

#### 2.1、节点
+ linux/mmzone.h中`typedef struct pglist_data{}pg_data_t;`
+ `pgdat_list`链表维护，由函数`init_bootmem_core()`初始化节点
#### 2.2、管理区
+ linux/mmzone.h中的`struct zone_t{};`描述，`zone_structs`用于**跟踪诸如页面使用情况统计数，空闲区域信息和锁信息**。
##### 2.2.1、管理区极值
+ **当系统中的可用内存很少时，守护程序kswapd被唤醒开始释放页面**。
+ 每个管理区有3个极值:
	+ pages_low
	+ pages_min
	+ pages_high
##### 2.2.2、计算管理区大小
+ 用`setup_memory()`
+ mm/bootmem.c
##### 2.2.3、管理区等待队列表
#### 2.3、管理区的初始化
+ `paging_init()`
#### 2.4、初始化mem_map
+ 在NUMA系统中，全局mem_map被处理为一个起始于`PAGE_OFFSET`的虚拟数组。`free_area_init_node()`
+ 在UMA系统中，`free_are_init()`使用config_page_data作为结点，并将全局mem_map作为该节点的局部mem_map
#### 2.5、页面
+ linux/mm.h中的`struct page{};`，类型`mem_map_t`
+ **表2.1 描述页面状态的标志位**
#### 2.6、页面映射到管理区
+ linux/page_alloc.c中的`zone_table`
#### 2.7、高端内存
+ 内核通过`kmap()`将高端内存的页面临时映射成`ZONE_NORMAL`
#### 2.8、2.6中有哪些新特性
+ 节点
+ 管理区
+ 页面
+ Per-CPU上的页面链表

### chap3、页表管理  （45/674）
#### 0、
+ **三层页表机制来完成内存管理**
#### 3.1、描述页目录
+ **每个进程都有一个指向其自己PGD的指针（`mm_struct->pgd`），它其实就是一个物理页面帧**。
+ asm/page.h中的`pgd_t`类型
+ `PMD_SHIFT`表示在线性地址中第二级页表所映射的位。
#### 3.2、描述页表项
+ **三层页表中的每一个项PTE，PMD，PGD分别由pte_t，pmd_t，pgd_t描述**
#### 3.3、页表项的使用
+ asm/pgtable.h中
	+ `pgd_offset()`
+ mm/memory.c中`follow_page()`
#### 3.4、页表项的转换和设置
+ `mk_pte()`
+ `pte_page()`
+ `set_pte()`
#### 3.5、页表的分配和释放
#### 3.6、内核页表
##### 3.6.1、引导初始化
+ arch/i386/kernel/head.S中的`startup_32()`
##### 3.6.2、收尾工作
+ `paging_init()`
#### 3.7、地址和struct page之间的映射
##### 3.7.1、物理和虚拟内核地址之间的映射
+ asm-i386/page.h中
##### 3.7.2、struct page和物理地址间的映射
+ asm-i386/pae.h中
#### 3.8、转换后援缓冲区（TLB）
+ asm/pgtable.h中
#### 3.9、一级CPU高速缓存管理
+ asm/pgtable.h中
#### 3.10、2.6中有哪些新特性
+ MMU-less体系结构的支持
+ 反向映射
+ 基于对象的反向映射
+ 高端内存中的PTE
+ 大型TLB文件系统
	+ linux/hugetlb.h中
+ 高速缓存刷新管理
	+ `flush_page_to_ram()`

### chap4、进程地址空间  （65/674）

#### 4.1、线性地址空间
+ 地址空间分为两个部分：
	+ 一个是随上下文切换而改变的用户空间部分
	+ 一个是保持不变的内核空间部分  **两者的分界点由PAGE_OFFSET决定，在x86中它的值是`0xC0000000`**
#### 4.2、地址空间的管理
+ 进程可使用的地址空间由`mm_struct`管理
#### 4.3、进程地址空间描述符
##### 0、
+ linux/sched.h中的`mm_struct`
##### 4.3.1、分配一个描述符
+ `Allocate_mm()`只是一个预处理宏，它从slab allocator中分配一个mm_struct
+ `mm_alloc()`从slab中分配，然后调用`mm_init()`对其初始化
##### 4.3.2、初始化一个描述符
+ `mm_struct`通过`init_mm()`初始化
##### 4.3.3、销毁一个描述符
+ **如果mm_users变成0，所有的映射区域通过`exit_mmap()`释放，同时释放页表**。
#### 4.4、内存区域
+ linux/mm.h中的`struct vm_area_struct{};`
##### 4.4.1、内存区域的操作
#### 4.5、异常处理
#### 4.6、缺页中断
#### 4.7、复制到用户空间/从用户空间复制
#### 4.8、2.6中有哪些新特性

### chap5、引导内存分配器   88（101/674）
#### 5.1、表示引导内存映射
+ **系统内存中的每一个节点都存在一个`bootmem_data`结构**，在linux/bootmem.h中
#### 5.2、初始化引导内存分配器
+ **每一种体系结构中都提供了一个`setup_arch()`**，用于获取初始化引导内存分配器时所必须的参数信息。
#### 5.3、初始化bootmem_data
+ 一旦`setup_memory()`确定了可用物理页面的界限。
#### 5.4、分配内存
+ `reserve_bootmem()`函数用于保存调用者所需的页面
+ UMA结构中，4个简单的分配函数:
	+ alloc_bootmem()
	+ alloc_bootmem_low()
	+ alloc_bootmem_pages()
	+ alloc_bootmem_low_pages()
+ NUMA结构中，同样有相似函数
#### 5.5、释放内存
+ 只有2种，**用于UMA的`free_bootmem()`，和用于NUMA的`free_bootmem_node()`**，两者都调用`free_bootmem_core()`，**只是NUMA中的不提供参数pgdat**。
#### 5.6、销毁引导内存分配器
+ 启动过程的末期，系统调用函数`start_kernel()`，这个函数知道此时可以安全地移除启动分配器和与之相关的所有数据结构。**每种体系都要求提供`mem_init()`函数，该函数负责清除启动内存分配器和与之相关的结构**。
#### 5.7、2.6中有哪些新特性
+ 第1个优化是在bootmem_data_t结构中增加了last_success字段
+ 第2个优化也和线性搜索有关
+ 最后的一个变更与NUMA体系结构及相似的体系结构有关


### chap6、物理页面分析  94（109/674）
#### 6.1、管理空闲块
+ linux/mm.h中
+ **内存对于每一个阶都维护数据结构数组`free_area_t`，用于指向一个空闲页面块的链表**。
#### 6.2、分配页面
+ `alloc_pages()`
#### 6.3、释放页面
+ `__free_page()`
#### 6.4、获得空闲页面（GFP）标志位
#### 6.5、进程标志位
+ **内外部碎片问题**
+ 外部碎片，是由于可用内存全部是小块而不能满足要求
+ 内部碎片，是由于一个大的块必须被分开来响应一些小的请求而浪费的空间
+ 影响分配器行为的进程标志位:
	+ PF_MEMALLOC
	+ PF_MEMDIE
	+ PF_FREE_PAGES
#### 6.6、防止碎片
+ 用slab分配器将页面块切割为小的内存块进行分配
#### 6.7、2.6中有哪些新特性
+ 分配页面
+ Per-CPU的页面链表
+ 空闲页面
+ GFP标志位

### chap7、非连续内存分配   （120/674）
#### 7.1、描述虚拟内存区
+ linux/malloc.h中的`vm_struct`
#### 7.2、分配非连续区域
+ `vmalloc()`，`vmalloc_dma()`，`vmalloc_32()`在连续的虚拟地址空间分配内存
#### 7.3、释放非连续区域
+ `vfree()`
#### 7.4、2.6中有哪些新特性
+ 所有的页表都由`_vmalloc()`预先分配，然后存储在一个数组中并传递给函数`map_vm_area()`，由它向内核表中插入页面

### chap8、Slab分配器   110（125/674）
#### 0、
+ Slab分配器的基本思想是:**将内核中经常使用的对象放到高速缓存中，并且由系统保持为初始的可利用状态**。
#### 8.1、高速缓存
+ `cat /proc/slabinfo`
##### 8.1.1、高速缓存描述符
+ mm/slab.c中的`struct kmem_cache_s`
##### 8.1.2、高速缓存静态标志位
+ linux/slab.h中
##### 8.1.3、高速缓存动态标志位
##### 8.1.4、高速缓存分配标志位
##### 8.1.6、创建高速缓存
+ `kmem_cache_create()`
##### 8.1.7、回收高速缓存
##### 8.1.8、收缩高速缓存
##### 8.1.9、销毁高速缓存
+ `kmem_cache_destroy()`
#### 8.2、Slabs
##### 8.2.1、存储slab描述符
##### 8.2.2、创建slab
##### 8.2.3、跟踪空闲对象
##### 8.2.4、初始化kmem_bufctl_t数组
##### 8.2.5、查找下一个空闲对象
##### 8.2.6、更新kmem_bufctl_t
##### 8.2.7、计算slab中对象的数量
##### 8.2.8、销毁slab
#### 8.3、对象
##### 8.3.1、初始化slab中的对象
##### 8.3.2、分配对象
##### 8.3.3、释放对象
#### 8.4、指定大小的高速缓存
##### 8.4.1、kmalloc()
##### 8.4.2、kfree()
#### 8.5、per-CPU对象高速缓存
##### 8.5.1、描述per-CPU对象高速缓存
##### 8.5.2、在per-CPU高速缓存中添加/移除对象
##### 8.5.3、启用per-CPU高速缓存
##### 8.5.4、更新per-CPU高速缓存的信息
##### 8.5.5、清理per-CPU高速缓存
#### 8.6、初始化Slab分配器
#### 8.7、伙伴分配器接口
#### 8.8、2.6中有哪些新特性
+ 高速缓存描述符
+ 高速缓存静态标志位
+ 回收高速缓存
+ 其他的改变