<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>OD基础题 - lionel的技术笔记</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "OD\u57fa\u7840\u9898";
        var mkdocs_page_input_path = "96output\\OD\u57fa\u7840\u9898.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> lionel的技术笔记
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../01daily/">daily</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../02ds/">ds</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../03cpp/">cpp</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../21tool/">tool</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">C++</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/effectiveC%2B%2B/">《Effective C++》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">《深度探索C++对象模型》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/EffectiveSTL/">《Effective STL》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/C%2B%2B%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/">《C++泛型STL原理和应用》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">《STL源码剖析》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../22C%2B%2Bmodern/%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8C%2B%2B11/">《深入应用C++11》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">基础知识</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">《操作系统导论》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">《大话设计模式》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90_C%2B%2B4th/">《数据结构与算法分析_C++4th》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E7%AE%97%E6%B3%95%284th%29/">《算法4th》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%BC%A0%E5%86%9B/">《算法设计与分析-张军》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E5%A4%A9%E8%A1%8C-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《天行-算法设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B-%E6%9D%8E%E6%98%A5%E8%91%86/">《数据结构教程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%96%B0%E7%BC%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E4%B8%8E%E8%A7%A3%E6%9E%90/">《新编数据结构习题与解析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网络编程</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">《TCP/IP网络编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">《Linux高性能服务器编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71/">《TCPIP详解卷1》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90/">《Linux内核网络栈源代码情景分析》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C/">《深入理解Linux网络》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">机器&深度学习</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../30machineLearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/">《机器学习线性代数基础》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../31deepLearning/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%9A%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《深度学习入门：基于Python的理论与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">文件系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/Linux%E5%86%85%E6%A0%B8%E6%8E%A2%E7%A7%98/">《Linux内核探秘》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《文件系统技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">《存储技术原理分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">存储</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../12storage/ceph%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《ceph设计原理与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">视频</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/FFmpeg%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">《FFmpeg入门到精通》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">《WebRTC权威指南》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AE%9E%E6%97%B6%E4%BA%92%E5%8A%A8%E6%8A%80%E6%9C%AF/">《WebRTC音视频实时互动技术》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/%E6%96%B0%E4%B8%80%E4%BB%A3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%A0%81%E6%A0%87%E5%87%86-H.264_AVC/">《新一代视频压缩码标准-H.264_AVC》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">内核</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《Linux内核设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/">《深入Linux设备驱动程序内核机制》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">《深入理解Linux虚拟内存管理》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《深入理解Linux网络技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90-tcpip%E5%AE%9E%E7%8E%B0/">《Linux内核源代码剖析-TCP/IP实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/">《深入理解Linux内核》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">工具</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/">《Wireshark网络分析实战》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%283rd%29/">《Linux命令行与shell脚本编程大全(3rd)》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%883rd%EF%BC%89/">《python程序设计（3rd）》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/python/Python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/">《Python编程从入门到实践》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">刷题</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../../91leetcode/%E5%89%91%E6%8C%87offer2nd/">《剑指offer2nd》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../91leetcode/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/">《剑指offer专项突破》</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">OD基础题</a>
    <ul class="current">
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../OD%E8%BF%9B%E9%98%B6%E9%A2%98/">OD进阶题</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网课</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/01Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/">《Linux高并发网络编程开发》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/%E4%BE%AF%E6%8D%B7/%E4%BE%AF%E6%8D%B7C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8660%E8%AE%B2/">《侯捷C++内存管理60讲》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/11NJU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">《NJU算法设计与分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">英语专</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../60English/00794%E7%BB%BC%E5%90%88%E8%8B%B1%E8%AF%AD%E4%B8%80%E4%B8%8A/">《综合英语(一)上》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../95selfStudy/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/">《概率率与数理统计》</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">lionel的技术笔记</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>刷题 &raquo;</li>
      <li>OD基础题</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h2 id="_1">缘起<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<ul>
<li>刷题的链接，https://blog.csdn.net/goldarmour/article/details/129807099?spm=1001.2014.3001.5502</li>
<li>2023-10-28花时间整理了一下</li>
<li>感觉<strong>滑窗</strong>不难，但其实自己还不太难做得出来。</li>
</ul>
<h2 id="_2">内容<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<ul>
<li></li>
</ul>
<h3 id="_3">题量比较大的（滑窗、自定义排序、字符串、逻辑分析）<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<h4 id="_4">字符串<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h4>
<ul>
<li>03敏感字段加密<ul>
<li><em>好像并不能，case全过，要再check一下</em></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od03_impl(int k,string input) {
    string d = input;
    while (k) {
        size_t pos = d.find("_");
        k--;
        d = d.substr(pos+1, d.size());
    }
    //cout &lt;&lt; d &lt;&lt; endl;
    size_t pos = d.find("_");
    string replace = d.substr(0, pos);

    pos = input.find(replace);
    string first = input.substr(0, pos);
    string last = input.substr(pos + replace.size(), input.size());
    string res = first + "******" + last;
    cout &lt;&lt; res &lt;&lt; endl;
}
</code></pre>
<ul>
<li>07IPv4地址转换为整数</li>
</ul>
<pre class="highlight"><code class="language-cpp">string num2hex(int num) {
    std::ostringstream ss;
    if (num &gt;= 0 &amp;&amp; num &lt;= 255) {
        ss &lt;&lt; std::hex &lt;&lt;setw(2) &lt;&lt;setfill('0') &lt;&lt; num;//没有头文件iomainip，所以不能用setw
        //string tmp = ss.str();
    }
    return ss.str();
}

void od07_impl(string input) {
    vector&lt;int&gt; data;
    string res;
    int start = 0;
    for (int i = 0; i &lt; input.size(); i++) {
        if (input[i] == '#') {
            //cout &lt;&lt; start &lt;&lt;"," &lt;&lt; i &lt;&lt; endl;
            data.emplace_back(stoi(input.substr(start, i)));
            start = i+1;//lionel，这个地方写错了，应该是i+1是start，调试出来的
        }
    }
    data.emplace_back(stoi(input.substr(start, input.size())));
    for (auto i : data) {
        res += num2hex(i);
    }
    string newres("0x");
    newres += res;
    //cout &lt;&lt; newres &lt;&lt; endl;
    cout &lt;&lt; stoll(newres, NULL, 16) &lt;&lt; endl;//lionel，要stoll才行，stoi和stol都越界了
}</code></pre>
<ul>
<li>16最远足迹<ul>
<li><em>感觉是不是想复杂了啊</em></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">bool cmp16(pair&lt;int, int&gt; m1, pair&lt;int, int&gt; m2) {
    int sum1 = (m1.first - 0) * (m1.second - 0);
    int sum2 = (m2.first - 0) * (m2.second - 0);

    if (sum1 &gt; sum2) {
        return 1;
    }
    return 0;
}

void od16_impl(string input) {
    vector &lt;pair&lt;int, int&gt;&gt; res;
    //lionel，用啥去过滤，先找(，然后固定长度即可

    //查找所有的话，用while
    char flagL = '(';
    char flagR = ')';
    int pos = 0;
    int i=0;
    vector&lt;int&gt; left;
    while ((pos = input.find(flagL, pos)) != string::npos) {
        left.emplace_back(pos);
        pos++;
        i++;
    }

    vector&lt;int&gt; right;
    pos = 0;
    i = 0;
    while ((pos = input.find(flagR, pos)) != string::npos) {
        right.emplace_back(pos);
        pos++;
        i++;
    }

    vector&lt;string&gt; val;
    //lionel，这个风险就在左右如果不匹配怎么办？
    for (int i = 0; i &lt; right.size(); i++) {
        string tmp = input.substr(left[i] + 1, right[i] - left[i] - 1);
        val.emplace_back(tmp);
    }

    for (auto s : val) {
        auto pos = s.find(',');
        int left = stoi(s.substr(0, pos-0)); //substr的用法是啥，最后一个是长度
        int right = stoi(s.substr(pos+1, s.size()-pos-1));
        //cout &lt;&lt; left &lt;&lt; "," &lt;&lt; right &lt;&lt; endl;
        res.emplace_back(make_pair(left, right));
    }

    sort(res.begin(), res.end(), cmp16);

    //lionel，我觉得更简单的方式用栈即可
    cout &lt;&lt; res[0].first &lt;&lt; "," &lt;&lt; res[0].second &lt;&lt; endl;
}</code></pre>
<ul>
<li>17需要打开多少监控器<ul>
<li><em>这个自己不会</em>，最开始没啥思路，有点dfs的意思，但又没这么写，<em>这个学一下</em></li>
<li>参数为啥要多个(0,0)，<em>当然，这个是实现的区别，关键还在于思想</em></li>
<li><em>这个怎么算字符串的了</em>，也算了<strong>逻辑分析</strong>的，我更觉得是后者</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od17_impl(vector&lt;vector&lt;int&gt;&gt; input, int m, int n) {
    vector&lt;vector&lt;int&gt;&gt; park(m + 2, vector&lt;int&gt;(n + 2, 0));
    for (int i = 1; i &lt;= m; i++) {
        for (int j = 1; j &lt;= n; j++) {
            park[i][j] = input[i - 1][j - 1];
        }
    }

    int dx[5] = { -1,0,1,0,0 };
    int dy[5] = { 0,-1,0,1,0 };//lionel，为啥是5呢？

    for (int i = 1; i &lt;m; i++) {
        for (int j = 1; j &lt;n; j++) {
            if (park[i][j] == 1) {
                for (int k = 0; k &lt; 5; k++) {
                    int nx = i + dx[k];
                    int ny = j + dy[k];

                    if (nx &gt;= 1 &amp;&amp; nx &lt;= m &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= n) {
                        park[nx][ny] = 1;
                    }
                }
            }
        }
    }

    int res = 0;
    for (int i = 1; i &lt;=m; i++) { //lionl，啥时候要等于，啥时候要不等于，这是个问题，要看下
        for (int j = 1; j &lt;= n; j++) {
            if (park[i][j] == 1)
                res++;
        }
    }

    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<ul>
<li>19求字符串中所有整数的最小和<ul>
<li>感觉最开始也没做出来，<em>最后也没debug出来啊</em>，最后sum前面的if里面，没写内容。</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">//bb1234aa,输出1+2+3+4=10
void od19_impl(string val) {
    int sum = 0;
    int first = 0, last = 0;
    bool minFlag = false;
    for (int i = 0; i &lt; val.size(); i++) {
        if (val[i] == '+') {
            break;
        }
        if (val[i] == '-') {
            minFlag = true;
            first = i;
        }
        if (isdigit(val[i])) {
            if()
            sum += (val[i] - '0');
        }
    }
    cout &lt;&lt; sum &lt;&lt; endl;
}</code></pre>
<ul>
<li>21TLV解析<ul>
<li>我没做出来，<em>还得再学下</em>，<strong>核心是，定义了一个<code>map&lt;int, vector&lt;int&gt;&gt; tagOffset;</code>结构体</strong></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od21() {
    string s = "0F04ABABABAB";
    //getline(cin, s);
    int n = 1;
    int tag = 15;
    //int n=2,tag就有2个值，15，17

    //lionel，不会，用map来记录需要匹配的tag和其解析后的[起始点，结束点]
    map&lt;int, vector&lt;int&gt;&gt; tagOffset;
    for (int i = 0; i &lt; n; i++) {
        vector&lt;int&gt; tmp = { 0,0 };
        tagOffset[tag] = tmp;
    }

    int bound = s.size();
    int left = 0;
    int right = 2;
    int offset = 2;
    while (left &lt; bound) {  //lionel,这个地方，作者写的是left&lt;=bound，我改成了left&lt;bound
        //一开始匹配的就是tag
        //https://blog.csdn.net/ma_minmin/article/details/126908825  [stoi(tmp,0,16)]
        string tmp = s.substr(left, right);//https://blog.csdn.net/zjl2222/article/details/112135497  [C++的16进制，转在10进制]
        int tag = stoi(tmp,0,16);  //lionel，get到了这个

        int length = stoi(s.substr(left + 2, right + 2));

        //判断tag是否匹配
        if (tagOffset.find(tag) != tagOffset.end() &amp;&amp; ((offset + length) * 2 &lt;= bound)) {  //lionel，这个地方，作者写的是&lt;bound，我改成&lt;=了
            tagOffset[tag] = { length,offset };
        }

        //根据长度来更新偏移量
        offset = offset + length + 2;
        left += (length * 2) + 4;
        right += (length * 2) + 4;
    }

    for (auto c : tagOffset) {
        cout &lt;&lt; c.second[0] &lt;&lt; " " &lt;&lt; c.second[1] &lt;&lt; endl;
    }
}</code></pre>
<ul>
<li>22拼接URL<ul>
<li>输入<code>string input1 = "acm,/bb";</code>，输出<code>/acm/bb</code></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">//用,分割
string check(string value) {
    string str;
    if (value[0] != '/')
        str = "/" + value;
    if (value[value.size()] == '/' &amp;&amp; value[value.size() - 1] == '/')
        str = value.substr(0, value.size() - 1);

    if (value[value.size()] == '/') {
        str = value.substr(0, value.size() - 1);
    }

    if (str.size()&gt;0) {
        return str;
    }
    return value;
}

void od22_impl(string input) {
    size_t pos = input.find(",");
    if (pos != input.npos) {
        string first = input.substr(0, pos);
        string last = input.substr(pos+1, input.size());
        string a = check(first);
        string b = check(last);
        string tmp = check(first) + check(last);
        cout &lt;&lt; tmp &lt;&lt; endl;
    }
}</code></pre>
<ul>
<li>42寻找相同子串<ul>
<li>直接用<code>find</code>或<code>find_first_of()</code>是不是不行？</li>
<li><strong>扩展学一下KMP吧</strong></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od42_impl(string source, string target) {
    //auto res = find_first_of(source.begin(), source.end(), target.begin(), target.end());  //lionel，用法不对
    cout &lt;&lt; source.find_first_of(target) + 1 &lt;&lt; endl;  //lionel，这个地方要加1吗？
    //cout &lt;&lt; *res &lt;&lt; endl;
}</code></pre>
<ul>
<li>44报文重排序<ul>
<li>自己当时2个思路，用vector存结构体，用map</li>
<li><strong>把字符串拆成字符串和数字</strong>（用的正则，其实可以string从后往前）</li>
<li>当时想的是<code>map()</code>是不是就默认按key排序，自己定义的<code>cmp</code>，其实还没有用上<ul>
<li><strong>C++中map的默认排序，就是从小到大</strong>，https://www.zhihu.com/question/518791037，<em>当然也可以自己指定</em></li>
<li><code>map&lt;string, int, cmp&gt; strInt;</code>可以这样定义</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">//rolling3 stone4 like1 a2  输出:like a rolling stone
struct cmp {
    bool operator()(const int &amp;num1, const int &amp;num2) const {  //lionel，这个都需要const，不管是参数，还是 函数，都要是const  【这个还是会报错，const _Tky转成const int】
        return num1 &gt; num2;
    }
};

void od44_impl(int num, vector&lt;string&gt;input) {
    //map&lt;string, int, cmp&gt; strInt;  //我写成这样，当然也是可以的
    map&lt;int,string&gt; intStr;//lionel，相当于自定义了一个排序规则
    for (auto c : input) {
        string s1 = c;
        string s2 = c;
        regex reg1 ("[0-9]") ;
        regex reg2("[a-zA-Z]") ;
        string value = regex_replace(s1, reg1, "");
        string num = regex_replace(s2, reg2, "");
        //cout &lt;&lt; value &lt;&lt; "," &lt;&lt; num &lt;&lt; endl;
        //strInt.insert(make_pair(value, stoi(num)));
        intStr.insert(make_pair(stoi(num), value));
    }

    string res;
    //for (auto c : strInt) {
    for (auto c : intStr) {
        res += c.second;
        res += " ";
    }
    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<ul>
<li>59最长公共后缀</li>
<li>66计算最大乘积<ul>
<li>目前是逐个比较，用的是2层for循环</li>
<li><em>但应该还有更好的方法</em>，比如看到了用<code>set()</code>，但我没看懂</li>
<li><em>lionel，判断，集合没有交集，两个子字符串没有重复元素</em></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">int mul(string s1, string s2) {
    for (int i = 0; i &lt; s1.size(); i++) {
        for (int j = 0; j &lt; s2.size(); j++) {
            if (s1[i] == s2[j]) {
                return 0;
            }
        }
    }
    return s1.size() * s2.size();
}

void od66_impl(vector&lt;string&gt; inputs) {
    int res=0;
    for (int i = 0; i &lt; inputs.size() - 1; i++) {
        res = max(res, mul(inputs[i], inputs[i + 1]));
    }
    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<ul>
<li>73按单词下标区间翻转文章内容<ul>
<li>最开始不需要用正则，转化为acm模式下的输入输出即可</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">//string inputs1{ "I am a developer" };,start1是1和2
void od73_impl(string input, int start, int end) {
    regex ws_re("\\s+");//lionel，不是太明白这个正则
    vector&lt;string&gt; res_helper(sregex_token_iterator(input.begin(), input.end(), ws_re, -1), sregex_token_iterator());

    while(start&lt;end){
        swap(res_helper[start], res_helper[end]);
        start++;
        end--;
    }

    string res;
    for (auto val : res_helper) {
        res += val;
        res += " ";
    }
    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<ul>
<li>84关联子串<ul>
<li><em>这个题，不太会啊</em>【也是抄的】</li>
<li><em>看用到了回溯算法，但解题没用这种</em></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">//input： abc; efghicbaiii  Ouput：5  【相当于abc的全排列，然后找位置？】
void od84_impl(string s1, string s2) {
    //求s1的全排列,使用next_permutation
    vector&lt;char&gt; res_helper;
    vector&lt;char&gt; res;
    vector&lt;vector&lt;char&gt;&gt; resout;
    res_helper.assign(s1.begin(), s1.end());
    sort(res_helper.begin(), res_helper.end());
    do {
        for (int i = 0; i &lt; res_helper.size(); i++) {
            //cout &lt;&lt; res_helper[i];
            res.emplace_back(res_helper[i]);
        }

    } while (next_permutation(res_helper.begin(), res_helper.end()));
    resout.emplace_back(res);

    vector&lt;string&gt; sVect;
    for (auto h : resout) {
        string s{ h.begin(), h.end() };
        for (int i = 0; i &lt; s.size(); i+=3) {
            sVect.emplace_back(s.substr(i, 3)); //lionel,substr的用法，还是不熟啊
        }
    }

    for (auto c : sVect) {
        //cout &lt;&lt; c &lt;&lt; endl;
        auto pos = s2.find(c);
        if (pos != s2.npos) {
            cout &lt;&lt; pos &lt;&lt; endl;
        }
        //auto it = find(s2.begin(), s2.end(), c);//lionel，太习惯用find算法后，不太会用string里面的find了
        //if (it != s2.end())
            //cout &lt;&lt; *it &lt;&lt; endl;
    }
}</code></pre>
<ul>
<li>88一种字符串压缩表示的解压<ul>
<li><em>不一定是最优的</em></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">//In:4dff，Out： ddddff
void od88_impl(string input) {
    vector&lt;char&gt; res;
    for (int i = 0; i &lt; input.size(); i++) {
        if (isdigit(input[i])) {
            if (input[i] - '0' &lt;= 2) {
                //cout &lt;&lt; input[i] - '0' &lt;&lt; endl;
                cout &lt;&lt; "!error" &lt;&lt; endl;
                break;
            } else {
                int num = input[i] - '0';
                while (num-1 &gt; 0) {
                    res.push_back(input[i + 1]);
                    num--;
                }
            }
        }else if (isalpha(input[i])) {
            res.push_back(input[i]);
        } else {
            cout &lt;&lt; "!error" &lt;&lt; endl;
            break;
        }
    }

    //cout &lt;&lt; res &lt;&lt; endl;
    string str(res.begin(), res.end()); //https://blog.csdn.net/liuzehn/article/details/107606163  把vector&lt;char&gt;转成string
    cout &lt;&lt; str &lt;&lt; endl;  //lionel，写了还不够健壮，但意思到了
}</code></pre>
<ul>
<li>90单词重量</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od90_impl(string input) {
    //https://zhuanlan.zhihu.com/p/426939341  正则，我是没想到的，字符串split，用find的话，要不断循环
    std::string s;
    char delim = ' ';
    s.append(1, delim);
    std::regex reg(s);
    std::vector&lt;std::string&gt; elems(std::sregex_token_iterator(input.begin(), input.end(), reg, -1),
        std::sregex_token_iterator());

    vector&lt;int&gt; res;
    for (auto c : elems) {
        res.emplace_back(c.size());
    }

    int sum = 0.0;
    sum = accumulate(res.begin(), res.end(), sum);
    cout &lt;&lt; fixed&lt;&lt;setprecision(2)&lt;&lt;(sum*1.0) / res.size() &lt;&lt; endl; //https://blog.csdn.net/abilix_tony/article/details/106956204  lionel，2个处问题，setprecison(2)和fixed不太熟悉
}</code></pre>
<h4 id="undo-2">字符串（undo-2）<a class="headerlink" href="#undo-2" title="Permanent link">&para;</a></h4>
<ul>
<li>69响应报文时间</li>
<li>87相对开音节</li>
<li>93</li>
</ul>
<h4 id="_5">自定义排序<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h4>
<ul>
<li>09组成最大数<ul>
<li><strong>难点，在于组成最大数的规则</strong>，《剑指offer》上有这个理论<ul>
<li>换成string后，s1+s2，s2+s1进行比较即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">bool cmp(int n1, int n2) {   // lionel，这个比较规则，是我没有想到的 
    string s1 = to_string(n1);
    string s2 = to_string(n2);

    string tmp1 = s1 + s2;
    string tmp2 = s2 + s1;
    if (tmp1 &lt; tmp2) {
        return 0;
    }

    return 1;
}

//In：4589,101,41425,9999
//Out:9999 4589 41425 101
void od09_impl(vector&lt;int&gt; inputs) {
    sort(inputs.begin(), inputs.end(), cmp);
    string s;
    for (auto c : inputs) {
        s += to_string(c);
    }
    cout &lt;&lt; stoll(s) &lt;&lt; endl; //lionel，是不是要考虑个越界的问题？
}</code></pre>
<ul>
<li>13选修课<ul>
<li><em>自己感觉也没弄明白</em></li>
<li>属于<strong>栈</strong>，但我没用这个思想</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">bool cmp13(string s1, string s2) {
    //http://c.biancheng.net/view/1447.html compare函数
    int m = s1.compare(0, 5, s2, 0, 5);
    if (m &gt; 1)
        return 1;
    else {
        // m==0，班级名称一样
        return 0;
    }

}

void od13_impl(vector&lt;pair&lt;string, int&gt;&gt; input1, vector&lt;pair&lt;string, int&gt;&gt; input2) {
    vector&lt;string&gt; res;
    //同时选修了2门，就是在1，和2都有一样的学号
    for (int i = 0; i &lt; input1.size(); i++) {
        //cout &lt;&lt; input1[i].first &lt;&lt; endl;
        for (int j = 0; j &lt; input2.size(); j++) {
            if (input1[i].first == input2[j].first) {
                //cout &lt;&lt; input1[i].first &lt;&lt; endl;
                res.emplace_back(input1[i].first);
            }
        }
    }
    sort(res.begin(), res.end(), cmp13);

    for (int i = 0; i &lt; res.size()-1; i++) {
        if (res[i].compare(0, 5, res[i + 1], 0, 5) == 0) {
            cout &lt;&lt; res[i].substr(0, 5) &lt;&lt; endl;
            cout &lt;&lt; res[i] &lt;&lt;"," &lt;&lt; res[i + 1] &lt;&lt; endl;
        } else {
            cout &lt;&lt; res[i].substr(0, 5)&lt;&lt;endl;
            cout &lt;&lt; res[i] &lt;&lt; endl;
        }
    }
}</code></pre>
<ul>
<li>28按身高和体重排队<ul>
<li><strong>核心是，定义结构体，【同时加上index字段】</strong>，中间的<code>equal()</code>函数没啥用吧</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">typedef struct person {
    int index;  //lionel，自定义排序，核心还是加个索引
    int height;
    int weight;
}Person;

bool comp(Person p1, Person p2) {
    if (p1.height &lt; p2.height) {
        return 1;
    } else if (p1.height == p2.height &amp;&amp; p1.weight &lt; p2.weight) {
        return 1;
    }
    return 0;
}

bool equal(Person p1, Person p2) {
    if (p1.height == p2.height &amp;&amp; p1.weight == p2.weight) {
        return 1;
    }
    return 0;
}

void od28() {
    //把输入的2行当成结构体好了
    Person p[4] = { {1,100,40},{2,100,30},{3,120,60},{4,130,50} };
    vector&lt;Person&gt; vp;
    vp.emplace_back(p[0]);
    vp.emplace_back(p[1]);
    vp.emplace_back(p[2]);
    vp.emplace_back(p[3]);
    vector&lt;Person&gt; old_vp{ vp };
    vector&lt;int&gt; num;

    sort(vp.begin(), vp.end(),comp);  //lionel，问题是，如何输出序号？

    for (auto c : vp) {
        cout &lt;&lt; c.index &lt;&lt; endl;
    }
}</code></pre>
<ul>
<li>32寻找身高相近的小朋友<ul>
<li>当时写的思考是，<em>用map存与vector存，有啥区别？</em></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">int g_height = 0;
bool cmp32(pair&lt;int, int&gt; m1, pair&lt;int, int&gt; m2) {
    int diff1 = m1.second - g_height;
    int diff2 = m2.second - g_height;
    if (abs(diff1) &lt; abs(diff2)) {
        return 1;
    } else if (abs(diff1) == abs(diff2)) {
        if (m1.first &lt; m2.first)
            return 1;
    }
    return 0;
}

void od32_impl(int height, int count, vector&lt;int&gt; inputs) {
    g_height = height;
    vector&lt;pair&lt;int, int&gt;&gt; res;
    for (int i = 0; i &lt; count; i++) {
        res.emplace_back(make_pair(i, inputs[i]));
    }

    sort(res.begin(), res.end(), cmp32);

    for (auto c : res) {
        cout &lt;&lt; c.second &lt;&lt; endl;
    }
}</code></pre>
<ul>
<li>34数组组成的最小数字<ul>
<li><strong>核心是全排列算法</strong></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">bool cmp(int i1, int i2) {//如果lambda的话，我不知道sort里面的参数是啥  ,【排序是对的，排出来的是，5，21，30，然后组合】
    //cout &lt;&lt; i1 &lt;&lt; "input," &lt;&lt; i2&lt;&lt;endl;
    string s1 = to_string(i1);
    string s2 = to_string(i2);
    if (s1.size() &lt; s2.size()) {
        return 1;
    } else if (s1.size() == s2.size()) {
        for (int i = 0; i &lt; s1.size(); i++) {
            //cout &lt;&lt; s1[i] &lt;&lt; "," &lt;&lt; s2[i] &lt;&lt; endl;
            if (s1[i] &lt; s2[i]) {
                return 1;
            } else
            {
                return 0;
            }
        }
    }
    return 0;
}

void od34_impl(vector&lt;int&gt; inputs) {
    while(inputs.size() &lt; 3) {
        inputs.emplace_back(0);
    }
    sort(inputs.begin(), inputs.end(), cmp);  //lionel，sort的用法
    //for (auto c : inputs) {
    //  cout &lt;&lt; c &lt;&lt; endl;
    //}
    string s1 = to_string(inputs[0]);
    string s2 = to_string(inputs[1]);
    string s3 = to_string(inputs[2]);

    //回到另外的问题上，3个string，如果全排列
    vector&lt;string&gt; v1{ s1,s2,s3 };
    sort(v1.begin(), v1.end());
    vector&lt;string&gt;v2;
    do {
        //cout &lt;&lt; v1 &lt;&lt; endl;
        v2.push_back(v1[0] + v1[1] + v1[2]);
    } while (next_permutation(v1.begin(), v1.end()));


    cout &lt;&lt; stoi(v2[0]) &lt;&lt; endl;
}</code></pre>
<ul>
<li>36数组去重和排序<ul>
<li><strong>重复文件如何插入map</strong><ul>
<li>1、用pair类型，<code>map.insert(make_pair(1,1));map.insert(make_pair(1,2));</code></li>
<li>2、用下标，<code>map[1]=2;map[1]=3;</code></li>
</ul>
</li>
<li>pair的头文件是<code>#include&lt;utility&gt;</code></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">bool cmp36(pair&lt;int, pair&lt;int, int&gt;&gt; m1, pair&lt;int, pair&lt;int, int&gt;&gt; m2) {
    if (m1.second.second &gt; m2.second.second)
        return 1;
    else if (m1.second.second == m2.second.second) {
        if (m2.first &gt; m1.first)
            return 1;
    }
    return 0;
}


void od36_impl(vector&lt;int&gt; inputs) {
    unordered_map&lt;int, int&gt; val;  //因为存的时候，数据顺序变掉了，把map改成了unordered_map，lionel
    for (int i = 0; i &lt; inputs.size(); i++)
        val[inputs[i]]++;

    vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; res1;  //lionel，用双层给解决了一下

    vector&lt;pair&lt;int, int&gt;&gt; res{ val.begin(),val.end() };  //lionel，当时不知道不知道map里面是不能自定义排序的，要用vector去保存一下
    for (int i = 0; i &lt; val.size(); i++) {
        //int i = val[i].second();
        pair&lt;int, int&gt; tmp = res[i];
        pair&lt;int, pair&lt;int, int&gt;&gt; tmp2 = make_pair(i, tmp);
        //res1[i] = tmp;
        //res1.insert(i, tmp);
        res1.emplace_back(tmp2);
    }

    sort(res1.begin(), res1.end(),cmp36);
    for (auto c : res1) {
        cout &lt;&lt; c.second.first &lt;&lt; endl;
    }
}
</code></pre>
<ul>
<li>47字符串摘要<ul>
<li><em>自己不太会，估计也是抄的</em>，题也没全部做完，<em>连续的怎么办？</em></li>
<li>算的是<strong>字符串、滑窗</strong>的两类</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">bool cmp47(pair&lt;char, int&gt; m1, pair&lt;char, int&gt; m2) {
    if (m1.second &gt; m2.second)
        return 1;
    return 0;
}

//aabbcc，输出a2b2c2
void od47_impl(string input) {
    unordered_map&lt;char, int&gt; res_helper;
    for (int i = 0; i &lt; input.size(); i++) {
        //lionel，这个要连续的，所以需要滑动窗口，这个没写，包括大小写算连续，非字符要break掉
        res_helper[input[i]]++;
    }

    vector&lt;pair&lt;char, int&gt;&gt; res{ res_helper.begin(),res_helper.end() };
    sort(res.begin(), res.end(),cmp47);

    string result;
    for (auto c : res) {
        //result.push_back(c.first);
        result += c.first;
        result += to_string(c.second);
    }
    cout &lt;&lt; result&lt;&lt;endl;
}</code></pre>
<ul>
<li>55拔河比赛<ul>
<li><strong>核心在于，定义一个结构体</strong></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">typedef struct person {
    int heigth;
    int weight;
}Person;

bool cmp(Person p1, Person p2) {
    if (p1.heigth &gt; p2.heigth) {
        return 1;
    } else if (p1.heigth == p2.heigth) {
        if (p1.weight &gt; p2.weight) {
            return 1;
        }
    }

    return 0;
}
void od55_impl(vector&lt;vector&lt;int&gt;&gt; inputs) {
    vector&lt;Person&gt; res;
    for (auto c : inputs) {
        Person tmp;
        tmp.heigth = c[0];
        tmp.weight = c[1];
        res.push_back(tmp);
    }
    sort(res.begin(), res.end(), cmp);

    for (int i = 0; i &lt; 10; i++) {
        cout &lt;&lt; res[i].heigth &lt;&lt; "," &lt;&lt; res[i].weight &lt;&lt; endl;
    }
}</code></pre>
<ul>
<li>60支持优先级的队列<ul>
<li><strong>结构体中增加一个index下标</strong>，用for的时候去把i的值赋值给它即可</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">typedef struct que {
    int index;
    int value;
    int weight;
}Que;

bool cmp(Que q1, Que q2) {
    if (q2.weight &gt; q1.weight) {
        return 0;
    } else if (q2.weight == q1.weight) {
        if (q2.index &lt; q1.index)
            return 0;
    }
    return 1;
}

void od60_impl() {
    //lionel，我是没想好，怎么处理输入  【2023-10-28,for的时候，用i赋值给index】
    vector&lt;Que&gt; v1{ {1, 10, 1}, { 2,20,1 }, { 3,30,2 }, { 4,40,3 }};  //输出40，30，10，20
    sort(v1.begin(), v1.end(), cmp);

    for (auto c : v1) {
        cout &lt;&lt; c.value &lt;&lt; endl; 
    }
}</code></pre>
<ul>
<li>77奖牌排行榜<ul>
<li>用结构体，用<strong>字符串的compare方法</strong></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">struct prize {
    string nation;
    int gold;
    int silver;
    int bronze;
};

bool cmp77(struct prize p1, struct prize p2) {
    if (p1.gold &gt; p2.gold) {
        return 1;
    } else if (p1.gold == p2.gold &amp;&amp; p1.silver &gt; p2.silver) {
        return 1;
    } else if (p1.silver == p2.silver &amp;&amp; p1.bronze &gt; p2.bronze) {
        return 1;
    } else if (p1.bronze == p2.bronze) {
        if (p1.nation.compare(p2.nation) &gt; 1)
            return 1;
    }
    //lionel,第一遍（0912）写的时候，cmp写的有问题，这时用结构体存的，我0922再写的时候，想到可以用vector&lt;pair&lt;string,vector&lt;int&gt;&gt;&gt;这样的形式，

    return 0;
}

void od77_impl(int n, vector&lt;prize&gt; input) {
    sort(input.begin(), input.end(), cmp77);
    for (int i = 0; i &lt; 3; i++) {
        cout &lt;&lt; input[i].nation &lt;&lt; endl;
    }
}</code></pre>
<ul>
<li>79数字最低位排序<ul>
<li>多了一个函数，计算<strong>最低位</strong>，要再看一下</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">int lowbit(int num) {
    num = abs(num);  //lionel，最开始用了abs(num)，没用num去接
    string tmp = to_string(num);
    int len = tmp.size();
    while (num &gt; 10) {
        int val = pow(10, len - 1);
        len--;
        num -= (num / val) * val;
    }
    return num;
}

bool cmp79(pair&lt;int, int&gt; m1, pair&lt;int, int&gt; m2) {
    //取最低位
    int num1 = lowbit(m1.second);
    int num2 = lowbit(m2.second);
    //cout &lt;&lt; num1 &lt;&lt; "," &lt;&lt; num2 &lt;&lt; endl;
    if (num1 &lt; num2) {
        return 1;
    } else if (num1 == num2) {
        if (m1.first &gt; m2.first) {
            return 0;
        } else
            return 1;
    }
    return 0;
}

void od79_impl(vector&lt;int&gt; input) {
    vector&lt;pair&lt;int, int&gt;&gt; res;
    for (int i = 0; i &lt; input.size(); i++) {
        res.emplace_back(make_pair(i, input[i]));
    }

    sort(res.begin(), res.end(), cmp79);

    for (auto c : res) {
        cout &lt;&lt; c.second &lt;&lt; endl;
    }
}</code></pre>
<ul>
<li>86统计射击成绩<ul>
<li><em>也不太确定，最终有没有做出来了</em></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">bool cmp86(pair&lt;int, int&gt; m1, pair&lt;int, int&gt; m2) {
    if (m1.second &gt; m2.second)
        return 1;
    else if (m1.second == m2.second &amp;&amp; m1.first&gt;m2.first) {
        return 1;
    }
    return 0;
}

void od86_impl(int count, vector&lt;int&gt; player, vector&lt;int&gt; score) {
    vector&lt;pair&lt;int, int&gt;&gt;res_helper;
    for (int i = 0; i &lt; count; i++) {
        res_helper.emplace_back(make_pair(player[i], score[i]));
    }

    //先统计次数
    map&lt;int, int&gt; res_map;
    for (auto c : player) {
        res_map[c]++;
    }

    vector&lt;pair&lt;int, int&gt;&gt; res;
    vector&lt;pair&lt;int, int&gt;&gt; res_vector(res_map.begin(), res_map.end());
    for (auto c : res_vector) {
        if (c.second &lt; 3) {
            //res_vector.erase(c.first);
            cout &lt;&lt; c.first &lt;&lt; endl;  //lionel，如何取消，这个地方应该遗留了一点
        }

        int sum = 0;
        int val = c.first;
        vector&lt;int&gt; top3;
        for (int i = 0; i &lt; res_helper.size(); i++) {
            if (val == res_helper[i].first) {
                //sum += res_helper[i].second;
                top3.emplace_back(res_helper[i].second);
            }
        }
        sort(top3.begin(), top3.end());
        int len = top3.size();
        sum += top3[len - 1];
        sum += top3[len - 2];
        sum += top3[len - 3];  //lionel，第一次忘记算3的成绩了
        res.emplace_back(make_pair(val, sum));
    }

    sort(res.begin(), res.end(),cmp86);

    for (auto c : res) {
        cout &lt;&lt; c.first &lt;&lt; endl;
    }
}</code></pre>
<h4 id="undo-1">自定义排序（undo-1）<a class="headerlink" href="#undo-1" title="Permanent link">&para;</a></h4>
<ul>
<li>74比赛</li>
</ul>
<h4 id="_6">滑窗、单双指针<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h4>
<ul>
<li>20求满足条件的最长子串长度<ul>
<li><em>这也是抄的，其实没弄懂</em></li>
<li>大概猜了一下，<strong>用滑动窗口，找到值，然后check一下，符合条件的，求出size，更新上去</strong></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">//只含(a-z,A-Z)，其它是数字，  abC124ACb，输出是4（abC1,4Acb）
bool check(string str) {
    regex r("[0-9]");
    string replace = regex_replace(str,r, "");
    //cout &lt;&lt; str &lt;&lt; "," &lt;&lt; replace &lt;&lt; endl;
    /*
    *
    ab, ab 
    bC1, bC
    C124, C
С124A, СА
124ACb, ACb
24ACb, ACb
4ACb, ACb 
ACb, ACb
    */
    return replace.size() != str.size() &amp;&amp; replace.size() &lt;= 1; //lionel，这个也没懂
}

void od20_impl(string input) {
    int left = 0, right = 1;
    int res = -1;
    while (left &lt; input.size() &amp;&amp; right &lt; input.size()) {
        right++;
        string subStr = input.substr(left, right); //lionel，求这个啥意思
        //cout &lt;&lt; subStr &lt;&lt; endl;
        if (check(subStr)) {
            res = max(res, (int)subStr.size());
        } else {
            left++;
        }
    }
    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<ul>
<li>40滑动窗口最大和<ul>
<li>每次的窗口是k</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od40_impl(vector&lt;int&gt; inputs, int k) {
    int res = 0;
    int first = 0, last = first + k;
    while (first &lt; last) {
        if (last &gt; inputs.size()) {
            break;
        }

        int sum = 0;
        sum = accumulate(inputs.begin() + first, inputs.begin() + last, sum);
        res = max(res, sum);
        first++; //lionel，会忘记这个++
        last++;
    }
    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<ul>
<li>45阿里巴巴找宝箱V<ul>
<li><em>跟40题是一样的？</em></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od45_impl(vector&lt;int&gt; inputs, int k) {
    int res = 0;
    int first = 0, last = first + k;
    while (first &lt; last) {
        if (last &gt; inputs.size()) {
            break;
        }

        int sum = 0;
        sum = accumulate(inputs.begin() + first, inputs.begin() + last, sum);
        res = max(res, sum);
        first++; //lionel，会忘记这个++
        last++;
    }
    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<ul>
<li>这4道是单双指针</li>
<li>04阿里巴巴找黄金宝箱I</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od04_impl(vector&lt;int&gt; nums) {
    for (int i = 0; i &lt; nums.size(); i++) {
        int first = accumulate(nums.begin(), nums.begin() + i,0);
        int last = accumulate(nums.begin()+i+1, nums.end(), 0);
        //cout &lt;&lt; first &lt;&lt; "," &lt;&lt; last &lt;&lt; endl;
        if (first == last) {
            cout &lt;&lt; i &lt;&lt; endl;
        }
    }
    //不然，返回-1
}</code></pre>
<ul>
<li>10最大花费金额<ul>
<li><strong>类似于3数之和</strong>（第一层for，然后再用2数之和的方式）</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od10_impl(vector&lt;int&gt; input, int target) {
    //09-12重新想了一下，类似于three sum的写法
    vector&lt;int&gt;res;
    sort(input.begin(), input.end());
    for (int i = 0; i &lt; input.size(); i++) {
        int first = i + 1;
        int last = input.size() - 1;

        target -= input[i];

        while (first &lt; last) {
            if (input[first] + input[last] &lt; target) {
                res.emplace_back(input[first] + input[last] + input[i]);
                first++;//lionel，这个顺序写错了，应该先emplace_back，然后再first++;
            } else {
                last--; 
            }
        }
    }

    sort(res.begin(), res.end());
    for (auto c : res) {
        cout &lt;&lt; c &lt;&lt; " ";
    }
    cout &lt;&lt; res[res.size()-1] &lt;&lt; endl;
}</code></pre>
<ul>
<li>11太阳能面板最大面积<ul>
<li>有2个点<ul>
<li>1是<strong>哪个值小，移左，还是右</strong></li>
<li>2是<strong>每次去max一下（res,area）</strong></li>
</ul>
</li>
<li>LC84柱状图中的最大矩形</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od11_impl(vector&lt;int&gt; input) {
    int res = 0;
    int first = 0, last = input.size() - 1;
    while (first &lt; last) {
        //lionel，怎么移呢，【琢磨出来了，哪个短，哪个移
        int tmp = min(input[first], input[last]);
        //cout &lt;&lt; tmp &lt;&lt; endl;
        if (tmp == input[first]) {
            first++;
        }
        if (tmp == input[last]) {
            last--;
        }
        int area = (last - first + 1) * tmp; //lionel，这个地方是不是得能+1才行
        res = max(res, area);
    }
    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<ul>
<li>35求最多可派出多少支团队<ul>
<li>排序，大于能力的可以组队，最多2个人一组，2个之和大于能力也算一支</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od35_impl(int sum, vector&lt;int&gt; input, int ability) {
    sort(input.begin(), input.end());
    int left = 0, right = input.size() - 1;
    int res = 0;
    while (left &lt; right) {
        if (input[right] &gt;= ability) {
            res++;
            right--;
        } else {
            if (input[right] + input[left] &gt;= ability) {
                res++;
                right--;
                left++;
            } else
            {
                left++;
            }
        }
    }
    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<ul>
<li>下面这3道，只是没写</li>
<li>81</li>
<li>82</li>
<li>91</li>
</ul>
<h4 id="undo-4">滑窗、单双指针（undo-4）<a class="headerlink" href="#undo-4" title="Permanent link">&para;</a></h4>
<ul>
<li>41</li>
<li>46</li>
<li>51</li>
<li>56</li>
</ul>
<h4 id="_7">逻辑分析<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h4>
<h5 id="27">动规：27<a class="headerlink" href="#27" title="Permanent link">&para;</a></h5>
<h5 id="54">回溯：54<a class="headerlink" href="#54" title="Permanent link">&para;</a></h5>
<h5 id="76">栈：76<a class="headerlink" href="#76" title="Permanent link">&para;</a></h5>
<ul>
<li>06斗地主之顺子<ul>
<li>确实是逻辑题，但<strong>难点在于，至少5张怎么判断</strong>，用了一个<code>vector.back()</code></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">int Str2Int(string val) {
    if (val == "J")
        return 11;
    else if (val == "Q")
        return 12;
    else if (val == "K")
        return 13;
    else if (val == "A")
        return 14;
    else
        return stoi(val);
}

string Int2Str(int num) {
    switch (num){
    case 11:
        return "J";
    case 12:
        return "Q";
    case 13:
        return "K";
    case 14:
        return "A";
    default:
        return to_string(num);
    }
}

void od06() {
    vector&lt;int&gt; nums;
    vector&lt;string&gt; inputs{ "2","9","J","10","3","4","K","A","7","Q","A","5","6" };
    for (auto c : inputs) {
        int val = Str2Int(c);
        if (val &gt; 2) {
            nums.push_back(val);
        }
    }

    sort(nums.begin(), nums.end());

    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; path;
    while (nums.size() &gt;= 5) {
        path.push_back(nums[0]);
        nums.erase(nums.begin());

        for (int i = 0; i &lt; nums.size(); i++) {
            if (nums[i] == path.back()) {  //lionel，这个没懂
                continue;
            }

            //lionel，我就这个地方没懂，根因是啥？
            if (nums[i] == path.back() + 1) {  //lionel，还是用了这个规则，back()，我也是搜的
                path.push_back(nums[i]);
                nums.erase(nums.begin() + i);
                i--; //i--是表示nums[i]的下标
            }
        }

        //表示一轮结束，存一下
        if (path.size() &gt;= 5) {
            res.push_back(path);
        }
        path.clear();
    }

    if (res.empty()) {
        cout &lt;&lt; "No" &lt;&lt; endl;
        return;
    }

    sort(res.begin(), res.end());
    for (int i = 0; i &lt; res.size(); i++) {
        for (auto c : res[i]) {
            string val = Int2Str(c);
            cout &lt;&lt; val &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }

}</code></pre>
<ul>
<li>12坐位调整<ul>
<li><em>自己不会</em>，也可以归为<strong>滑窗问题</strong></li>
<li>LC605种花问题</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od12_impl(vector&lt;int&gt; input) {
    int res = 0;
    int len = input.size();
    int prev = -1;
    for (int i = 0; i &lt; len; i++) {
        if (input[i] == 1) {
            if (prev &lt; 0) {
                res += i / 2;
            } else {
                res += (i - prev - 2) / 2;//lionel，没懂啥意思
            }
            prev = i; //lionel，为啥是放在里面？
        }
    }

    if (prev &lt; 0) {
        res += (len + 1) / 2;
    } else {
        res += (len - prev + 1) / 2;
    }

    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<ul>
<li>27猴子爬山（done）</li>
<li>37快递运输<ul>
<li><em>没有全部AC</em></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od37_impl(vector&lt;int&gt; input, int target) {
    sort(input.begin(), input.end());
    int first = 0, last = first + 1;
    int sum = 0;
    sum += input[first];
    int res = 0;
    while (first &lt; last) {
        if (sum &gt;= target) {
            res = (last - first)-1;
            break;
        }

        sum += input[last];
        last++;
    }
    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<ul>
<li>38停车场车辆统计<ul>
<li><em>lionel，应该也是看的</em>，自己没做出来</li>
<li><strong>核心是用replace替换</strong></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-c++">string subString(string src, string oldStr, string newStr) {
    string dest_str = src;
    string::size_type pos = 0;
    while ((pos = dest_str.find(oldStr)) != string::npos) {
        dest_str.replace(pos, oldStr.size(), newStr);
    }
    return dest_str;
}

void od38_impl(vector&lt;int&gt; input) {
    string res_helper;
    for (auto n : input) {
        res_helper += to_string(n);
    }

    string tmp1 = subString(res_helper, "111", "x");
    string tmp2 = subString(tmp1, "11", "x");
    string tmp3 = subString(tmp2, "1", "x");
    int res = 0;
    for (auto c : tmp3) {
        if (c == 'x')
            res++;
    }

    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<ul>
<li>52分割数组最大差值<ul>
<li>也是逻辑做的，就是暴力</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od52_impl(int num, vector&lt;int&gt; input) {
    int total = 0;
    total = accumulate(input.begin(), input.end(), total);

    int res = 0;
    int sum = 0;

    for (int i = 0; i &lt; input.size(); i++) {
        sum += input[i];
        int left = sum, right = total - sum;
        res = max(res, abs(right - left));
    }
    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<ul>
<li>54保密电梯（done）<ul>
<li><em>这是抄的</em>，自己并没有完全消化</li>
</ul>
</li>
<li>63数字涂色<ul>
<li><em>不一定对</em>，重新学一下</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-c++">void od63_impl(int n, vector&lt;int&gt; inputs) {
    vector&lt;int&gt; res;
    int min = inputs[0];
    res.push_back(min);
    for (int i = 1; i &lt; inputs.size(); i++) {
        if (inputs[i] % min != 0) {
            res.push_back(inputs[i]);
        } else
        {
            break;
        }

    }
    cout &lt;&lt; res.size() &lt;&lt; endl;
}</code></pre>
<ul>
<li>70食堂供餐</li>
</ul>
<pre class="highlight"><code class="language-cpp">//hour是开餐开长，count是盒饭份数，person是排队人数
void od70_impl(int hour, int count, vector&lt;int&gt; person) {
    int res = 0;
    int sum = 0;
    sum = accumulate(person.begin(), person.end(), sum);  //lionel，这个sum，还得给个返回值来接一下，不然sum还是0

    while ((hour - 1)*res + count &lt; sum) {
        res++;
    }
    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<ul>
<li>76荒岛求生</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od76_impl(vector&lt;int&gt; input) {
    stack&lt;int&gt; s;
    int res = 0;
    for (auto c : input) {
        if (c &gt; 0) {
            s.push(c);
        } else if (c &lt; 0) {  //lionel，现在是正数多一个，如果是负数多一个怎么办？s.top()取不到值，但c还有，也是要++的，这个地方不够健壮，要判断一下 s.top()
            if (s.top() + c != 0) {
                res++;
            }
            s.pop();
        }
    }
    if (s.size() &gt; 0)
        res += s.size();
    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<ul>
<li>78报数游戏<ul>
<li>是不是也属于约瑟夫环的一种？</li>
<li><em>lionel，应该也没有做出来</em></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od78_impl(int n) {
    //list&lt;int&gt; input;
    vector&lt;int&gt; input;
    for (int i = 1; i &lt;= 100; i++)
        input.emplace_back(i);

    int index = 0;
    while (input.size() &gt;= n) {
        index = (index + (n - 1)) % (input.size());  //lionel，核心还是这个公式，当然还是要用vector，当然用vector时，用erase(v.begin()+pos)
        //input.remove(index);
        input.erase(input.begin()+index);
        //cout &lt;&lt; input.size() &lt;&lt; endl;
    }

    for (auto c : input) {
        cout &lt;&lt; c &lt;&lt; endl;
    }
}</code></pre>
<ul>
<li>80CPU算力<ul>
<li>逻辑题<ul>
<li>除表示次数</li>
<li>取余表示剩下还可以用</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od80_impl(vector&lt;int&gt; input, int taskNum) {
    int time = 0;
    int remain = 0;
    for (auto count : input) {
        if (count + remain &gt; taskNum) {  //remain第一次只是顺带，后面的话，要代入带来处理的
            remain = count + remain - taskNum;
        } else {
            remain = 0;
        }
        time++;
    }

    time += remain / taskNum; //剩下的还要几次

    if (remain % taskNum &gt; 0) //如果剩下的还有余下的，说明还需要一次
        time++;

    cout &lt;&lt; time &lt;&lt; endl;
}</code></pre>
<ul>
<li>83字符串序列II<ul>
<li><em>这个自己不会</em></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">//判断 abc 是不是 abcayber的子序列，Out:3【最后一个子序列的起始位置】
void od83_impl(string target, string source) {
    //for (int i = target.size(); i &gt; 0; i--) {  //lionel，本来想搞2层for循环的，发现可以优化，也是参考的
    int cur = target.size();
        for (int j = source.size(); j &gt; 0; j--) {
            if (source[j] == target[cur]) {
                cur--;
                if (cur &lt; 0)
                {
                    cout &lt;&lt; j &lt;&lt; endl;
                    break;
                }

            }
        }
    //}
}</code></pre>
<ul>
<li>85字符串变最小字符串<ul>
<li><em>也是抄的</em></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od85() {
    string str = "bcdefa";//找到a,跟b换一下，输出acdefb

    string s2 = str;
    sort(s2.begin(), s2.end());

    char min = s2[0];
    int place = 0, change = 0;

    for (int i = 0; i &lt; str.size(); i++) {
        if (str[i] == min) {//找到原串中最小的位置
            place = i;
            break;
        }
    }

    for (int j = 0; j &lt; str.size(); j++) {
        if (str[j] != min) {  //这个地方取原串，未排序的
            change = j;//记下排序后，不等的地方
            break;
        }
    }

    if (place &gt; change) {
        swap(str[place], str[change]);
    }

    cout &lt;&lt; str &lt;&lt; endl;
}</code></pre>
<h4 id="undo-13">逻辑分析（undo-13）<a class="headerlink" href="#undo-13" title="Permanent link">&para;</a></h4>
<ul>
<li>14</li>
<li>18</li>
<li>26</li>
<li>31</li>
<li>48</li>
<li>49</li>
<li>61</li>
<li>67</li>
<li>68</li>
<li>75</li>
<li>89</li>
<li>92</li>
<li>94</li>
</ul>
<h3 id="_8">重要看的（之前不会）<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<h4 id="dfs">dfs<a class="headerlink" href="#dfs" title="Permanent link">&para;</a></h4>
<ul>
<li>50文件目录大小<ul>
<li><strong>这个难点，在于构造<code>file</code>结构体</strong>，这确实是我没想到的，dfs的思想反而简单了些</li>
<li><em>知道要有dfs()函数，便参数怎么确定，不太明白</em></li>
<li>LC113：路径总和II，<em>是这个吗？</em>https://www.jianshu.com/p/c2e1851164eb</li>
<li>LC690：</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">//参考LC690
typedef struct f {
    int id;
    int size;
    vector&lt;int&gt; subordinates;
}file;

void dfs(int id, unordered_map&lt;int, file&gt;&amp; um, int&amp; sum) {
    for (auto id : um[id].subordinates) {
        sum += um[id].size;
        dfs(id, um, sum);
    }
}

void od_50_impl(int n, vector&lt;file&gt; input) {
    unordered_map&lt;int, file&gt; um;
    for (auto c : input) {
        um[c.id] = c;
    }

    int sum = um[n].size;
    dfs(n, um, sum);
    cout &lt;&lt; sum &lt;&lt; endl;
}

//lionel，相当于，我要把每一行放到 file 结构体里

void od50() {
    int m = 4;
    int n = 2;
    vector&lt;int&gt; tmp{ 4,5 };
    vector&lt;int&gt; emp;
    vector&lt;file&gt; inputs{ {4,20,emp},{5,30,emp},{2,10,tmp},{1,40,emp} };  //输出就是60
    od_50_impl(n, inputs);  //lionel，如何用指针？
}</code></pre>
<h4 id="_9">递归<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h4>
<ul>
<li>15分糖果<ul>
<li><em>自己做出来了</em>，但不确定是不是就是100分的答案</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">int od15_impl(int input) {
    int res = 0;
    if (input == 1) {
         res++;
         return res;//lionel，这个地方有问题，return res++（只是返回4），拆成2句就是5，**其实左加和右加还是有区别的**
    }

    if (input % 2) {
        input += 1;
    } else{
        input /= 2;
        res++;
    }

    cout &lt;&lt; input &lt;&lt; endl;
    res += od15_impl(input);
}</code></pre>
<h4 id="_10">贪心<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h4>
<ul>
<li>24最大股票收益</li>
</ul>
<pre class="highlight"><code class="language-c++">void od24_impl(vector&lt;string&gt; input) {
    vector&lt;int&gt; nums;
    string tmp;
    for (auto s : input) {
        int len = s.size();
        char last = s[len - 1];
        tmp = s.substr(0, len - 1);
        if (last == 'Y') {
            nums.emplace_back(stoi(tmp));
        }
        if (last == 'S') {
            nums.emplace_back(stoi(tmp) * 7);
        }
    }

    int sum = 0;
    int maxValue = 0;
    int first = nums[0];
    for (int i = 1; i &lt; nums.size(); i++) {
        if (nums[i] - first &gt; maxValue) {
            sum -= maxValue;
            maxValue = nums[i] - first;  //lionel，当时用了一个补丁方案，当i=len-1时，sum+=maxValue，解决最后一个maxValue不能加的问题
            sum += maxValue;
        } else {
            maxValue = 0;
            first = nums[i];//lionel，第一版时，写在这的sum += maxValue;
        }
    }
    cout &lt;&lt; sum &lt;&lt; endl;
}</code></pre>
<ul>
<li>29阿里巴巴找黄金宝箱II</li>
</ul>
<pre class="highlight"><code class="language-c++">bool cmp(pair&lt;int, int&gt; m1, pair&lt;int, int&gt; m2) {
    if (m1.second &gt; m2.second)
        return 1;
    return 0;
}

//1,1,1,1,3,3,3,6,6,8  Out:2
void od29_impl(vector&lt;int&gt; inputs) {
    map&lt;int, int&gt; val;
    for (int i = 0; i &lt; inputs.size(); i++) {
        val[inputs[i]]++;
    }

    int len = inputs.size();
    vector&lt;pair&lt;int, int&gt;&gt; res{ val.begin(),val.end() };

    sort(res.begin(), res.end(), cmp);

    //cout &lt;&lt; res[0].first &lt;&lt; res[0].second &lt;&lt; endl;
    int remain = len / 2 - 0;

    while (remain &gt; 0) { //lionel，这个是临时想到的
        remain -= res[0].second;
        res.erase(res.begin());  //lionel，这个是不会，搜的
    }
    cout &lt;&lt; res.size() &lt;&lt; endl;
}</code></pre>
<ul>
<li>30玩牌高手<ul>
<li><em>lionel，每次与前面的比最大值</em>，也不知道对不对</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-c++">//1,-5,-6,4,3,6,-2  Out:11  【不选本轮的话，选3轮前的】
void od30_impl(vector&lt;int&gt; input) {
    //vector&lt;int&gt;result(input.size());//lionel，本意是把input.size()的大小，都赋值成0，vector&lt;int&gt;result { 0 };这种写法是错误的
    //int res = 0;
    int maxValue = 0;
    vector&lt;int&gt; score;
    for (int i = 0; i &lt; input.size(); i++) {
        if (i &lt; 3) {
            maxValue = max(input[i], 0);
            score.emplace_back(0);
        } else {
            maxValue = max(input[i]+maxValue, score[i - 3]);
            score.emplace_back(maxValue);  //lionel，也是突然之间改对了，境加了一个score的vector类型，把每次的比较，result[i-3]改成了score[i-3]
            //res += maxValue;
        }
        //cout &lt;&lt; maxValue &lt;&lt; endl;
    }
    cout &lt;&lt; maxValue &lt;&lt; endl;
}</code></pre>
<h4 id="_11">单调栈<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h4>
<ul>
<li>25找朋友</li>
</ul>
<h4 id="_12">动规（我自己列的）<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h4>
<ul>
<li>27猴子爬山<ul>
<li>参考LC70</li>
<li>每次跳一步，或者跳3步<ul>
<li>第1个台阶，只有1种</li>
<li>第2个台阶，也只有1种</li>
<li>第3个台阶，就有2种</li>
<li>第4个台阶，就可以用<code>f(n)=f(n-1)+f(n-3)</code>了，<strong>记得从4开始</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od27_impl(int input) {
    const int n = 100;//lionel，先定义为100吧
    int dp[n] = {0};
    dp[1] = 1;
    dp[2] = 1;
    dp[3] = 2;
    //dp[3]=2,dp[2]+dp[1] = 2;
    // dp[4] =dp[3]+dp[2]
    for (int i = 4; i &lt;= input; i++) {  //lionel，这个点要从4开始，我写成了3了
        dp[i] = dp[i - 1] + dp[i - 3];
    }
    cout &lt;&lt; dp[input] &lt;&lt; endl;
    //动态规划的公式不会算，dp[i]=dp[i-3]
}</code></pre>
<ul>
<li>在</li>
</ul>
<h3 id="_13">不会的知识点<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h3>
<h4 id="_14">区间交并集<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h4>
<ul>
<li>2路灯照明问题<ul>
<li><em>不一定是自己做出来的，也不一定对</em></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-c++">int od02_impl(vector&lt;int&gt; input, int N) {
    constexpr int len = 100;
    int res = 0;
    int first = 0, last = 1;
    while (first &lt; last) {
        while (last &gt;= input.size())
            //break;
            return res;  //lionel，这是个临时方案，为何break; 在这个地方不行了呢

        int distance = input[first] + input[last];
        if (distance == len) {
            res += 0;
        } else {
            if (distance &gt; len)
                res += 0;//lionel，大于100的时候，不用管，其实 这里面可以缩小到只判断一种，多了一些无用的判断语句
            else
                res += abs(len - distance);
        }
        first++;
        last++;
    }
    return res;
}</code></pre>
<h4 id="_15">位运算<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h4>
<ul>
<li>08分苹果<ul>
<li>最开始没做出来，感觉是题意都没读懂，当然<em>也有后面的技术问题</em>（比如怎么逐个算2进制）</li>
<li><em>还是有一些疑问的</em>，比如<strong>二进制累加</strong>，为何可以直接用<strong>异或</strong>，而不需要单独拆成二进制？【当然这可能属于经典知识】<ul>
<li><strong>异或，就是不带进位的二进制加法</strong>（题目的意思，就是2进制累加时，不计算进位）-<em>本质上是这个知识点不会</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">//输入数量3，每个苹果质量是3,5,6  [输出11，因为3的二进制是1，5和6的二进制之和也是1]
void od08_impl(int num, vector&lt;int&gt; input) {   //lionel，可能最开始题目都理解错了
    //lionel，问题是，1个数的二进制怎么算？ 跟谁去异或？【这个问题，没解答出来】

    // 先排个序？lionel，其实无所谓
    sort(input.begin(), input.end());

    int res = 0;
    //10-28解答，是因为要算left【至少从0到1】，算right也是【i,到最后一个】
    for (int i = 1; i &lt; input.size()-1; i++) { //lionel，这个地方为何是从1开始？还有只到input.size()-1 ？
        int binA = 0, binB = 0;
        int sumA = 0, sumB = 0;  //lionel，这2处赋初值，是不是只能在for里面赋值，啥意思？
        //left
        for (int left = 0; left &lt; i; left++) {
            binA ^= input[left];
            sumA += input[left];
        }

        //right
        for (int right = i; right &lt; input.size(); right++) {
            binB ^= input[right];
            sumB += input[right];
        }

        if (binA == binB) {
            res = max(sumA, sumB);
        }
    }
    cout &lt;&lt; res &lt;&lt; endl;

}</code></pre>
<ul>
<li>72数据分类</li>
</ul>
<pre class="highlight"><code class="language-cpp">int add(int value){  //lionel，是我这个理解错了，https://blog.csdn.net/yuhaomogui/article/details/125341750
    int sum = 0;
    while (value &gt; 0) {
        sum += value &amp; 0xff;
        value &gt;&gt;= 8;
    }
    return sum;
}

void od72_impl(vector&lt;int&gt; input) {
    int modNum = input[1];
    int val = input[0];
    vector&lt;int&gt;nums(input.begin() + 2, input.end());
    vector&lt;int&gt; res;
    for (auto c : nums) {
        int v = add(c);
        //cout &lt;&lt; v &lt;&lt; endl;
        res.push_back(v % modNum);
    }

    map&lt;int, int&gt;m;
    for (auto c : res) {  //lionel，应该是1 2 3 0 1 2 3 0 12，我输出是 0 1 2 3 0 1 2 3 0 1
        m[c]++;
    }

    int min = 0;
    for (auto c : m) {
        //cout &lt;&lt; c.first &lt;&lt; endl;
        if (c.first &lt; val) {
            min = c.second &gt; min ? c.second : min;
        }
    }
    cout &lt;&lt; min &lt;&lt; endl;
}</code></pre>
<h4 id="_16">正则表达式<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h4>
<ul>
<li>58增强的strstr<ul>
<li><em>但考查的应该不是这个</em></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-c++">//"a[bc]"匹配"ab"或"ac"
void od58_impl(string input_src, string input_target) {
    regex r(input_target);
    smatch m; //lionel，这是个啥
    regex_search(input_src, m, r);
    int res = 0;
    if (m.size()) {
        res = m.position();
    } else
        res = -1;

    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<h4 id="debug-1undo-1">数学运算（debug-1，undo-1）<a class="headerlink" href="#debug-1undo-1" title="Permanent link">&para;</a></h4>
<ul>
<li>23、</li>
<li>64勾股数元组<ul>
<li>核心<strong>两两互斥</strong>怎么实现</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">//输入，1和20，输出 3组  【3，4,5 ; 5,12,13; 8,15,17】
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}

void od64() {
    int n, m;
    while (cin &gt;&gt; n &gt;&gt; m) {
        int found = 0;
        for (int i = n; i &lt;= m; i++) {
            for (int j = i + 1; j &lt;= m; j++) {
                int k = (int)sqrt(i * i + j * j);
                if (k &gt; m) {
                    break;
                }
                if (k * k == i * i + j * j) {
                    if (gcd(i, j) == 1 &amp;&amp; gcd(j, k) == 1) {
                        cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; " " &lt;&lt; k &lt;&lt; endl;
                        found = 1;
                    }
                }
            }
        }
        if (!found) {
            cout &lt;&lt; "Na" &lt;&lt; endl;
        }
    }
}</code></pre>
<ul>
<li>65工号不够怎么办<ul>
<li>标准的数学问题，没想出来，网上找的答案</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od65() {
    //n=26的a次方+10的b次方
    int x = 2600, y = 1;  //26,1输出1   2600，1输出2

    //总人数
    int sum = pow(26, y);

    //数字个数
    int dig = 1;
    //y个字母
    while (sum * pow(10, dig) &lt; x) {
        dig++;
    }

    cout &lt;&lt; dig &lt;&lt; endl;
}</code></pre>
<ul>
<li>71、（undo）</li>
</ul>
<h4 id="_17">数据结构（栈）<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h4>
<ul>
<li>13选修课（<em>但我没用栈做</em>，在<strong>字符串</strong>里）</li>
<li>33消消乐游戏</li>
</ul>
<pre class="highlight"><code class="language-c++">//Input:mMbccbc  Out:3(mMc)
void od33_impl(string inputs) {
    stack&lt;char&gt; s;
    for (int i = 0; i &lt; inputs.size(); i++) {
        s.push(inputs[i]);
        if (s.top() == inputs[i+1]) { //i++和++i还是有蛮大区别的，写一行，和分两行写，还是有说法的
            s.pop();
            i++;
            break; //lionel，break还是调试出来的；
        }
    }
    cout &lt;&lt; s.size() &lt;&lt; endl;
}</code></pre>
<ul>
<li>36数组去重和排序（<em>但我没用栈做</em>，在<strong>字符串</strong>里）</li>
<li>39查找众数及中位数<ul>
<li><em>估计还没有debug出来，会core掉</em></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">bool cmp39(pair&lt;int, int&gt; m1, pair&lt;int, int&gt; m2) {
    if (m1.second &lt; m2.second)  //lionel，因为存在重复的元素，我就聪明的写个=号，会发生断言错误if (m1.second &lt;= m2.second)，这种不支持
        return 1;
    return 0;
}

void od39_impl(vector&lt;int&gt; inputs) {
    map&lt;int, int&gt; countMap;
    for (int i = 0; i &lt; inputs.size(); i++) {
        //lionel，不知道怎么用map去存重复的值了？
        countMap[inputs[i]]++; //lionel,0922突然想起来的
    }

    vector&lt;pair&lt;int, int&gt;&gt; res{ countMap.begin(),countMap.end() };
    sort(res.begin(), res.end(), cmp39);

    vector&lt;int&gt; result;
    int len = res.size();
    int max = res[len - 1].second;
    for (int i = len; i &gt; 0; i--) {
        if (res[i - 1].second == max)
            result.push_back(res[i - 1].first);
        else
            break;
    }

    int middle = 0;
    sort(result.begin(), result.end());
    len = result.size();
    if (len % 2 != 0) {
        middle = result[len / 2];
    } else {
        middle = (result[len / 2] + result[len / 2 - 1]) / 2;
    }
    cout &lt;&lt; middle &lt;&lt; endl;
}</code></pre>
<h4 id="_18">二分查找<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h4>
<ul>
<li>53生日礼物</li>
</ul>
<pre class="highlight"><code class="language-cpp">//10,20,5 蛋糕单价 5,5,2小礼物单， 预算15
void od53_impl(vector&lt;int&gt; cake, vector&lt;int&gt; gift, int value) {
    int res = 0;
    //先排个序
    sort(cake.begin(), cake.end());
    sort(gift.begin(), gift.end());
    for (int i = cake.size() - 1; i &gt;= 0; i--) { //lionel，i&gt;=0，少判断一位
        if (cake[i] &gt; value) {
            continue; //lionel，这个还是没分清，break与contiue的区别，还是调试出来的
        }
        for (int j = gift.size() - 1; j &gt;= 0; j--) {
            if (cake[i] + gift[j] &lt;= value) {
                res++;
            }
        }
    }
    cout &lt;&lt; res &lt;&lt; endl;
}</code></pre>
<h4 id="undo-1_1">约瑟夫环（undo-1）<a class="headerlink" href="#undo-1_1" title="Permanent link">&para;</a></h4>
<ul>
<li>05喊7的次数重排</li>
</ul>
<h3 id="_19">自己觉得未消化的知识<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h3>
<h4 id="_20">回溯<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h4>
<ul>
<li>54保密电梯</li>
</ul>
<pre class="highlight"><code class="language-cpp">void od54() {
    // 5,3 
    // 1 2 6
    //输出6 2 1  【1，2 6和6，2，1都是，按先处理大值，6，2，1】

    //典型的回溯，(lionel，我怎么看不出来典型）

    int target=5, n=3;
    //cin &gt;&gt; target &gt;&gt; n;
    //1 2 6 怎么写到vector中
    int tmp;
    vector&lt;int&gt; nums{1,2,6};
#if 0
    //其实可以在while（）里用n--的方式
    while (cin &gt;&gt; tmp) {
        nums.push_back(tmp);
        if (cin.get() == '\n')
            break;
    }
#endif

    //按大值处理，先排序
    sort(nums.begin(), nums.end(), greater&lt;int&gt;());
    vector&lt;int&gt; path(n,0);
    vector&lt;bool&gt;visited(100,false);  //lionel，记错了，前面是数量，后面才是初始化的值

    dfs(nums, 1, 0, 0, target, path, visited);

    if (!res.empty()) {   //lionel，为啥这个地方是6呢
        string s = to_string(res[0]);
        for (int i = 1; i &lt; res.size(); i++){
            s += ",";
            s += to_string(res[i]);
        }
        cout &lt;&lt; s &lt;&lt; endl;
    }
}

/*
* 数组序列
* 向上还是下
* 目前所在楼层
* 第几次楼层移动
* 目标楼层
* 在楼层上下过程中的记录
* 记录哪些移动楼层数字已经被使用
*/
void dfs(vector&lt;int&gt; nums, int direction, int level, int i, int target, vector&lt;int&gt; &amp;path, vector&lt;bool&gt; &amp;visitied) {
    //使用完所有次数
    if(i==nums.size()){
        //到达楼层，或者小于该楼层最近
        if (target - level &gt;= 0 &amp;&amp; target - level &lt; min1) {
            min1 = target - level;
            res = path;
        }
        return;
    }

    //遍历序列，
    for (int j = 0; j &lt; nums.size(); j++) {
        if (!visitied[j]) {
            visitied[j] = true;
            path.push_back(nums[j]);
            //上还是下
            if (direction == 1) {
                dfs(nums, 0, level + nums[j], i + 1, target, path, visitied);
            }else {
                //下的话，就要减
                dfs(nums, 1, level - nums[j], i + 1, target, path, visitied);
            }
            //回溯
            path.pop_back();//删除元素  https://blog.csdn.net/qq_39451578/article/details/115015639
            visitied[j] = false;
        }
    }
}</code></pre>
<h3 id="_21">之前不会的知识点<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h3>
<h4 id="_22">位运算<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>异或，就是不带进位的二进制加法</strong>（题目的意思，就是2进制累加时，不计算进位）-<em>本质上是这个知识点不会</em><ul>
<li>来自题08</li>
</ul>
</li>
</ul>
<h4 id="_23">字符串<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>题07</p>
<ul>
<li>如果用<code>stol()</code>越界的话，可以考试用<code>stoll()</code></li>
</ul>
<ul>
<li>16进制转型，<code>string hexstr; stoi(hexstr,0,16);</code>，这个后面也遇到过，没做对</li>
</ul>
<ul>
<li>C++20的，<code>std::format</code>，<em>lionel，这个没会，没学呢</em></li>
</ul>
<ul>
<li>
<p>把整型转成16进制字符串（ostringstream对象、iomainip）</p>
<ul>
<li>因为0的时候，只转成1个0，所以要强制一下？</li>
</ul>
<pre class="highlight"><code class="language-cpp">string num2hex(int num) {
    std::ostringstream ss;
    if (num &gt;= 0 &amp;&amp; num &lt;= 255) {
        ss &lt;&lt; std::hex &lt;&lt;setw(2) &lt;&lt;setfill('0') &lt;&lt; num;//没有头文件iomainip，所以不能用setw
    }
    return ss.str();
}</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li>题19<ul>
<li>字符转整型，<code>sum += (val[i] - '0');</code>，<strong>直接用<code>-'0'</code>解决</strong></li>
<li><code>stoi()</code>是可以判断正负的，https://www.jianshu.com/p/cdd95f5eaebb</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>题90</p>
<ul>
<li>怎么拆分空格（没有好好理解呢）<strong>感觉有点整复杂了</strong></li>
</ul>
<pre class="highlight"><code class="language-cpp">//Input: who love solo  这种其实可以在输入的时候直接处理掉，直接转换成acm模式的输入输出问题了
std::string s;
char delim = ' ';
s.append(1, delim);
std::regex reg(s);
std::vector&lt;std::string&gt; elems(std::sregex_token_iterator(input.begin(), input.end(), reg, -1),           std::sregex_token_iterator());</code></pre>
<ul>
<li>输出格式化，<code>cout &lt;&lt; fixed&lt;&lt;setprecision(2)&lt;&lt;(sum*1.0) / res.size() &lt;&lt; endl;</code></li>
</ul>
</li>
</ul>
<ul>
<li>
<p>题13</p>
<ul>
<li><strong>字符串比较compare函数</strong>，<code>int m = s1.compare(0, 5, s2, 0, 5);</code></li>
</ul>
</li>
</ul>
<h4 id="_24">正则表达式<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>题20</p>
<ul>
<li>要包含头文件<code>#include&lt;regex&gt;</code></li>
</ul>
<pre class="highlight"><code class="language-cpp">bool check(string str) {
  regex r("[0-9]");
  string replace = regex_replace(str,r, "");//把数字替换掉
  //cout &lt;&lt; str &lt;&lt; "," &lt;&lt; replace &lt;&lt; endl;
  /*
  *
  ab, ab 
  bC1, bC
  C124, C
С124A, СА
124ACb, ACb
24ACb, ACb
4ACb, ACb 
ACb, ACb
  */
  return replace.size() != str.size() &amp;&amp; replace.size() &lt;= 1; //lionel，这个也没懂
}</code></pre>
</li>
</ul>
<ul>
<li>题44</li>
</ul>
<pre class="highlight"><code class="language-cpp">//把字符串拆成数字和字符，比如stone4这样，当然也可以不用这么复杂        
regex reg1 ("[0-9]") ;
regex reg2("[a-zA-Z]") ;
string value = regex_replace(s1, reg1, "");
string num = regex_replace(s2, reg2, "");</code></pre>
<ul>
<li>题73</li>
</ul>
<pre class="highlight"><code class="language-cpp">regex ws_re("\\s+");//lionel，不是太明白这个正则
    vector&lt;string&gt; res_helper(sregex_token_iterator(input.begin(), input.end(), ws_re, -1), sregex_token_iterator());</code></pre>
<ul>
<li>在</li>
</ul>
<h4 id="_25">其它<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h4>
<ul>
<li><code>accumlate()</code>的使用，**头文件是<code>#include&lt;numic&gt;</code>，具体使用是<code>int first = accumulate(nums.begin(), nums.begin() + i,0);</code></li>
<li>题34，<strong>全排列</strong></li>
</ul>
<pre class="highlight"><code class="language-cpp">    vector&lt;string&gt; v1{ s1,s2,s3 };
    sort(v1.begin(), v1.end());
    vector&lt;string&gt;v2;
    do {
        //cout &lt;&lt; v1 &lt;&lt; endl;
        v2.push_back(v1[0] + v1[1] + v1[2]);
    } while (next_permutation(v1.begin(), v1.end()));</code></pre>
<ul>
<li>题36，map的一些使用<ul>
<li><strong>重复文件如何插入map</strong><ul>
<li>1、用pair类型，<code>map.insert(make_pair(1,1));map.insert(make_pair(1,2));</code></li>
<li>2、用下标，<code>map[1]=2;map[1]=3;</code></li>
</ul>
</li>
<li>pair的头文件是<code>#include&lt;utility&gt;</code></li>
<li><code>sort()</code>不支持map，要把map赋值到vector中才行<ul>
<li>csdn，Tianqinse，摸森堡</li>
</ul>
</li>
<li>csdn, weixin_41588502，Daniel_tmz，C++中的sort自定义排序函数</li>
</ul>
</li>
<li><code>return res++;</code>和<code>return ++res;</code>还是有区别的</li>
<li>09组成最大数的<strong>理论依据</strong></li>
<li><strong>自定义排序时</strong>，不能<strong>有等于的</strong>情况（大于，小于都可以）</li>
<li>在</li>
</ul>
<h3 id="_26">遗留问题<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h3>
<h4 id="_27">做得不一定对<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h4>
<ul>
<li>03</li>
<li>63</li>
<li>84</li>
<li>86</li>
</ul>
<h4 id="_28">知识点<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h4>
<ul>
<li>C++20的，<code>std::format</code></li>
<li>12、<ul>
<li>LC，种花</li>
</ul>
</li>
</ul>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../91leetcode/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/" class="btn btn-neutral float-left" title="《剑指offer专项突破》"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../OD%E8%BF%9B%E9%98%B6%E9%A2%98/" class="btn btn-neutral float-right" title="OD进阶题">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../../91leetcode/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../OD%E8%BF%9B%E9%98%B6%E9%A2%98/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
