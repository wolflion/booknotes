## 《剑指offer》

+ 全书共75道（没有网上搜的81道，书是68道，有部分题是分2小道的），计划从0725开始刷，leetcode上需要31天
  + 0731发现了2道（53III、50II），书上有，但刷题库上没有
  + 0803发现了（23、1、2），书上有
+ https://leetcode.cn/study-plan/lcof/
+ https://leetcode.cn/studyplan/coding-interviews/  【新模板】
+ 书中的作者源代码：https://github.com/zhedahht/CodingInterviewChinese2
+ 刷题分为3步:（这样才能确定下问题出在哪一步）
  + 1、读懂题目
  + 2、分析，推导，**逻辑上这题怎么解**
  + 3、把思路转化为代码
+ 20230725-发现自己的一个问题，**没有耐心一步步的往下推下去**，哪怕是简单的排序算法，**要先想着怎么去暴力**，也就是**要先做出来，然后再优化**，自己第一步都不好好整，这是个问题，*要逐步fixed掉这个问题*
  + **如何才算刷透《剑指offer》**-这个我还没有答案
  + 遇到瓶颈或疑问时，要问问**《剑指offer》怎么刷**
+ 重要的参考：
  + [《剑指offer》所有题目解法思路与出现频率汇总](https://blog.csdn.net/weixin_43954951/article/details/125821879)，*在这个里面找思路，便于自己记一下*

### 书上一些思想

#### 3.3、代码的完整性

##### 1、从3个方面确保代码的完整性

+ 一、普通功能测试的测试用例
+ 二、各种边界值的测试用例
+ 三、各种可能的错误输入

##### 2、3种错误处理的方法

+ 一、函数用返回值来告知调用者是否出错
+ 二、当错误发生时设置一个全局变量
  + `GetLastError()`机制就是用的是全局变量
  + **问题是**，不是每次调用者，都会去调用`GetLastError()`来判断正确与否
+ 三、异常

### W1（0725-0729，21道+2）

#### W1.1、栈与队列（4）

+ d1：9、用2个栈实现队列
  + 作者思路：
    + 插入的时候，在stack1插即可
    + 删除的时候，得用到stack2，如果stack2为空，得把stack1入到stack2里，然后再再删，如果stack1也为空，就是异常
+ d1：30、包含min函数的栈
  + 直观想法：压入栈里的元素排序，但问题**不保证最后入栈的元素先出**
  + 自己思路：用一个单独变量去存最小值，**但问题是，最小元素被弹出了，如何得到下一个更小的**，所以就需要一个**辅助栈**去存一下【所谓辅助栈，就是再定义一个栈嘛】
+ d27：59I（H）滑动窗口的最大值
  + 自己思路：暴力（还不一定能写得出来）
  + 作者思路：
    + 方法1：利用2个栈组成队列，同时写一个max函数的栈，O(1)，**这种组合不一定好想**
    + 方法2：利用deque，可能成为最大值的存入deque，*一般deque里放2个值*，【重点是，怎么判断最后一位】
+ d27：59II（M）、队列的最大值
  + 利用59I里的，2个组合（2个栈实现队列，再找最大）

#### W1.2、链表（7）

+ d2：6、从尾到头打印链接
+ d2：24、反转链表
+ d2：35（M）、复杂链表的复制
+ d11：18、删除链表的节点
  + **要分场景讨论**（非头/尾时）
+ d11：22、链表中倒数第k个节点
  + 第一想到的就是从头到尾，**因为是单链表**，没法从尾到头
  + 方法：**双指针**，p1先走个（长度-k），然后p2再走，那么p2就是。【自己想的，不一定对】
+ d12：25、合并2个排序的列表
  + *我想着new一个节点出来呢*，**注意鲁棒性**
+ d12：52、两个链表的第一个公共节点
  + 方法1：第一想到的就是从头往后，需要O(m*n)
  + 方法2：从后往前呢
    + 2.1、需要辅助栈
    + 2.2、不需要辅助栈，**先求链表长度**

#### W1.3、字符串（4）

+ d3：5、替换空格
  + 自己想的，**暴力**（逐个替换），需要O(n平方)
  + 作者思路：先得到空格数目，再算新的长度，**双指针 牛逼**（p1指向原字符串末尾，p2指向新字符串末尾），从后往前替换，p2与p1相同了，就表示全部替换结束了
+ d3：58II、左旋转字符串（abcdefg，2）变成（cdefgab）
  + 自己想法：先记住左边，右边往左边移嘛，然后插入到后面即可，*可能有一些边界性的问题*
  + 作者思路，利用了**58I**的结论
+ d26：20、表示数值的字符串
  + *自己想的，怎么建立规则*
+ d26：67、把字符串转换成整数
  + *这个没太有思路，但觉得要分场景讨论*
  + 作者思路：**核心就是`num=*string *10 + *string -'0'`，但还有很多边界条件**

#### W1.4、查找（6+2）

+ d4：3、数组中重复的数字
+ d4：53I、在排序数组中查找数字
  + 自己思路：**有序就二分**，*lionel，如何利用二分*，`GetFirstK()、GetLastK()`
+ d4： 53II、0~n-1中缺失的数字
  + *lionel，这个没看*
+ 53III、数组中数值和下标相等的元素（这道题，书上有）
+ d5：4（M）、二维数组中的查找
+ d5：11、旋转数组的最小数字
  + 自己思路，*lionel，题目都没懂*
+ d5： 50I、第一个只出现一次的字符
  + 自己思路，**用hash**，*lionel，但怎么算第1个呢？*
+ 50II、字符流中第一个只出现一次的字符（这道题，书上有）

### W2（0730-0805，18道）

#### W2.1、搜索与回溯算法（18）

+ d6：32I（M）、不分行从上到下打印二叉树
  + 作者思路：先找到根，**再用队列去存节点**，然后再从左找1个（有左右节点，再放到队列后面），这样保证顺序性，**自己画个图**走一下流程（8，6，10，5，7，9，11）这样的顺序是不是ok，**用deque**
  + **进阶**，广度优先遍历二叉树，不是太明白
+ d6：32II、分行从上到下打印二叉树
  + 作者思路：在上面的基础上，**需要2个变量**，1个是当前层中还没有打印的节点数toBePrinted，另一个变量是表示下一层节点的数目nextLevel，**只要toBePrinted!=0，就不换行**，*lionel，还得思考下，怎么处理这2个变量的关系*
+ d6：32III（M）、之字形打印二叉树
  + *lionel，初步没太看懂，然后也就没看*
+ d7：26（M）、树的子结构
  + 自己思路：**分2步**：第1步是树A中找到和树B的根节点一样的节点R，第2步，判断树A中以R为根节点的子树是不是包含和树B一样的结构  *lionel，但这个实现就有点复杂了*
+ d7：27、二叉树的镜像
  + 自己思路：**要理解镜像**，不仅结构一样，里面的值也一样（注意顺序）
+ d7：28、对称的二叉树
  + 自己思路：**要理解对称**，要保证结构一样
  + 作者码，**递归调用2个根节点作为参数**，判断左右和右左，*自己还不是十分明白*
+ d14：12、矩阵中的路径
  + 自己想法，最开始用暴力，然后**根据矩阵找规律**
+ d14：13、机器人的运动范围
  + *自己也没啥思路，作者也没说清楚，（0，0）到（i,j），再判断（i,j）四边的情况，（i-1,j），(i+1,j）这样的*
  + **回溯算法**原理是个啥？
+ d15：34、二叉树中和为某一值的路径
  + 自己思路：用栈+递归，如果大于某值，就退出到根节点，往右去【但要自己写好，也不容易】
+ d15：36、二叉搜索树与双向链表
+ d15：54、二叉搜索树的第k大节点
  + 自己思路：利用好**二叉搜索树**的特性，k是个入参，先找到根，判断小还是大（小就往左，大就往右），也靠递归，【但代码实现，还得自己手撕一下】
+ d18：55II、二叉树的深度
  + 自己思路：递归，如果没有子节点，就=1，然后再往回++，**区分左右**，`leftvalue= 1+depath(left),rightvalue=1+depth(right)，取最大的`
  + **自己的难点在于怎么调试**，创建树型结构自己弄得比较少，但也copy过一些ds的代码
+ d18：55II、判断树是不是平衡二叉树
  + 自己思路：**递归**，每次求下深度，不超过1，就是平衡二叉树
  + 作者思路：**后序遍历**，这样遍历到某个结点时，已经遍历过了其左右子树，只需要记录它的深度，然后对比一下（**分左右**），*lionel，感觉作者写的代码里，`*pDepth`求值没啥意义啊*
+ d19：64、求1+2+...+n，不能用乘除法、for、while、switch及条件判断语句（A?B:C）
  + 作者思路，**不让用循环和递归**，*不是太看懂，lionel*
    + 利用构造函数
    + 利用虚函数
    + 利用函数指针
    + 利用模板类型
+ d19：68I、树中两个节点的最低公共祖先  【二叉搜索树是可以找到的/普通的树，有没有指向根节点？】
+ d19：68II、
+ d28：37、序列化二叉树
+ d28：38、字符串的排列（abc）的组合
  + 作者思路：第一步，固定第1位，其它的进行组合，第二步，拿第1个与后面的逐个交换 **这个要学习一下**

### W3（0806-0812，17道）

#### W3.1、动态规划（10）

+ d8：10I、斐波那契数列
  + *lionel，再琢磨一下动规*
+ d8：10II、青蛙跳台阶问题
  + *自己想到的方案，是动规，但自己没想完善好，没有自洽好*
+ d8：63、股票的最大利润
  + 自己想法：蛮力，逐个比对，算一个最大值
  + **作者思路**，动规，*没有完全理解*
+ d9：42、连续子数组的最大和
  + 输入：[1,-2,3,10,-4,7,2,-5]，输出：[3,10,-4,7,2]
  + 自己思路：（蛮力），动态规划（遇到小于0，就等于当下这个值，然后每次求max）【f(i)=f(i-1)+data[i]】
  + 什么是**连续子数组**
  + 手抄的一些思路：
    + 递归的方式
    + 分析动态规划，*lionel，这种题，动态规划怎么做*
+ d9：47、礼物的最大价值
  + *两层for，然后画图，用两维的dp去实现，lionel*
+ d10：46、把数字翻译成字符串【0翻译成a，1翻译成b，25到z，这样12258，就有5种翻译】
  + *lionel，没完全想明白呢*
+ d10：48、最长不含重复字符的字符串
  + 自己想的只是：*最长的，都是从其它加上来的，怎么设计表达式?*
+ d29：19、正则表达式匹配
  + *lionel，这个没看呢*
+ d29：49、丑数 【包含2，3，5，**原数也是排序的**】
  + 自己思路：写个丑数判断函数，逐个判断
  + **作者思路**：定义一个丑数数组（**排好序**），这样每个丑数，都是前面的丑数乘以2，3，5相关的】
+ d29：60、n个sa子的点数【s的所有可能的值出现的概率】
  + *lionel，还没有想*

#### W3.2、双指针（3）

+ d13：21、调整数组顺序使奇数位于偶数前面
  + 自己想到的方案：就是first从头，last从尾指，然后遇到合适的就交换位置
+ d13：57I、和为s的数字（**排序**）
  + 自己想到的方案：first从头，last从尾，如果两者之和大于s，就移动last，之和小于s，就移动first
+ d13：58I、旋转字符串（从I am a student.  变成 student. a am I）
  + 自己想的是：直接用string的revert算法（*这个还达不成*），**然后还需要再翻转一下，句子的每个单词**

#### W3.3、排序（4）

+ d16：45、把数组排成最小数
  + *这个也不太会，lionel*
+ d16：61、扑克牌中的顺子（大小王看成任意数字）【随机抽5张】
  + 自己思路：先排序，看看有几个百搭，相邻数字的差，大于百搭的个数，就没有，**有对子的，肯定就不是顺子了**
+ d17：40、最小的k个数
  + 输入：[4,5,1,6,2,7,3,8]里最小的4个数是，输出：[1,2,3,4]
  + 自己思路：先排序，求倒数第k个
  + **学到的思路**，先构造k个数的数组，逐一去跟k个数组比较，直到
  + 还有别的思路：
    + Partition()排序
    + 红黑树
+ d17：41、数据流中的中位数
  + *lionel，这个没太懂*

### W4、（0813-0819，19道）

#### W4.1、分治算法（5）

+ d20：7、重建二叉树
  + 自己：不太会
+ d20：16、数值的整数次方
  + 自己：直接 相乘
+ d20：33、二叉搜索树的后序遍历序列
  + 自己：不太会
+ d30：17、打印从1到最大的n位数
  + 自己思路：直接for循环
+ d30：51、数组中的叛逆对
  + 自己思路：两层for，O(n方)，然后一个优化成双指针（*没完全想好*），想了一下，这种样子，其实还是O(n方)

#### W4.2、位运算（4）

+ d21：15、二进制中1的个数
  + 思路：转为二进制，一次次count
+ d21：65、不用加减乘除做加法
  + *不会*
+ d22：56I、数组中数字出现的次数
  + 自己思路：暴力
+ d22：56II、数组中数字唯一出现的次数
  + 自己思路：暴力

#### W4.3、数学（8）

+ d23：39、数组中次数超过一半的数字
  + 输入：[1,2,3,2,2,2,5,4,2]，输出：2 *次数超出了5次*
  + 自己想法：我现在肯定想用map来做
    + 当时的想法是排序，然后再遍历计一下count
  + 看到的思路：
    + 基于Partition，在某个数左边
+ d23：66、
+ d24：14I、
+ d24：57II、
+ d24：62、
+ d31：14II、
+ d31：43、1~n整数中1出现的次数
  + 自己思路：我好像没啥思路
  + 手抄的
    + 分析规律，去掉最高位的进行递归，*lionel，其实我没太想好*
+ d31：44、

#### W4.4、模拟（2）

+ d25：29、顺时针打印矩阵
  + 自己思路：题能看懂，思路还不一定完全可行，*代码更是写不来*
+ d25：31

### 最后

#### 过程

+ 2022年3月-4月，大概把第1版过了一遍题目，代码也基本只是抄，**没有真正的弄懂**

#### 自己心得

+ 如果写不出来，就干2件事
  + 1、用更抽象的语言去写，比如C++的string或一些算法，**自己有思路就行**
  + 2、如果思路都没有，就先**举例和分解**，先做对几种场景，或者用暴力的方法先解出后，再**想办法去优化**（因为分解后，就能慢慢找到具体优化哪一步了），**针对具体的地方优化**

#### ref（这些都不一定用得上）

+ [面试必刷-《剑指offer》刷题小结](https://zhuanlan.zhihu.com/p/56200260)

+ https://www.algomooc.com/ ， https://github.com/MisterBooo， 都是 吴师兄学算法
+ [《剑指offer》学习心得](https://doc.yonyoucloud.com/doc/wiki/project/for-offer/index.html)，人家的笔记，不过是用java写的，**胜在人家有ut**
+ https://github.com/Wang-Jun-Chao/coding-interviews  也是java的，解题可以去看他的csdn，blog
+ [剑指offer leetcode怎么刷](https://www.zhihu.com/question/271458173)  这是zhihu上的答案，自己有疑问时可以查查看