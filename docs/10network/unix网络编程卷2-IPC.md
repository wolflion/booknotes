## 《Unix网络编程卷2-IPC》

### 0

#### 目录

+ part1、简介（1-3）
+ Part2、消息传递(4-6)
+ Part3、同步（7-11）
  + [线程同步----信号量、互斥量、读写锁、条件变量](https://blog.csdn.net/IT_happy_/article/details/98962396)
    + *同步，也可以用队列实现，队头写，队尾读*
  + [操作系统的各种锁](https://blog.csdn.net/ZIMAJIM/article/details/108485331)
    + 互斥锁（使用步骤、保护临界区、任何时刻只有一个线程）
    + 读写锁（）
    + 条件变量（**不是锁**），*如果互斥锁，一旦加锁，其它线程都无法进入*
      + 条件满足，通知
      + 条件不满足，阻塞
    + 信号量
    + 自旋锁
    + 悲观锁与乐观锁
+ Part4、共享内存区（12-14）
+ Part5、远程过程调用（15-16）

### chap7、互斥锁与条件变量

#### 0、自己记的

+ 1、C++11的用法
  + `mutex m; m.lock(); m.unlock`
  + 怕忘记unlock，引入了**lock_guard**，`lock_guard<mutex> g(m);`，跟RAII一样，生存期 结束，会自己释放
  + unqiue_lock、try_lock、defer_lock，不太熟悉了
+ 2、问题1：互斥锁为何要引入条件变量？
  + 多生产者、消费者时，等待条件，通知条件

#### 7.1、概述

+ **同步**是为了允许在线程或进程间共享数据

#### 7.2、互斥锁：上锁与解锁

+ 任何时刻只有一个线程在执行其临界区的指令
+ pthread_mutex_t类型
  + 静态分配，`PTHREAD_MUTEX_INITIALIZER`
  + 动态分配，`pthread_mutex_init()`
+ 虽然互斥锁保护的是临界区，**实际上保护的是在临界中被操纵的数据**
+ 互斥锁是**协作锁**（cooperative）

#### 7.3、生产者-消费者问题

+ mutex/prodcons2.c
  + 里面的`set_concurrency()`是C++标准库的，不是pthread的，`pthread_setconcurrency()`才是

7.4、对比上锁与等待

+ mutex/prodcons3.c

#### 7.5、条件变量：等待与信息发送

+ 互斥锁用于**上锁**，**条件变量，则用于等待**，**每个条件变量总是有一个互斥锁与之关联**
+ `pthread_cond_t`变量
+ `pthread_cond_wait()`，**这是等被其它线程激活**
+ `pthread_cond_signal()`，*这里的signal是啥？*，**等待条件变量的线程**（用于通知人家）

+ mutex/prodcons6.c

7.6、条件变量：定时等待与广播

7.7、互斥锁和条件变量的属性

#### 7.8、小结

### chap8、读写锁

#### 8.4、使用互斥锁和条件变量实现读写锁

### chap10、Posix信号量

#### 0、自己看到的

+ 信号量是种**睡眠锁**
+ 问题1、信号量与互斥锁的差异？
  + 二值信号量，就是互斥锁
  + 互斥锁：保护共享资源，二元值（锁定、非锁定）
  + 信号量：保护？ **多个状态，P、V操作**，信号量值为0时，P会阻塞线程，**P加1，V减1**
+ 问题2：啥场景才用信号量处理同步问题？

#### 10.1、概述

### chap15、门

#### 0、自己的问题

+ 1、为啥称远程过程用为门，*没找到更好的，只是说像门一样，一种程序调用另一种程序*
+ 2、学习RPC需要什么背景知识，*除了通用的外，就是说分布式系统、RPC框架*（gRPC，Thrift，ZeroMQ）
+ 3、PRC带来的问题
  + a、call ID映射，本地有函数指针
  + b、序列化，本地用栈
  + c、网络传输，一般用TCP，也有用HTTP2的

#### 15.1、概述