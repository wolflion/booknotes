## 《数据结构与算法分析》C++语言描述4th

+ https://github.com/juejian/Data-Structures-and-Algorithm-Analysis-in-Cpp-4th

+ 我自己有一本纸质的，C语言描述2nd，*2者结合着看*

### chap1、程序设计：综述

#### 1.1、本书讨论的内容

+ 一、选择问题，topK（N个数确定其中第k个最大者）
  + 方法1：先排序
  + 方法2：先读前k个，然后再逐个对比，大于k的话，就把最后一个元素挤出去
+ 二、字谜（二维数组和单词表）
  + 方法1：
  + 方法2：

#### 1.2、数学知识复习

1.2.1、指数（exponent）

1.2.2、对数（logarithm）

1.2.3、级数（series）

1.2.4、模运算（modular arithmetic）

##### 1.2.5、证明方法

#### 1.3、递归简论

+ 递归的4条基本法则：
  + 1、基准情形
  + 2、要有进展  递归时，**每一次递归调用都必须要使状况朝向一种基准情形推进**
  + 3、设计法则
  + 4、合成效益法则（compound interest rule） **在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作**

#### 1.5、C++细节

##### 1.5.1、指针（pointer）

##### 1.5.2、左值、右值和引用

1.5.3、参数传递

1.5.4、返回值传递

1.5.5、std::swap和std::move

1.5.6、五大函数：析构、拷贝构造、移动构造、拷贝赋值operator=、移动赋值operator=

#### 1.6、模板

1.6.1、函数模板

1.6.4、函数对象

1.6.5、类模板的分离式编译

#### 1.7、使用矩阵

1.7.1、数据成员、构造函数和基本访问函数

1.7.2、operator[]

1.7.3、五大函数

#### 小结

### chap2、算法分析

2.1、数学基础

2.2、模型

2.3、要分析的问题

#### 2.3、要分析的问题

+ **最大子序列和问题**（leetcode42、可以用动态规划实现）
  + `Q(list,i)=max(0,Q(list,i-1)+list[i])`

#### 2.4、运行时间计算

### chap3、线性表、栈和队列  77/254

#### 3.1、抽象数据类型（ADT）

+ ADT是**带有一组操作的一些对象的集合**

#### 3.2、线性表ADT

+ 有哪些操作？

##### 3.2.1、线性表的简单数组实现

+ vector

##### 3.2.2、简单链表

+ linked list
+ doubly linked list

#### 3.3、STL中的vector和list

##### 3.3.1、迭代器

+ 获取迭代器
+ 迭代器方法
+ 需要迭代器的容器操作

##### 3.3.2、例子：对表使用erase

##### 3.3.3、const_iterators

#### 3.4、vector的实现

#### 3.5、list的实现

#### 3.6、栈ADT

+ **只能在一端操作**，只能在表的末端，就**栈顶**（top）

##### 3.6.1、栈模型

##### 3.6.2、栈的实现

+ 栈的链表实现
+ 栈的数组实现

##### 3.6.3、应用

+ 平衡符号
+ 后缀表达式
+ 中缀到后缀的转换
+ 函数调用

#### 3.7、队列ADT

+ 插入在一端，删除在另一端

##### 3.7.1、队列模型

+ **表的末端（队尾、rear）插入，叫入队；删除它们在（队头，front），叫出队**

##### 3.7.2、队列的数组实现

##### 3.7.3、队列的应用

#### 小结

#### 练习

### chap4、树   113/524

+ 二叉查找树的运行时间是O(logN)，set和map实现的基础

#### 4.1、预备知识

##### 4.1.1、树的实现

+ 树节点的声明

```cpp
struct TreeNode{
    Object element;
    TreeNode *firstChild;  //第一个孩子
    TreeNode *nextSibling;  //下一个兄弟
};
```



##### 4.1.2、树的遍历及应用

+ 先序
+ 后序

#### 4.2、二叉树

##### 4.2.1、实现

+ 二叉树节点类

```cpp
struct BinaryNode{
    Object element;   //节点上的数据
    BinaryNode *left;  //左儿子
    BinaryNode *right; //右儿子
};
```



##### 4.2.2、一个例子--表达式树

+ 构造一棵表达式树



+ 例5.4、编写一个函数，计算一棵二叉树的结点数。【*感觉要用递归啊，直到子节点时+1*】

#### 4.3、查找树ADT-二叉查找树

##### 4.3.1、contains

##### 4.3.2、findMin和findMax

##### 4.3.3、insert

##### 4.3.4、remove

##### 4.3.5、析构函数和拷贝构造函数

##### 4.3.6、平均情况分析

#### 4.4、AVL树（平衡树）

+ Adelson-Velskii和Landis，**带有平衡条件**
  + 每个节点的左子树和右子树的高度最多差1的二叉查找树

##### 4.4.1、单旋转

##### 4.4.2、双旋转

#### 4.5、伸展树

##### 4.5.1、一个简单的想法（不能直接使用）

##### 4.5.2、展开（splaying）

#### 4.6、树的遍历

+ 中序
+ 后序
+ 先序
+ 层序

#### 4.7、B树

#### 4.8、标准库中的容器set和map

##### 4.8.1、集合容器set

##### 4.8.2、映射容器map

##### 4.8.3、set和map的实现

##### 4.8.4、使用多个map的示例

#### 小结

+ 表达式树是更一般结构即所谓的**分析树（parse tree）**的一个小例子

#### 练习

#### 0、

+ 二叉树->满二叉树->二叉排序树（搜索树）【左边小于根，右边大于根】->平衡二叉树（AVL树）【左右子树的高度差1】->红黑树【根是黑的，子节点是黑的，红色结点有2个黑的，不能有连续2个红的】
+ leetcode上的题（114，116，226）

chap5、散列

### chap6、优先队列（堆）-209/524

+ 打印机按队列放任务并不一定是最好方案，**特别重要的任务**希望插个队，没办法做到

#### 6.1、模型

+ insert()，相当于入队
+ deleteMin()，相当于出队

#### 6.2、一些简单的实现

+ 方法1：表头O(1)插入，O(n)遍历找到最小者
+ 方法2：让链表保持排序状态，插入就需要O(n)
+ 方法3：**使用二叉查找树**，两者时间都是O(n logn)

#### 6.3、二叉堆

+ Q1：*这是个啥呢？利用AVL树？还是自己创的呢？* 【6.3.1解释了】

+ 二叉堆，简称为**堆**，有2个性质
  + 结构性
  + 堆序性

##### 6.3.1、结构性质

+ **堆**是一棵被完全填满的二叉树（完全二叉树）**因为它的规律性，就可以使用队列，而不需要使用链**
  + 对于位一位置i上的元素
    + 左孩子在2i上
    + 右孩子在2i+1上
    + 父亲在i/2取整上
+ **唯一的问题**，最大堆的大小需要事先估计，（可以重新调整堆）

##### 6.3.2、堆序性质

+ **最小单元应该在根上**，任意子树也是堆，性质就是**每一个节点X，X的父亲中的关键字小于（或等于）X中的关键字**。

##### 6.3.3、基本的堆操作

+ insert插入
  + 在下一个可用位置**创建一个空穴（hole）**，不破坏堆的性质，直接插入即可
  + 破坏了，就要找合适的位置，**与根的方向冒一步【叫上滤（percolate up）】**（就是与根节点交换），直到找到位置
  + *lionel，思路是懂了，但代码怎么写，不清楚*
+ deleteMin（删除最小元）
  + 找到比较简单，**删除就比较难**，创建一个空穴（hole）与子结点交换，满足性质即可
  + **附加题**，堆中存在偶数个元素时，将遇到一个节点只有一个儿子的情况。*后面没太看，也就没懂，lionel*

##### 6.3.4、其它的堆操作

+ 0
  + 上面实现的都只是**最小堆**
+ decreaseKey（降低关键字的值）
+ increaseKey（增加关键字的值）
+ remove（删除）
+ buildHeap（构建堆）
+ 定理6.1、

#### 6.4、优先队列的应用

##### 6.4.1、选择问题

##### 6.4.2、事件模拟

#### 6.5、d堆

+ d=2的时候是**二叉堆**，以此类推
+ 堆的合并比较难

6.6、左式堆

+ **区别**，左式堆不是理想平衡（perfectly balanced），实际上是趋向于**非常不平衡**

6.6.1、左式堆的性质

+ 定理6.2

6.6.2、左式堆操作

+ 合并

6.7、斜堆

6.8、二项队列

6.8.1、二项队列构建

6.8.2、二项队列操作

6.8.3、二项队列的实现

#### 6.9、标准库中的优先队列

+ `priority_queue`类模板，头文件是`queue.h`，**STL实现的是，最大堆（max-heap）而不是最小堆（min-heap）**
  + push
  + top
  + pop
  + empty
  + clear

#### 小结

#### 练习

### chap7、排序  245/524

+ 存在O(n平方)的排序，比如插入
+ 希尔也是O(n平方)，*缩小增量*
+ 稍微复杂的O(n logn)的排序算法

#### 7.1、预备知识

+ 基于比较的排序

#### 7.2、插入排序

+ *自己心得*，第几趟就是前面第几次已经排好序了，具体实现呢，**就是把新的值，插入到前面排好序的合适位置**

##### 7.2.1、算法

+ *个人思考，其实是两层*
  + 外层 是数组大小（for到a.size()）
  + 内层 是把第i轮前面的都要保证有序
+ 以34，8，64，51，32，21取例，看外层的话，需要移动位置数是多少，*代码实现上与C差不多*
  + **自己要画一个图，来推衍一下排序的过程** 【*说明我没有真懂，lionel*】**核心是，第几趟，第几个位置的前面都是排好序的**【也就是把新来的元素，插入到前面已经排好序的里面去，lionel】
  + 第1趟后：8，34，64，51，32，21，【*8和34是排序的*，移动1次】
  + 第2趟后：8，34，64，51，32，21，【*8，34，64是排序的*，移动0次】
  + 第3趟后：8，34，51，64，32，21，【*以此类推*，移动1次】
  + 第4趟后：8，32，34，51，64，21，【*以此类推*，移动3次】
  + 第5趟后：

```c++
template<typename Compareble>
void insertionSort(vector<Comparable> &a){
    for(int p=1;p<a.size();++p){
        Compareable tmp = std::move(a[p]);
        int j;
        for(j=p;j>0&&tmp<a[j-1];--j){
            a[j]=std::move(a[j-1]);
        }
        a[j]=std::move(tmp);
    }
}
```



##### 7.2.2、插入排序的STL实现

##### 7.2.3、插入排序的分析

#### 7.3、一些简单排序算法的下界

+ 逆序数
+ 定理7.1、**N个互异元素的数组的平均逆序数是N(N-1)/4
+ 定理7.2、

#### 7.4、希尔排序

##### 7.4.1、希尔排序的最坏情形分析

+ 定理7.3、
+ 定理7.4、

#### 7.5、堆排序

+ *lionel，我不太明白，作者想表达啥*

##### 7.5.1、堆排序的分析

#### 7.6、归并排序

##### 7.6.1、归并排序的分析

#### 7.7、快速排序

##### 7.7.1、选取枢纽元

+ 一种错误的方法
+ 一种安全的做法
+ 三数中值分割法

##### 7.7.2、分割策略

##### 7.7.3、小数组

##### 7.7.4、实际的快速排序例程

##### 7.7.5、快速排序的分析

+ 最坏情形的分析
+ 最好情形的分析
+ 平均情形的分析

##### 7.7.6、选择问题的线性期望时间算法

#### 7.8、排序算法的一般下界

##### 7.8.1、决策树

+ 引理7.1、
+ 引理7.2、
+ 定理7.6、
+ 定理7.7、

#### 7.9、选择问题的决策树下界

#### 7.10、对手下界

#### 7.11、线性时间排序：桶式排序和基数排序

#### 7.12、外部排序

chap8、不相交集类

### chap9、图论算法

### chap10、算法设计技巧

#### 10.1、贪婪算法（greedy algorithm）

+ 3个应用：Dijkstra、Prim、Kruskal
+ 贪婪算法**分阶段地工作**，在每个阶段，可以认为所作决定是好的，而不考虑将来的后果，**局部的最优**
+ 一些例子
  + 货币找零钱
  + 交通问题
+ 本节的应用例子
  + 简单的调度问题
  + 处理文件压缩
  + 贪婪近似算法

##### 10.1.1、一个简单的调度问题

##### 10.1.2、哈夫曼编码

##### 10.1.3、近似装箱问题

#### 10.2、分治算法

+ 分治算法（divide and conquer）两部分组成：
  + 分（divide）：递归解决较小的问题
  + 治（conquer）：然后，从子问题的解构建原问题的解

10.2.1、分治算法的运行时间

10.2.2、最近点问题

##### 10.2.3、选择问题

##### 10.2.4、一些算术问题的理论改进

#### 10.3、动态规划

+ 把子问题的答案系统地记录在一个表内

##### 10.3.1、用表代表递归

10.3.2、矩阵乘法的顺序安排

10.3.3、最优二叉查找树

10.3.4、所有点对最短路径

#### 10.4、随机化算法

10.4.1、随机数发生器

10.4.2、跳跃表

10.4.3、素性测试

#### 10.5、回溯算法

+ 本质是个穷举，但可以删除明显不合适的。
+ **在一步内删除一大组可能性的做法**叫裁剪（pruning）
+ 举了2个例子
  + 计算几何中的问题
  + 国际象棋和西洋跳棋的对弈，如何选取行棋的步骤

##### 10.5.1、收费公路重建问题（turnpike reconstruction problem）

##### 10.5.2、博弈

chap11、摊还分析

chap12、高级数据结构及其实现