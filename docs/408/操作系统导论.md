## 《操作系统导论》

+ Part1、虚拟化
  + 虚拟化CPU（3-11）
  + 虚拟化内存（12-24）
+ PartII：Concurrency并发（25-34）
+ Part3、持久性（35-）

### chap13、抽象:地址空间

#### 13.1、早期系统

+ 没有抽象

#### 13.2、多道程序和时分共享

+ **分时共享的方法**，让一个进程单独占用全部内存一小段时间，然后停止它，并将它所有状态信息保存在磁盘上

#### 13.3、地址空间

+ address space，**运行的程序看到的系统中的内存**

#### 13.4、目标

+ 一个目标是**透明**，运行的程序不感知
+ 另一个目标是**效率**，尽可能高效，有时不得不依赖硬件
+ 第三个目标是**保护**，不受其他进程影响，操作系统本身也不会受进程影响

#### 13.5、小结

### chap14、插叙：内存操作API

#### 14.1、内存类型

+ 栈内存，由编译器隐式管理
+ 堆内存，程序员显式调用

#### 14.2、malloc()调用

#### 14.3、free()调用

#### 14.4、常见错误

+ 忘记分配内存
+ 没有分配足够的内存
+ 忘记释放内存
+ 在用完之前释放内存
+ 反复释放内存
+ 错误地调用free()
+ 忘记初始化分配的内存
+ 小结
  + 利用`purify`和`valgrind`工具

#### 14.5、底层操作系统支持

+ malloc和free是库调用，不是系统调用，`brk()`或`sbrk()`才是系统调用。
+ `mmap()`调用从操作系统获取内存

#### 14.6、其他调用

+ `calloc()`和`realloc()`

#### 14.7、小结

### chap15、机制：地址转换

#### 0、

#### 15.1、假设

+ 先假设用户的地址空间必须连续地放在物理内存中
+ 假设每个地址空间大小完全一样

#### 15.2、一个例子

+ **理解地址转换需要什么**

#### 15.3、动态（基于硬件）重定位

+ 基址加虚拟地址（可以看作是地址空间的偏移量）的方式，很容易得到物理地址。**虚拟地址“过大”或者为负数时，会导致异常**

#### 15.4、硬件支持：总结

+ 特权模式（privileged mode）也叫**内核模式**
+ 用户模式

#### 15.5、操作系统的问题

#### 15.6、小结

+ **地址转换（address translation），扩展了受限直接访问的概念**
+ 利用地址转换，操作系统可以控制进程的所有内存访问，确保访问在地址空间的界限内
+ **避免内存碎片**，得到了**分段（segmentation）的概念**

### chap16、分段

#### 0、

+ 之前，一直假设把所有进程的地址空间完整地加载到内存中。
+ **怎样支持大地址空间**

#### 16.1、分段：泛化的基址/界限

+ **在典型的地址空间里有3个逻辑不同的段：代码、栈和堆**
+ 分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中的未使用部分占用物理内存

#### 16.2、我们引用哪个段

+ 硬件在地址转换时使用段寄存器。**它如何知道段内的偏移量，以及地址引用了哪个段？**

#### 16.3、栈怎么办

#### 16.4、支持共享

#### 16.5、细粒度与粗粒度的分段

#### 16.6、操作系统支持

+ 分段带来的问题:
  + 第一个是，**操作系统在上下文切换时应该做什么？**各个段寄存器中的内容必须保存和恢复
  + 第二个是，**管理物理内存的空闲空间**

#### 16.7、小结

+ **分段的好处是：代码共享**

chap17、空闲空间管理

chap18、分页：介绍

chap19、分页：快速地址转换（TLB）

chap20、分页：较小的表

chap21、超越物理内存：机制

chap22、超越物理内存：策略

### chap23、VAX/VMS虚拟内存系统

### chap24、内存虚拟化总结对话

#### chap25、并发的对话

+ 吃一个桃子？

#### chap26、并发：简介

##### 26.3、问题的核心：自由安排

##### 26.4、原子性

#### chap27、插曲：线程API

##### 27.1、线程创建

##### 27.2、线程完成

+ 如果你想等待线程完成，会发生什么情况？你需要做一些特别的事情来等待完成。

+ `pthread_join(pthread_t, )`
  + 第1个参数，用于指定要等待的线程
  + 第2个参数，指向你希望得到的返回值

##### 27.3、锁

+ 通过**锁来互斥进入临界区**的那些函数

##### 27.4、条件变量

+ **当线程之间必须发生某种信号时，如果一个线程在等待另一个线程继续执行某些操作**，条件变量就很有用。
+ **要使用条件变量，必须另外有一个与此条件相关的锁**。
+ `int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);`**使调用线程进入休眠状态**，因此等待其它线程发出信号，通常当程序中的某些内容发生变化时，现在正在休眠的线程可能会关心它。

##### 27.5、编译和运行

+ 增加`-pthread`标记，例：`gcc -o main main.c -Wall -pthread`

##### 27.6、小结

+ `man -k pthread`
+ **线程难的部分不是API，而是如何构建并发程序的棘手逻辑**。

#### chap28、锁

##### 28.1、锁的基本思想

+ 锁为程序员提供了最小程度的调度控制。通过给临界区加锁，可以保证临界区内只有一个线程活跃。**锁将原本由操作系统调度的混乱状态变得更为可控**。

```c++
lock_t mutex;//some globally-allocated lock 'mutex'
...
lock(&mutex);
balance = balance + 1;
unlock(&mutex);
```

##### 28.2、pthread锁

+ POSIX库将锁称为**互斥量（mutex）**，因为它被用来提供线程之间的互斥。即当一个线程在临界区，它能够阻止其他线程进入直到本线程离开临界区。

##### 28.3、实现一个锁

+ 怎样实现一个锁？
+ **我们需要硬件和操作系统的帮助来实现一个可用的锁**。

##### 28.4、评价锁

##### 28.5、控制中断

##### 28.6、测试并设置指令（原子交换）

##### 28.7、实现可用的自旋锁

##### 28.8、评价自旋锁

##### 28.9、比较并交换

##### 28.10、链接的加载和条件式存储指令

##### 28.11、获取并增加

##### 28.12、自旋过多：怎么办

##### 28.13、简单方法：让出来吧，宝贝

##### 28.14、使用队列：休眠替代自旋

##### 28.15、不同操作系统，不同实现

##### 28.16、两阶段锁

##### 28.17、小结

#### chap29、基于锁的并发数据结构

##### 29.1、并发计数器

##### 29.2、并发链表

##### 29.3、并发队列

##### 29.4、并发散列表

##### 29.5、小结

#### chap30、条件变量

##### 30.1、定义和程序

##### 30.2、生产者/消费者（有界缓冲区）问题

##### 30.3、覆盖条件

#### chap31、信号量

##### 31.1、信号量的含义

##### 31.2、二值信号量（锁）

##### 31.3、信号量用作条件变量

##### 31.4、生产者/消费者（有界缓冲区）问题

##### 31.5、读者-写者锁

##### 31.6、哲学家就餐问题

##### 31.7、如何实现信号量

##### 31.8、小结

#### chap32、常见并发问题

##### 32.1、有哪些类型的缺陷

##### 32.2、非死锁缺陷

##### 32.3、死锁缺陷

##### 32.4、小结

#### chap33、基于事件的并发（进阶）

##### 33.1、基本想法：事件循环

##### 33.2、重要API：select()（或poll()）

##### 33.3、使用select()

##### 33.4、为何更简单？无须锁

##### 33.5、一个问题：阻塞系统调用

##### 33.6、解决方案：异步I/O

##### 33.7、另一个问题：状态管理

##### 33.8、什么事情仍然很难

#### chap34、并发的总结对话

### 

#### chap35、关于持久性的对话

## 履历

+ 2022年27W（7.5-7.）看Part2并发的chap26，但习题没做和练习，只是有个概念