## 《深入理解Linux内核》

### chap3、进程

#### 3.1、进程、轻量级进程、线程

#### 3.2、进程描述符

##### 0、

##### 3.2.1、进程状态

+ state字段

##### 3.2.2、标识一个进程

+ 0
  + pid字段，**pidmap-array位图来表示当前已分配的PID号和闲置的PID号**
+ 3.2.2.1、进程描述符处理
+ 3.2.2.2、标识当前进程
+ 3.2.2.3、双向链表
+ 3.2.2.4、进程链表
+ 3.2.2.5、TASK_RUNNING状态的进程链表

##### 3.2.3、进程间的关系

+ 0
+ 3.2.3.1、pidhash表及链表

##### 3.2.4、如何组织进程

+ 0
+ 3.2.4.1、等待队列
+ 3.2.4.2、等待队列的操作

##### 3.2.5、进程资源限制

+ `current->signal->rlim`字段

#### 3.3、进程切换

##### 3.3.1、硬件上下文

##### 3.3.2、任务状态段

+ 0
+ 3.3.2.1、thread字段

##### 3.3.3、执行进程切换

##### 3.3.4、保存和加载FPU、MMU及XMM寄存器

+ 0
+ 3.3.4.1、保存FPU寄存器
+ 3.3.4.2、装载FPU寄存器

#### 3.4、创建进程

##### 0、

+ *lionel，OS是怎么样的？*（shell创建一个新进程，新进程执行shell的另一个拷贝）

+ 传统的Unix操作系统

+ 现代Unix的引入三种机制
  + 写时复制技术，允许父子进程读相同的物理页。**两者任一试图写一个物理页，内核就把这个页的内容拷贝到一个新的物理页**
  + 轻量级进程
  + vfork()创建的进程能共享父进程的内存地址空间

##### 3.4.1、clone()、fork()及vfork()系统调用

+ 0
  + 轻量级进程是由名为clone()的函数创建的
  + fork()在Linux中是用clone()实现的
  + vfork()在Linux中也是用clone()实现的
+ 3.4.1.1、do_fork()函数
  + **主要步骤**
+ 3.4.1.2、copy_process()函数
  + **主要步骤**

##### 3.4.2、内核线程

+ 0
  + **内核线程不受不必要的用户态上下文的拖累**
+ 3.4.2.1、创建一个内核线程
  + `kernel_thread()`
+ 3.4.2.2、进程0
  + **所有进程的祖先**
+ 3.4.2.3、进程1
  + init()调用execve()系统调用装入可执行程序init。结果，**init内核线程变为一个普通进程**
+ 3.4.2.4、其他内核线程

#### 3.5、撤销进程

##### 3.5.1、进程终止

+ 3.5.1.1、do_group_exit()函数
+ 3.5.1.2、do_exit()函数

##### 3.5.2、进程删除

### chap4、中断和异常

4.1、中断信号的作用