## 《算法4th》

+ 书上的chap1基础是java，我尽量想用C++给整一下
+ chap2
  + 2.1、初级排序（选择【简单选择、堆】、插入【直接插入，shell】、交换【冒泡、快排】），**快排、堆**单独弄一习来讲了
  + 2.2、归并排序（自顶向下、自底向上，**跟单次的merge实现没关系**，无非是怎么组织`merge-sort()`而已）
  + 2.3、快排
  + 2.4、堆（优先队列）

### chap1、基础

#### 1.1、基础编程模型

##### 1.1.3、语句

+ 声明语句
+ 赋值语句
+ 条件语句
+ 循环语句
  + break，**从循环中退出**
  + continue，**下一轮循环**
+ 调用的返回语句

##### 1.1.4、数组

##### 1.1.8、字符串

##### 1.1.9、输入输出

##### 1.1.10、二分查找

+ 用C++实现、用例、性能

##### 答疑&练习&提高题

#### 1.2、数据抽象

+ ADT，用`class`或`struct`关键字，**向用例隐藏内部表示的数据类型**

##### 1.2.1、使用抽象数据类型

##### 1.2.2、抽象数据类型举例

##### 1.2.3、抽象数据类型的实现

+ 构造函数

##### 1.2.4、更多抽象数据类型的实现

##### 1.2.5、数据类型的设计

###### 1.2.5.1、封装

###### 1.2.5.5、接口继承与实现继承

+ [C++中区别接口继承与实现继承](https://blog.csdn.net/YinShiJiaW/article/details/99940566)
  + **C++不太区分**，整体是一套
  + 不继承实现，只继承方法接口，就用**纯虚函数**
  + 继承方法接口，以及默认实现，**虚函数**
  + 继承方法接口，以及默认实现，**普通函数**

##### 答疑&练习&提高题

#### 1.3、背包、队列和栈

##### 1.3.1、API

###### 1.3.1.4、Bag

+ **不支持从中删除元素的集合数据类型**

##### 13.2、集合类数据类型的实现

##### 13.3、链表

##### 13.4、综述

+ 以介绍的数据结构为基石
+ 展示数据结构和算法的关系
+ 若干算法的实现重点

##### 答疑&练习&提高题

#### 1.4、算法分析

1.4.1、科学方法

1.4.2、观察

1.4.3、数学模型

1.4.4、增长数量级的分类

1.4.5、

1.4.6、

1.4.7、注意事项

##### 1.4.8、处理对于输入的依赖

1.4.9、内存

##### 答疑&练习&提高题

#### 1.5、案例研究：union-find算法

##### 1.5.1、动态连通性

1.5.2、

##### 1.5.3、展望

##### 答疑&练习&提高题

### chap2、排序  152（163/647）

#### 2.1、初级排序

##### 2.1.1、游戏规则

##### 2.1.2、选择排序

+ **重复的从待排元素中选出最大者或 最小者**
  + 我之前一般都是*存元素*，这里存的是下标

```cpp
void SelectSort(vector<int> nums){
    int len = nums.size();
    for(int i=0;i<len;i++){
        //将a[i]与a[i+1...len]中最小元素交换
        int min = i;//最小元素的索引
        for(int j=i+1;j<len;j++){
            if(less(a[j],a[min]))//这个less的写法，自己要会,lionel
                min=j;
        }
        exch(a,i,min);
    }
}
```



##### 2.1.3、插入排序

+ **为了腾空间，其它元素在插入之前都向右移动一位**

```cpp
void InsertSort(vector<int> nums){
    //按升序排列
    int lne = nums.size();
    for(int i=0;i<len;i++){
        //nums[i]插入到a[i-1],a[i-2],a[i-3]...之中
        for(int j=i;j>0&&less(a[j],a[j-1]);j--)
            exch(a,j,j-1);//lionel,我没看到哪个是往右移的，这也是种交换啊，难道是逐个交换？
    }
}
```



+ **部分有序**的场景

##### 2.1.4、插入排序的可视化

##### 2.1.5、比较两种排序算法

+ 用`time()`函数

##### 2.1.6、希尔排序

+ **基于插入排序的快速排序**
+ 使数组中任意间隔为h的元素都是有序的，**插入排序中移动元素的距离由1改为h即可**
+ 问题：**如何选择递增子序列？**

```java
public static void sort(Comparable[] a){
    //将a[]按升序排列
    int N = a.length;
    int h = 1;
    while(h<N/3) h=3*h+1;//这是啥意思？lionel
    while(h>=1){
        //将数组变为h有序
        for(int i=h;i<N;i++){
            for(int j=i;j>=h &&less(a[j],a[j-h]);j-=h){
                exch(a,j,j-h);
            }
        }
        h=h/3;  //lionel，为啥要除以3？
    }
}
```



##### 答疑&练习&提高题

+ 为什么有这么多排序算法？
+ 2.1.2、在选择排序中，一个元素最多可能会被交换多少次？平均可能会被交换多少次？

+ 2.1.19、希尔排序的最坏情况
+ 2.1.20、希尔排序的最好情况
+ 2.1.35、**不均匀的概率分布**。编写一个测试用例，使用非均匀分布的概率来生成随机排列的数据，包括：，评估并验证这些输入数据对本节讨论的算法的性能的影响
  + 高斯分布
  + 泊松分布
  + 几何分布
  + 离散分布

#### 2.2、归并排序

+ **两个有序的数组归并成一个更大的数组**，NlogN，需要额外的空间
+ **先递归的分成两半分别排序，然后将结果归并起来**

##### 2.2.1、原地归并的抽象方法

+ 创建一个数组，将原数组从小到大放入。

```java
public static void merge(Compable[] a, int lo, int mid, int high){
    //将a[lo...mid]和a[mid+1...hi]归并
    int i=lo,j=mid+1;
    for(int k=lo;k<=hi;k++)
        aux[k]=a[k];//临时弄了个数组
    
    for(int k=lo;k<=hi;k++){ //lionel，没太懂啥意思
        if(i>mid)
            a[k]=aux[j++];
        else if(j>hi)
            a[k]=aux[i++];
        else if(less(aux[j],aux[i]))
            a[k]=aux[j++];
        else
            a[k]=aux[i++];
    }
}
```



##### 2.2.2、自顶向下的归并排序

+ *没理解*

##### 2.2.3、自底向上的归并排序

+ *没理解*

```java
public class MergeBu{
    private static Comparable[]  aux;//归并所需的辅助数组
    
    public static void sort(Comparable[] a){
        //进行lgN次两两归并
        int N=a.length;
        aux=new Comparable[N];
        for(int sz=1;sz<N;sz=sz+sz)  //sz:子数组大小
            for(int lo=0;lo<N-sz;lo+=sz+sz) //lo:子数组索引
                merge(a,lo,lo+sz-1,Math.min(lo+sz+sz-1,N-1));
    }
}
```



##### 2.2.4、排序算法的复杂度

#### 2.3、快速排序

+ Nlog2N（2为底）

##### 2.3.1、基本算法

+ **是一种分治排序算法**，2个子数组有序那么整个数组自然就有序了

###### 2.3.1.1、原地切分

###### 2.3.1.2、别越界

###### 2.3.1.3、保持随机性

###### 2.3.1.4、终止递归

##### 2.3.2、性能特点

##### 2.3.3、算法改进

#### 2.4、优先队列

##### 2.4.1、API

##### 2.4.2、初级实现

##### 2.4.3、堆的定义

+ 当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为**堆有序**

##### 2.4.4、堆的算法

###### 2.4.4.1、由下至上的堆有序变化（上浮）

###### 2.4.4.2、由上至下的堆有序变化（下沉）

###### 2.4.4.3、多叉堆

##### 2.4.5、堆排序

###### 2.4.5.1、堆的构造

#### 2.5、应用

##### 2.5.1、将各种数据排序

##### 2.5.2、我应该使用哪种排序算法

##### 2.5.3、问题的归纳

##### 2.5.4、排序应用一览

#### lionel自己想的

+ 3大排序
  + 选择（找最小的），**用数组下标**
    + 拿第1个元素与后面的元素挨个比较
  + 插入（插入到直接有序的）
    + shell排序
  + 交换（冒泡，两两互换）*要想一下这个过程*
    + 第一趟，能交换到一个最大值在最后个（中间会比较0-n次）
    + 第二趟，只需要交换0到n-1次了
  + [交换排序与选择排序的区别（附C语言实现）](https://blog.csdn.net/weixin_43986898/article/details/104519207)

### chap3、查找  227（238/647）

#### 3.1、符号表

3.2、二叉查表树

3.3、平衡查找树

3.4、散列表

3.5、应用

### chap4、图 329（340/647）

+ 例子
+ 依次学习4种最重要的图模型
  + 无向图（简单连接）
  + 有向图（连接有方向性）
  + 加权图（连接带有权值）
  + 加权有向图（连接既有方向性又带有权值）

#### 4.1、无向图

+ **图**，由一组顶点和一组能够将两个**顶点**（vertex）相连的**边**（edge）组成的
+ 特殊的图
  + **自环**：一条连接一个顶点和其自身的边
  + 连接同一对顶点的两条边称为**平行边**

##### 4.1.1、术语表

+ **子图**，由一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图
+ **路径**：由边顺序连接的一系列顶点。**简单路径**是一条没有重复顶点的路径。
+ **环**，是一条至少含有一条边且起点和终点相同的**路径**。*也就说，环至少是个路径，lionel*
+ **连通图**，从任意一个顶点都存在一条路径到达另一个任意顶点。一幅**非连通的图**由若干连通的部分组成，它们都是其极大连通子图
+ **树**是一幅无环连通图，连通图的**生成图**是它的一幅子图，它含有图中的所有顶点且是一棵树。

##### 4.1.2、表示无向图的数据类型

###### 4.1.2.1、

###### 4.1.2.2、邻接表的数据结构

4.1.2.3、图的处理算法的设计模式

##### 4.1.3、深度优先搜索

###### 4.1.3.1、走迷宫

4.1.3.5、

##### 4.1.4、寻找路径

###### 4.1.4.1、实现

4.1.4.2、详细轨迹

##### 4.1.5、广度优先搜索

+ 单点最短路径（BFS）

##### 4.1.6、连通分量

+ DFS的应用

###### 4.1.6.1、实现

###### 4.1.6.2、union-find算法

##### 4.1.7、符号图

###### 4.1.7.1、API

4.1.7.2、测试用例

4.1.7.3、实现

##### 4.1.8、总结

#### 4.2、有向图

+ 有向图中，**边是单向的**

##### 4.2.1、术语

+ **有向图**，由一组顶点和一组有方向的边组成的，每条有方向的边都连接着有序的一对顶点

##### 4.2.2、有向图的数据类型

##### 4.2.3、有向图中的可达性

###### 4.2.3.2、有向图的寻路

##### 4.2.4、环和有向无环图

##### 4.2.5、有向图中的强连通性

+ 如果两个顶点v和w是互相可达的，则称它们为**强连通**的，如果任意两个顶点都是强连通的，则称这幅**有向图也是强连通的**

###### 4.2.5.1、强连通分量

+ 性质：
  + 自反性
  + 对称性
  + 传递性

4.2.5.2、应用举例

4.2.5.3、Kosaraju算法

4.2.5.4、再谈可达性

##### 4.2.6、总结

#### 4.3、最小生成树

+ **图的生成树**，它的一棵含有其所有顶点的无环连通子图

##### 4.3.1、原理

###### 4.3.1.1、切分原理

##### 4.3.2、加权无向图的数据类型

###### 4.3.2.1、用权重来比较边

4.3.2.2、平行边

4.3.2.3、自环

##### 4.3.3、用最小生成树的API和测试用例

##### 4.3.4、Prim算法

##### 4.3.5、Prim算法的即时实现

##### 4.3.6、Kruskal算法

##### 4.3.7、展望

#### 4.4、最短路径

##### 4.4.1、最短路径的性质

##### 4.4.2、加权有向图的数据结构

4.4.2.4、边的松弛

##### 4.4.3、最短路径算法的理论基础

###### 4.4.3.1、最优性条件

##### 4.4.4、Dijkstra算法

##### 4.4.5、无环加权有向图中的最短路径算法

##### 4.4.6、一般加权有向图中最短路径问题

###### 4.4.6.8、负权重环的检测

##### 4.4.7、展望

### chap5、字符串  451（/647）