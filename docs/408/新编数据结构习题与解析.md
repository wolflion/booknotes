## 《新编数据结构习题与解析》

+ chap11内排序（计划0821-0826完成的）

### chap11、内排序

#### 11.1、插入（直接插入、希尔）

```cpp
typedef struct {
    int key;//关键字
    int data;//其它数据
}SqList;
```



##### 11.1.1、知识点

+ 直接插入
  + 思路：**前面是有序的**

```cpp
void InsertSort(SqList R[], int len){
    SqList tmp;
    for(int i=1;i<n;i++){
        tmp = R[i];
        int j=i-1; //因为i前面是有序的，j指向有序区的最后一个元素
        while(j>=0 && R[j].key > tmp.key){   //lionel，里面的for循环，就是为了在 有序区，找插入位置
            R[j+1] = R[j];  //不断往后移
            j--;//不断减减，找到合适的插入位置
        }
        R[j+1] = tmp;//找到j后，再j+1，把tmp插入进去
    }
}
```



+ 折半插入
  + 想法是，**在前面的有序区间中，用折半查找的方法**，找到j的位置
+ 希尔
  + 又叫缩小增量，可以用2个函数，也可以在原来的 直接插入 外面套一个while循环
  + **与待排序数据的顺序有关**，正序时效率最高，反序时效率最低

```cpp
void ShellSort(SqList R[], int n) {  //n就是len
    SqList tmp;
    int d = n/2;
    while(d>0){ //lionel，相当于套了一层，一直循环到d=1为止
        for(int i=d;i<n;i++){  //对所有相隔d位置的元素组进行排序
            tmp = R[i];
            int j=i-d;  //lionel，所有的原先是1的地方，变成了增量d
            while(j>=0 && R[j].key>tmp.key){
                R[j+d] = R[j];
                j-=d;
            }
            R[j+d] = tmp;
        }
        d=d/2;
    }
}
```



##### 11.1.2、习题

###### 一、单选

+ 1、直接插入排序最好情况下时间复杂度是`O(n)`，*正序，里层的while循环不需要插入*
+ 2、对n个记录的表进行直接插入排序，在最坏情况下需比较`n(n-1)/2`
  + 我用的是排除法，肯定是O(n方)，只能选D
  + 真实的情况：第2次需要1次比较，第3次需要2次比较，....第n次需要n-1次比较
+ 3、稳定的排序算法是**直接插入排序**
  + 这个肯定是稳定的，*其它的选项不确定*
+ 4、{8,9,10,4,5,6,20,1,2}只能是**直接插入排序**算法的两趟排序后的结果
  + 两趟排序后的有序区，不是**全局有序**
+ 5、
+ 6、
+ 7、在初始序列已基本有序的情况下，排序效率最高的是**直接插入排序**
  + 我本来想的是**希尔排序**，但选项没有，*两个答案都是正确的*，如果是多选的话
+ 8、不稳定的排序算法是**希尔排序**（*其它选项，不确定*）
+ 10、

###### 二、填空

+ 11、
+ 12、
+ 13
+ 14、{Q,H,C,Y,Q,A,M,S,R,D,F,X}，关键字递增，初始步长为4，则第一趟的结果**,**。
  + *lionel，疑问点在于，布长，怎么计*【第1个就是1，然后数4个？】
+ 15、

###### 三、简答

+ 16、直接插入排序与希尔排序算法的不同
  + 直接插入排序，是**稳定的**，采用顺序查找时，也适用于链式存储
  + 希尔排序，是**不稳定的**，不适用于链式存储
+ 17、希尔排序每一趟都要调用若干次直接插入排序，为什么希尔排序还比直接插入排序算法效率更高。
  + **按近正序时**效率很高？*lionel，我感觉答案没写对啊？*
+ 18、
+ 19、
+ 20、写出{4,5,1,2,8,6,7,3,10,9}的直接插入排序过程
+ 21、写出{4,5,1,2,8,6,7,3,10,9}的希尔排序过程

###### 四、算法

+ 22、创建一个带头节点的单链表，设计一个直接插入排序对这个单链表进行递增排序
+ 23、
+ 24、

#### 11.2、选择（简单选择、堆-优先队列）

##### 11.2.1、知识点

+ 简单选择
  + **有序区的均小于无序区的**，每次从无序区找一个第小的与R[i]交换，这样R[0...i]都有序了

```cpp
void SelectSort(SqList R[], int n){ //n就是len
    SqList tmp;
    int k;  //用k指出最小的，为啥不直接用min？lionel
    for(int i=0;i<n;i++){
        k=i;//lionel，哨兵？
        for(int j=i+1;j<n;j++){ //两层for循环，从无序区找最小的
            if( R[k].key > R[j].key)
                k=j;//用k指出每趟在无序区的最小元素
            
            if(i!=k){  //R[k]与R[i]交换，lionel，为啥这个时候交换？【因为i会不断加加，相当于前面的都是排序的】
                tmp = R[i];
                R[i] = R[k];
                R[k] = tmp;
            }
        }
    }
}
```



+ 堆排序（优先队列）
  + 筛选算法？

```cpp
void Sift(SqList R[], int low, int high){  //把R[low...high]调整成堆
    int i=low,j=2*i;  //R[j]是R[i]的左孩子
    SqList tmp = R[i];
    
    while(j<=high){
        if(j<high && R[j].key < R[j+1].key)  //右孩子大，j指向右孩子
            j++;
        if(tmp.key<R[j].key){//双亲的根节点小于 孩子，需调整
            R[i] = R[j];  //R[j]调整到双亲结点上
            i=j;
            j=2*i;   //修改i和j，以便继续向下筛选  【lionel，就不太明白了】
        }else
            break;   //筛选结束
    }
    R[j]=tmp;  //被筛选节点的值，放入最终位置  【lionel，不太明白】
}


//建立堆
void HeapSort(SqList R[], int n){
    SqList tmp;
    int i;
    for(i=n/2;i>=1;i--)
        Sift(R,i,n);
    
    for(i =n;i>=2;i--){ //n-1次循环
        tmp = R[1];//每一个元素同当前区间内的R[1]对换
        R[1] = R[i];
        R[i] = tmp;
        Sift(R,1,i-1);  //lionel，其实还是不太懂
    }
}
```

