<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>《剑指offer专项突破》 - lionel的技术笔记</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u300a\u5251\u6307offer\u4e13\u9879\u7a81\u7834\u300b";
        var mkdocs_page_input_path = "91leetcode\\\u5251\u6307offer\u4e13\u9879\u7a81\u7834.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> lionel的技术笔记
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../01daily/">daily</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../02ds/">ds</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../03cpp/">cpp</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../21tool/">tool</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">C++</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/effectiveC%2B%2B/">《Effective C++》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">《深度探索C++对象模型》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/EffectiveSTL/">《Effective STL》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/C%2B%2B%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/">《C++泛型STL原理和应用》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">《STL源码剖析》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../22C%2B%2Bmodern/%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8C%2B%2B11/">《深入应用C++11》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">基础知识</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">《操作系统导论》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">《大话设计模式》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90_C%2B%2B4th/">《数据结构与算法分析_C++4th》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E7%AE%97%E6%B3%95%284th%29/">《算法4th》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%BC%A0%E5%86%9B/">《算法设计与分析-张军》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E5%A4%A9%E8%A1%8C-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《天行-算法设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B-%E6%9D%8E%E6%98%A5%E8%91%86/">《数据结构教程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../408/%E6%96%B0%E7%BC%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E4%B8%8E%E8%A7%A3%E6%9E%90/">《新编数据结构习题与解析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网络编程</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">《TCP/IP网络编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">《Linux高性能服务器编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71/">《TCPIP详解卷1》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90/">《Linux内核网络栈源代码情景分析》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C/">《深入理解Linux网络》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">文件系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/Linux%E5%86%85%E6%A0%B8%E6%8E%A2%E7%A7%98/">《Linux内核探秘》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《文件系统技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">《存储技术原理分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">存储</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../12storage/ceph%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《ceph设计原理与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">视频</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/FFmpeg%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">《FFmpeg入门到精通》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">《WebRTC权威指南》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AE%9E%E6%97%B6%E4%BA%92%E5%8A%A8%E6%8A%80%E6%9C%AF/">《WebRTC音视频实时互动技术》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/%E6%96%B0%E4%B8%80%E4%BB%A3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%A0%81%E6%A0%87%E5%87%86-H.264_AVC/">《新一代视频压缩码标准-H.264_AVC》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">内核</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《Linux内核设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/">《深入Linux设备驱动程序内核机制》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">《深入理解Linux虚拟内存管理》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《深入理解Linux网络技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90-tcpip%E5%AE%9E%E7%8E%B0/">《Linux内核源代码剖析-TCP/IP实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/">《深入理解Linux内核》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">工具</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/">《Wireshark网络分析实战》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%283rd%29/">《Linux命令行与shell脚本编程大全(3rd)》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%883rd%EF%BC%89/">《python程序设计（3rd）》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">刷题</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../%E5%89%91%E6%8C%87offer2nd/">《剑指offer2nd》</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">《剑指offer专项突破》</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#0">0</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_1">在其它地方刷过的题</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap11-5">chap1、整数（1-5）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#11">1.1、基础知识</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1">1、整数除法</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#12">1.2、二进制</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#2">2、二进制加法</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#3-n-1">3、前 n 个数字二进制中 1 的个数</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#4">4、只出现一次的数字</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#5">5、单词长度的最大乘积</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap26-13">chap2、数组（6-13）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#21">2.1、基础知识</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#22">2.2、双指针</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#6">6、排序数组中的两个数字之和</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#7-0-undo">7、数组中和为 0 的三个数，undo</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#8-target">8、和大于等于 target 的最短子数组</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#9-k">9、乘积小于 K 的子数组</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#23">2.3、累加数组数字求子数组之和</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#24">2.4、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap314-20">chap3、字符串（14-20）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#31">3.1、基础知识</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#32">3.2、双指针</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#14">14、字符串中的变位词</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#15">15、字符串中的所有变位词</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#16">16、不含重复字符的最长子字符串</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#17">17、包含所有字符的最短字符串</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#33">3.3、回文字符串</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#18">18、有效的回文</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#19">19、最多删除一个字符得到回文</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#20">20、回文子字符串的个数</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#31_1">3.1、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap421-29">chap4、链表（21-29）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_2">题目</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#22_1">22、链表中环的入口节点</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#24_1">24、反转链表</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap530-35">chap5、哈希（30-35）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_3">题目</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#32_1">32、有效的变位词</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap6">chap6、栈</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#61">6.1、基础知识</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#62">6.2、栈的应用</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#36">36、后缀表达式</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#37">37、小行星碰撞</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#38">38、每日温度</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#39">39、直方图最大矩形面积</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#40">40、矩阵中最大的矩形</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#63">6.3、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap741-46">chap7、队列（41-46）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#71">7.1、基础知识</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#72">7.2、队列的应用</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#41">41、滑动窗口的平均值</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#42">42、最近请求次数</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#43">43、在完全二叉树中添加节点</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#44">44、二叉树每层的最大值</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#45">45、二叉树最底层最左边的值</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#46">46、二叉树的右侧视图</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#73">7.3、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap8">chap8、树</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1_1">1、基础知识</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2_1">2、二叉树的深度优先搜索</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3">3、二叉搜索树</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4treesettreemap">4、TreeSet和TreeMap的应用</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap9">chap9、堆</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1_2">1、基础知识</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2_2">2、堆的应用</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap1062-">chap10、前缀树（62-）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#101">10.1、基础知识</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#62_1">62、实现前缀树</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#102">10.2、前缀树的应用</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#63_1">63、替换单词</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#64">64、神奇的字典</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#65">65、最短的单词编码</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#66">66、单词之和</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#67">67、最大的异或</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#103">10.3、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap11">chap11、二分查找</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1_3">1、基础知识</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2_3">2、在排序数组中二分查找</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3_1">3、在数值范围内二分查找</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap12">chap12、排序</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1_4">1、基础知识</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2_4">2、计数排序</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_4">快速排序</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_5">归并排序</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap1379-87">chap13、回溯法（79-87）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#131">13.1、基础知识</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#132">13.2、集合的组合、排列</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#79">79、所有子集</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#80-k">80、含有 k 个元素的组合</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#81">81、允许重复选择元素的组合</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#82">82、包含重复元素集合的组合</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#83">83、没有重复元素集合的全排列</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#84">84、包含重复元素集合的全排列</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#133">13.3、使用回溯法解决其他类型的问题</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#85">85、生成匹配的括号</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#86">86、分割回文字符串</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#87ip">87、复原IP</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#134">13.4、本章小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap1488-104">chap14、动态规划（88-104）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#141">14.1、基础知识</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#88">88、爬楼梯的最小成本</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#142">14.2、单序列问题</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#89">89、房屋被盗</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#90">90、环形房屋偷盗</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#143">14.3、双序列问题</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#144">14.4、矩阵路径问题</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#145">14.5、背包问题</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#101_1">101、分割等和子集</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#102_1">102、加减的目标值</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#103_1">103、最少的硬币数目</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#146">14.6、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap15105-119">chap15、图（105-119）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#151">15.1、基础知识</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#152">15.2、图的搜索</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_6">拓扑排序</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_7">并查集</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#155">15.5、小结</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../96output/OD%E5%9F%BA%E7%A1%80%E9%A2%98/">OD基础题</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../96output/OD%E8%BF%9B%E9%98%B6%E9%A2%98/">OD进阶题</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网课</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/01Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/">《Linux高并发网络编程开发》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/%E4%BE%AF%E6%8D%B7/%E4%BE%AF%E6%8D%B7C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8660%E8%AE%B2/">《侯捷C++内存管理60讲》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/11NJU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">《NJU算法设计与分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">英语专</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../60English/00794%E7%BB%BC%E5%90%88%E8%8B%B1%E8%AF%AD%E4%B8%80%E4%B8%8A/">《综合英语(一)上》</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">lionel的技术笔记</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>刷题 &raquo;</li>
      <li>《剑指offer专项突破》</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h2 id="offer">《剑指offer专项突破版》<a class="headerlink" href="#offer" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/422908736">滑动窗口详解</a><ul>
<li>https://leetcode.cn/circle/article/9gcJBk/</li>
</ul>
</li>
<li>chap8树，chap9堆，chap10前缀树、不熟悉（前2个还算看过，第3个根本不太了解）</li>
<li>https://github.com/doocs/leetcode/blob/main/lcof2/README.md</li>
<li>https://leetcode.cn/studyplan/coding-interviews-special/</li>
</ul>
<h3 id="0">0<a class="headerlink" href="#0" title="Permanent link">&para;</a></h3>
<h4 id="_1">在其它地方刷过的题<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h4>
<ul>
<li>5、单词长度的最大乘积</li>
</ul>
<h3 id="chap11-5">chap1、整数（1-5）<a class="headerlink" href="#chap11-5" title="Permanent link">&para;</a></h3>
<h4 id="11">1.1、基础知识<a class="headerlink" href="#11" title="Permanent link">&para;</a></h4>
<h5 id="1">1、整数除法<a class="headerlink" href="#1" title="Permanent link">&para;</a></h5>
<h4 id="12">1.2、二进制<a class="headerlink" href="#12" title="Permanent link">&para;</a></h4>
<h5 id="2">2、二进制加法<a class="headerlink" href="#2" title="Permanent link">&para;</a></h5>
<h5 id="3-n-1">3、前 n 个数字二进制中 1 的个数<a class="headerlink" href="#3-n-1" title="Permanent link">&para;</a></h5>
<h5 id="4">4、<a href="https://leetcode.cn/problems/WGki4K/?envType=study-plan&amp;id=lcof-ii&amp;plan=lcof&amp;plan_progress=x95pysw2">只出现一次的数字</a><a class="headerlink" href="#4" title="Permanent link">&para;</a></h5>
<ul>
<li><a href="https://leetcode-cn.com/problems/single-number-ii/">137</a></li>
<li>自己想到了hash，<em>但hash的用法，不太熟</em></li>
<li>参考链接：<strong>位运算</strong>的思路，<ul>
<li>https://blog.csdn.net/qq_32523711/article/details/108041437</li>
<li>https://www.jb51.net/article/217687.htm</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">//给你一个整数数组 nums ，除某个元素仅出现一次外，其余每个元素都恰出现三次。请你找出并返回那个只出现了一次的元素
//nums = [2,2,3,2]，返回3
int singleNumber(vector&lt;int&gt;&amp; nums) {
    map&lt;int,int&gt; val;
    for(auto i:nums){
        val[i]++;
    }

    for(auto c: nums){
        if(val[c] == 1){
           return c;
        }
    }
    return 0;
}</code></pre>
<h5 id="5">5、单词长度的最大乘积<a class="headerlink" href="#5" title="Permanent link">&para;</a></h5>
<ul>
<li><em>在其它地方刷过，但没用作者给的2个思路，用的是自己的</em></li>
</ul>
<ul>
<li>字符串数组words，保存的是"abcw","foo"，“bar”,"fxyz","abcdf"，因为"bar"和"foo"没有相同的字符，所以乘积是<code>3*3=9</code>，"abcw"和"fxyz"也没有相同的字符，乘积是<code>4*4=16</code>，所以最大值是16。<ul>
<li>自己思路是：两个for循环，找到没有相同的字符串</li>
<li>作者的给的思路1：<strong>用哈希表记录字符串中出现的字符</strong>。</li>
<li>作者的给的思路2：</li>
</ul>
</li>
</ul>
<h3 id="chap26-13">chap2、数组（6-13）<a class="headerlink" href="#chap26-13" title="Permanent link">&para;</a></h3>
<h4 id="21">2.1、基础知识<a class="headerlink" href="#21" title="Permanent link">&para;</a></h4>
<h4 id="22">2.2、双指针<a class="headerlink" href="#22" title="Permanent link">&para;</a></h4>
<ul>
<li>方向相反的双指针，用来求排序数组中的两个数字之和</li>
<li>方向相同的双指针，用来求正数数组中子数组的和或乘积</li>
</ul>
<h5 id="6">6、排序数组中的两个数字之和<a class="headerlink" href="#6" title="Permanent link">&para;</a></h5>
<ul>
<li>递增排序的数组和一个值k，找到两个和为k的数字并返回它们的下标？<ul>
<li><code>[1,2,4,6,10]</code>，k的值为8</li>
<li>思路：<code>left=0,right=array.size()</code>，right&gt;targe，right--; left+right&lt;target，left++，直到它们相等</li>
</ul>
</li>
</ul>
<h5 id="7-0-undo">7、<a href="https://leetcode.cn/problems/1fGaJU/?envType=study-plan&amp;id=lcof-ii&amp;plan=lcof&amp;plan_progress=x95pysw2">数组中和为 0 的三个数</a>，undo<a class="headerlink" href="#7-0-undo" title="Permanent link">&para;</a></h5>
<ul>
<li><a href="[leetcode.cn/problems/3sum/](https://leetcode.cn/problems/3sum/)">15</a><ul>
<li><strong>快排+对撞指针</strong>，2个我都不太熟悉（<em>为啥要排序</em>，之前觉得排序打乱输出位置了，其实最后并不会影响）</li>
<li>https://blog.csdn.net/weixin_44294809/article/details/106097652</li>
<li>https://blog.csdn.net/Innocence02/article/details/127427598</li>
<li>https://blog.csdn.net/weixin_45629285/article/details/117060550 【详细题解】</li>
<li>https://www.bilibili.com/video/BV1i3411R71x/?vd_source=66d6345790c729dfa0a136a5183762c9</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">//给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。
//输入：nums = [-1,0,1,2,-1,-4]
//输出：[[-1,-1,2],[-1,0,1]]
//lionel，先尝试看看能不能看懂，或真正理解了
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt; &gt; res;
        if(nums.size()&lt;3)//边界条件
            return res;

        sort(nums.begin(),nums.end());//对数组排序

        for(int k=0;k&lt;nums.size()-2;k++)
        {
            //当nums[k]&gt;0时直接跳出,因为nums[j]&gt;=nums[i]&gt;=nums[k]&gt;0,三数和必大于零
            if(nums[k]&gt;0)
                break;

            //当k&gt;0且nums[k]==nums[k-1]时跳过nums[k]：因为已经将nums[k-1]的所有组合加入到结果中，
            //本次搜索只会得到重复组合。
            if(k&gt;0 &amp;&amp; nums[k]==nums[k-1])
                continue;

            int i=k+1,j=nums.size()-1;//双指针
            while(i&lt;j)
            {
                int sum=nums[k]+nums[i]+nums[j];
                vector&lt;int&gt; temp;
                if(sum==0)
                {
                    temp.push_back(nums[k]);
                    temp.push_back(nums[i]);
                    temp.push_back(nums[j]);
                    res.push_back(temp);//将满足条件的组合存入结果
                    while(i&lt;j &amp;&amp; nums[i]==nums[++i]) ;//跳过重复的nums[i]
                    while(i&lt;j &amp;&amp; nums[j]==nums[--j]) ;//跳过重复的nums[j]
                }
                else if(sum&lt;0)
                {
                    while(i&lt;j &amp;&amp; nums[i]==nums[++i]) ;//跳过重复的nums[i]
                }
                else  //sum&gt;0
                {
                    while(i&lt;j &amp;&amp; nums[j]==nums[--j]) ;//跳过重复的nums[j]
                }
            }  
        }

        return res;
    }</code></pre>
<h5 id="8-target">8、<a href="https://leetcode.cn/problems/2VG8Kg/">和大于等于 target 的最短子数组</a><a class="headerlink" href="#8-target" title="Permanent link">&para;</a></h5>
<ul>
<li><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209</a><ul>
<li>看到视频讲解的一道题</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums){
        //时间复杂度O(n)
        //空间复杂度O(1)
        int l=0,r=-1;//nums[l...r]为我们的滑动窗口
        int sum = 0;
        int res=nums.size()+1;

        while(l&lt;nums.size()){
            if(r+1&lt;nums.size()&amp;&amp;sum&lt;target){
                r++;
                sum+=nums[r]; //右边界拓展
            } else{
                //sum-=nums[l++];//先减去，然后再++
                sum-=nums[l];
                l++;
            }

            if(sum&gt;=target){
                res = min(res,r-l+1);
            }
        }
        if(res==nums.size()+1)
            return 0;
        return res;
    }</code></pre>
<h5 id="9-k">9、乘积小于 K 的子数组<a class="headerlink" href="#9-k" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p><code>[10,5,2,6]</code>，k的值是100，有8个子数组的所有数字的乘积小于100</p>
<ul>
<li>p1和p2两个指针之间的数字组成一个子数组。</li>
</ul>
<ul>
<li>先移动p2，如果不超过，再移过p2，直到超过100，再移动p1</li>
</ul>
<ul>
<li><code>cpp
  int numSubarrayProduceLessThanK(vector&lt;int&gt; nums, int k){
      long produce = 1;
      int left=0,right=0;
      int count=0;
      for(right=0;i&lt;nums.size();right++){
          produce *= nums[right];
          while(left&lt;right &amp;&amp; produce &gt;= k){
              produce /= nums[left++];  //lionel，这个实现有点6
          }
          count += right&gt;=left?right-left+1:0;  //lionel，确实就算知道思路了，还是有很多种实现方法
      }
      return count;
  }</code></li>
</ul>
<ul>
<li></li>
</ul>
</li>
</ul>
<h4 id="23">2.3、累加数组数字求子数组之和<a class="headerlink" href="#23" title="Permanent link">&para;</a></h4>
<p>10、和为 k 的子数组</p>
<p>11、0 和 1 个数相同的子数组</p>
<p>12、左右两边子数组的和相等</p>
<p>13、二维子矩阵的和</p>
<h4 id="24">2.4、小结<a class="headerlink" href="#24" title="Permanent link">&para;</a></h4>
<h3 id="chap314-20">chap3、字符串（14-20）<a class="headerlink" href="#chap314-20" title="Permanent link">&para;</a></h3>
<h4 id="31">3.1、基础知识<a class="headerlink" href="#31" title="Permanent link">&para;</a></h4>
<ul>
<li>C++的string类（<em>lionel，书中讲的是java</em>）</li>
</ul>
<h4 id="32">3.2、双指针<a class="headerlink" href="#32" title="Permanent link">&para;</a></h4>
<ul>
<li>把字符串看成一个由字符组成的数组，那么也可以用两个指针来定位一个子字符串。</li>
<li><strong>使用哈希表来存储每个元素出现的次数</strong>，解决问题时<strong>同时使用 双指针 + 哈希表</strong>（2个配合使用）</li>
</ul>
<h5 id="14">14、字符串中的变位词<a class="headerlink" href="#14" title="Permanent link">&para;</a></h5>
<h5 id="15">15、字符串中的所有变位词<a class="headerlink" href="#15" title="Permanent link">&para;</a></h5>
<h5 id="16">16、不含重复字符的最长子字符串<a class="headerlink" href="#16" title="Permanent link">&para;</a></h5>
<h5 id="17">17、包含所有字符的最短字符串<a class="headerlink" href="#17" title="Permanent link">&para;</a></h5>
<ul>
<li>s为"ADDBANCAD"，t为“ABC”，找出s中包含t的所有字符的最短子字符串。输出是<strong>BANC</strong><ul>
<li>作者思路：<ul>
<li><strong>哈希表统计字符串每个字符出现的次数</strong>，先扫描t，统计每个字符的个数；再扫描s，每扫描一个字符，就检查哈希表中是否存在，不存在就忽略，存在hash表的值就减1。</li>
</ul>
</li>
<li><em>java中的HashMap类型对应C++的是哪种？</em></li>
</ul>
</li>
</ul>
<h4 id="33">3.3、回文字符串<a class="headerlink" href="#33" title="Permanent link">&para;</a></h4>
<h5 id="18">18、<a href="https://leetcode.cn/problems/XltzEq/">有效的回文</a><a class="headerlink" href="#18" title="Permanent link">&para;</a></h5>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-palindrome/">125</a><ul>
<li>知道<strong>用指针了</strong>，但啥时候<strong>该转大小写，数字判断又迷糊了</strong></li>
<li>https://www.jb51.net/article/217081.htm</li>
<li>https://blog.csdn.net/qq_40416052/article/details/82504029</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">//给定一个字符串 s ，验证 s 是否是 回文串 ，只考虑字母和数字字符，可以忽略字母的大小写。
//输入: s = "A man, a plan, a canal: Panama"
//输出: true
bool isPalindrome(string s) {
        int left = 0, right = s.size() - 1 ;
        while (left &lt; right) {
            if (!isalnum(s[left])) ++left;
            else if (!isalnum(s[right])) --right;
            else if ((s[left] + 32 - 'a') %32 != (s[right] + 32 - 'a') % 32) return false;
            else {
                ++left; --right;
            }
        }
        return true;
    }</code></pre>
<h5 id="19">19、<a href="https://leetcode.cn/problems/RQku0D/?envType=study-plan&amp;id=lcof-ii&amp;plan=lcof&amp;plan_progress=x95pysw2">最多删除一个字符得到回文</a><a class="headerlink" href="#19" title="Permanent link">&para;</a></h5>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">680</a><ul>
<li>https://www.cnblogs.com/zzxcm/p/15864818.html <em>这个写得复杂了，我就没参考，但确实符合我第一次看到题的思路</em></li>
<li>https://zxi.mytechroad.com/blog/string/leetcode-680-valid-palindrome-ii/  【这个答案有点儿意思】，我用了这个</li>
<li>https://github.com/keineahnung2345/leetcode-cpp-practices/blob/master/680.%20Valid%20Palindrome%20II.cpp <em>感觉都是这么写的</em></li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">//给定一个非空字符串 s，请判断如果 最多 从字符串中删除一个字符能否得到一个回文字符串。
//输入: s = "aba"
//输出: true
class Solution {
public:
    bool validPalindrome(const string&amp; s) {
        int l = -1;
        int r = s.length();
        while (++l &lt; --r)
            if (s[l] != s[r])
                return isPalindrome(s, l+1, r) 
                    || isPalindrome(s, l, r-1);
        return true;
    }
private:
    bool isPalindrome(const string&amp; s, int l, int r) {
        while (l &lt; r)
            if (s[l++] != s[r--]) return false;
        return true;
    }
};</code></pre>
<h5 id="20">20、回文子字符串的个数<a class="headerlink" href="#20" title="Permanent link">&para;</a></h5>
<ul>
<li>字符串"abc"有3个回文字符串（a,b,c），字符串"aaa"有6个回文串（a,a,a,aa,aa,aaa）。</li>
</ul>
<h4 id="31_1">3.1、小结<a class="headerlink" href="#31_1" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>熟练掌握字符串常用操作</strong>是解题的前提</li>
<li><strong>变位词与回文</strong>是考查的重点<ul>
<li><strong>变位词</strong>，两个字符串包含的字符及每个字符出现的次数都相同，只是字符出现的顺序不同，<strong>用哈希表统计每个字符出现的次数</strong></li>
<li><strong>回文</strong>，从前往后还是从后往前读取其每一个字符，得到的内容都是一样的。<strong>双指针</strong>（两端往中间移，中间往两端移）两种思路</li>
</ul>
</li>
</ul>
<h3 id="chap421-29">chap4、链表（21-29）<a class="headerlink" href="#chap421-29" title="Permanent link">&para;</a></h3>
<h4 id="_2">题目<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h4>
<p>21、删除链表的倒数第 n 个结点</p>
<h5 id="22_1">22、链表中环的入口节点<a class="headerlink" href="#22_1" title="Permanent link">&para;</a></h5>
<p>23、两个链表的第一个重合节点</p>
<h5 id="24_1">24、反转链表<a class="headerlink" href="#24_1" title="Permanent link">&para;</a></h5>
<p>25、链表中的两数相加</p>
<p>26、重排链表</p>
<p>27、回文链表</p>
<p>28、展平多级双向链表</p>
<p>29、排序的循环链表</p>
<h3 id="chap530-35">chap5、哈希（30-35）<a class="headerlink" href="#chap530-35" title="Permanent link">&para;</a></h3>
<h4 id="_3">题目<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h4>
<p>插入、删除和随机访问都是 O(1) 的容器</p>
<p>最近最少使用缓存</p>
<h5 id="32_1">32、<a href="https://leetcode.cn/problems/dKk3P7/?envType=study-plan&amp;id=lcof-ii&amp;plan=lcof&amp;plan_progress=x95pysw2">有效的变位词</a><a class="headerlink" href="#32_1" title="Permanent link">&para;</a></h5>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-anagram/">242</a><ul>
<li>虽然我解出来了，但官方的答案比我的优秀</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-cpp">//给定两个字符串 s 和 t ，编写一个函数来判断它们是不是一组变位词（字母异位词）。
//输入: s = "anagram", t = "nagaram"
//输出: true
bool isAnagram(string s, string t) {
        if(s.size()!=t.size()) return false;   //1、为啥用size()而不用length()，区别在哪？
        if(s==t) return false;          //2、两个判断相等，其实可以直接判断，不用再逐个字符判断
        vector&lt;int&gt; vt1(26,0),vt2(26,0);  //3、用vector去存的，而并没有用所谓的hash里的一些map的用法，【26的取值，以及-'a'的操作，都值得学一下】
        for(int i=0;i&lt;s.size();i++){
            vt1[s[i]-'a']++;
            vt2[t[i]-'a']++;
        }
        return vt1==vt2;
    }</code></pre>
<p>变位词组</p>
<p>外星语言是否排序</p>
<p>最小时间差</p>
<h3 id="chap6">chap6、栈<a class="headerlink" href="#chap6" title="Permanent link">&para;</a></h3>
<h4 id="61">6.1、基础知识<a class="headerlink" href="#61" title="Permanent link">&para;</a></h4>
<h4 id="62">6.2、栈的应用<a class="headerlink" href="#62" title="Permanent link">&para;</a></h4>
<ul>
<li>单调栈（<strong>保存在栈中的数据是排列的</strong>）</li>
</ul>
<h5 id="36">36、后缀表达式<a class="headerlink" href="#36" title="Permanent link">&para;</a></h5>
<h5 id="37">37、小行星碰撞<a class="headerlink" href="#37" title="Permanent link">&para;</a></h5>
<h5 id="38">38、每日温度<a class="headerlink" href="#38" title="Permanent link">&para;</a></h5>
<h5 id="39">39、直方图最大矩形面积<a class="headerlink" href="#39" title="Permanent link">&para;</a></h5>
<h5 id="40">40、矩阵中最大的矩形<a class="headerlink" href="#40" title="Permanent link">&para;</a></h5>
<h4 id="63">6.3、小结<a class="headerlink" href="#63" title="Permanent link">&para;</a></h4>
<h3 id="chap741-46">chap7、队列（41-46）<a class="headerlink" href="#chap741-46" title="Permanent link">&para;</a></h3>
<h4 id="71">7.1、基础知识<a class="headerlink" href="#71" title="Permanent link">&para;</a></h4>
<h4 id="72">7.2、队列的应用<a class="headerlink" href="#72" title="Permanent link">&para;</a></h4>
<h5 id="41">41、滑动窗口的平均值<a class="headerlink" href="#41" title="Permanent link">&para;</a></h5>
<h5 id="42">42、最近请求次数<a class="headerlink" href="#42" title="Permanent link">&para;</a></h5>
<h5 id="43">43、在完全二叉树中添加节点<a class="headerlink" href="#43" title="Permanent link">&para;</a></h5>
<h5 id="44">44、二叉树每层的最大值<a class="headerlink" href="#44" title="Permanent link">&para;</a></h5>
<h5 id="45">45、二叉树最底层最左边的值<a class="headerlink" href="#45" title="Permanent link">&para;</a></h5>
<h5 id="46">46、二叉树的右侧视图<a class="headerlink" href="#46" title="Permanent link">&para;</a></h5>
<h4 id="73">7.3、小结<a class="headerlink" href="#73" title="Permanent link">&para;</a></h4>
<h3 id="chap8">chap8、树<a class="headerlink" href="#chap8" title="Permanent link">&para;</a></h3>
<h4 id="1_1">1、基础知识<a class="headerlink" href="#1_1" title="Permanent link">&para;</a></h4>
<h4 id="2_1">2、二叉树的深度优先搜索<a class="headerlink" href="#2_1" title="Permanent link">&para;</a></h4>
<p>二叉树剪枝</p>
<p>序列化与反序列化二叉树</p>
<p>从根节点到叶节点的路径数字之和</p>
<p>向下的路径节点之和</p>
<p>节点之和最大的路径</p>
<h4 id="3">3、二叉搜索树<a class="headerlink" href="#3" title="Permanent link">&para;</a></h4>
<p>展平二叉搜索树</p>
<p>二叉搜索树中的中序后继</p>
<p>所有大于等于节点的值之和</p>
<p>二叉搜索树迭代器</p>
<p>二叉搜索树中两个节点之和</p>
<p>值和下标之差都在给定的范围内</p>
<h4 id="4treesettreemap">4、TreeSet和TreeMap的应用<a class="headerlink" href="#4treesettreemap" title="Permanent link">&para;</a></h4>
<p>日程表</p>
<h3 id="chap9">chap9、堆<a class="headerlink" href="#chap9" title="Permanent link">&para;</a></h3>
<h4 id="1_2">1、基础知识<a class="headerlink" href="#1_2" title="Permanent link">&para;</a></h4>
<h4 id="2_2">2、堆的应用<a class="headerlink" href="#2_2" title="Permanent link">&para;</a></h4>
<p>数据流的第 K 大数值</p>
<p>出现频率最高的 k 个数字</p>
<p>和最小的 k 个数对</p>
<h3 id="chap1062-">chap10、前缀树（62-）<a class="headerlink" href="#chap1062-" title="Permanent link">&para;</a></h3>
<h4 id="101">10.1、基础知识<a class="headerlink" href="#101" title="Permanent link">&para;</a></h4>
<ul>
<li>前缀树（<strong>字典树</strong>），用一个树状结构存储一个字典中的所有单词。<ul>
<li>can,cat,come,do,i,in,inn保存的样子（图10.1）<ul>
<li>第一层是c,第二层是a，<strong>找共性，找不到，再另起一个</strong>，比如同第一行就是d和i</li>
</ul>
</li>
</ul>
</li>
<li><strong>前缀树</strong>是一个<strong>多叉树</strong>，一个节点可能有多个子节点。<strong>前缀树的根节点不表示任何字符</strong>。</li>
<li>字符串在前缀树中的路径并不一定终止于叶节点。（一个单词是另一个单词的前缀）</li>
<li>如果前缀树路径到达某个节点时它表示了一个完整的字符串，那么<strong>字符串最后一个字符对应的节点有特殊的标识</strong>。</li>
</ul>
<h5 id="62_1">62、实现前缀树<a class="headerlink" href="#62_1" title="Permanent link">&para;</a></h5>
<ul>
<li>有3个功能<ul>
<li>insert</li>
<li>search，查找字符串</li>
<li>startWith，查找字符串前缀</li>
</ul>
</li>
</ul>
<h4 id="102">10.2、前缀树的应用<a class="headerlink" href="#102" title="Permanent link">&para;</a></h4>
<h5 id="63_1">63、替换单词<a class="headerlink" href="#63_1" title="Permanent link">&para;</a></h5>
<h5 id="64">64、神奇的字典<a class="headerlink" href="#64" title="Permanent link">&para;</a></h5>
<h5 id="65">65、最短的单词编码<a class="headerlink" href="#65" title="Permanent link">&para;</a></h5>
<h5 id="66">66、单词之和<a class="headerlink" href="#66" title="Permanent link">&para;</a></h5>
<h5 id="67">67、最大的异或<a class="headerlink" href="#67" title="Permanent link">&para;</a></h5>
<h4 id="103">10.3、小结<a class="headerlink" href="#103" title="Permanent link">&para;</a></h4>
<ul>
<li>前缀树通常用来保存字符串，它的节点和字符串的字符对应，而路径与字符串对应。<strong>为了标注某些节点和字符串的最后一个字符对应，前缀树节点中通常需要一个布尔类型的字段</strong>。</li>
</ul>
<ul>
<li>前缀树经常用来解决与字符串查找相关的问题。和哈希表相比，在前缀树中查找更灵活。既可以从哈希表中找出所有以某个前缀开头的所有单词，也可以找出修改了一个（或多个）字符的字符串。</li>
<li>使用前缀树解决问题通常需要2步：<ul>
<li>1、创建前缀树</li>
<li>2、在前缀树中查找</li>
</ul>
</li>
</ul>
<h3 id="chap11">chap11、二分查找<a class="headerlink" href="#chap11" title="Permanent link">&para;</a></h3>
<h4 id="1_3">1、基础知识<a class="headerlink" href="#1_3" title="Permanent link">&para;</a></h4>
<h4 id="2_3">2、在排序数组中二分查找<a class="headerlink" href="#2_3" title="Permanent link">&para;</a></h4>
<p>查找插入位置</p>
<p>山峰数组的顶部</p>
<p>排序数组中只出现一次的数字</p>
<p>按权重生成随机数</p>
<p>求平方根</p>
<p>狒狒吃香蕉</p>
<h4 id="3_1">3、在数值范围内二分查找<a class="headerlink" href="#3_1" title="Permanent link">&para;</a></h4>
<h3 id="chap12">chap12、排序<a class="headerlink" href="#chap12" title="Permanent link">&para;</a></h3>
<h4 id="1_4">1、基础知识<a class="headerlink" href="#1_4" title="Permanent link">&para;</a></h4>
<h4 id="2_4">2、计数排序<a class="headerlink" href="#2_4" title="Permanent link">&para;</a></h4>
<p>合并区间</p>
<p>数组相对排序</p>
<h4 id="_4">快速排序<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h4>
<p>数组中的第 k 大的数字</p>
<h4 id="_5">归并排序<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h4>
<p>链表排序</p>
<p>合并排序链表</p>
<h3 id="chap1379-87">chap13、回溯法（79-87）<a class="headerlink" href="#chap1379-87" title="Permanent link">&para;</a></h3>
<h4 id="131">13.1、基础知识<a class="headerlink" href="#131" title="Permanent link">&para;</a></h4>
<ul>
<li>解决问题时的每一步都尝试所有可能的选项，最终找到所有可行的解决方案。非常适合<strong>解决由多个步骤组成的问题，并且每个步骤都有多个选项</strong>。</li>
<li>求解<code>[1,2]</code>的所有子集<ul>
<li><strong>子集的初始状态为空</strong></li>
<li>分2步：是否在子集中添加1，是否在子集中添加2</li>
</ul>
</li>
<li>采用回溯法解决问题的过程实质上是在树形结构中从根节点开始进行深度优先遍历。</li>
<li>如果在前往某个节点时对问题的解的状态进行了修改，那么在回溯到它的父节点时要记得清除对应的修改</li>
</ul>
<h4 id="132">13.2、集合的组合、排列<a class="headerlink" href="#132" title="Permanent link">&para;</a></h4>
<ul>
<li>一个子集又可以称为一个组合</li>
</ul>
<h5 id="79">79、所有子集<a class="headerlink" href="#79" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p>输入不含重复数字的数据集合，找出它的所有子集。<code>[1,2]</code>的所有子集</p>
<ul>
<li><strong>集合中包含n个元素，那么生成子集就可以分成n步</strong>，每步从集合中取一个数字，有2个选项，加入或不加入</li>
</ul>
<ul>
<li>```cpp
  //nums是集合，包含了所有元素；index是下标，当前的数字的下标；subset是当前子集；result是已经生成的子集
  void helper(vector<int> nums, int index, vector<int>subset, vector<vector\<int>> result){
      if(index == nums.size()){
          result.push(subset);  //lionel，这个对不对 【加入的只是subset的拷贝】
      }else if(index&lt;nums.size()){
          helper(nums,index+1,subset,resut);  //不加入，直接调用递归函数处理下一个（index+1）即可
      }<pre class="highlight"><code>subset.push(nums[index]); //把当前数字加入到当前子集
helper(nums,index+1,subset,result);
subset.remove();//递归完成后，把加入的再退出</code></pre>
<p>}
```</p>
</li>
</ul>
<ul>
<li></li>
</ul>
</li>
</ul>
<h5 id="80-k">80、含有 k 个元素的组合<a class="headerlink" href="#80-k" title="Permanent link">&para;</a></h5>
<h5 id="81">81、允许重复选择元素的组合<a class="headerlink" href="#81" title="Permanent link">&para;</a></h5>
<ul>
<li><em>lionel，这个要看一下，主要条件不再是index了</em></li>
</ul>
<h5 id="82">82、包含重复元素集合的组合<a class="headerlink" href="#82" title="Permanent link">&para;</a></h5>
<ul>
<li><em>lionel，没看</em></li>
</ul>
<h5 id="83">83、没有重复元素集合的全排列<a class="headerlink" href="#83" title="Permanent link">&para;</a></h5>
<ul>
<li>给定一个没有重复数字的集合，找出它的所有全排列。<code>[1,2,3]</code>有6个全排列<ul>
<li><em>lionel，没看</em>，用的是递归？</li>
</ul>
</li>
</ul>
<h5 id="84">84、包含重复元素集合的全排列<a class="headerlink" href="#84" title="Permanent link">&para;</a></h5>
<ul>
<li>给定一个包含重复数字的集合，找出它的所有全排列。<code>[1,1,2]</code>有3个全排列<ul>
<li><em>lionel，不熟悉</em></li>
</ul>
</li>
</ul>
<h4 id="133">13.3、使用回溯法解决其他类型的问题<a class="headerlink" href="#133" title="Permanent link">&para;</a></h4>
<h5 id="85">85、生成匹配的括号<a class="headerlink" href="#85" title="Permanent link">&para;</a></h5>
<ul>
<li><em>lionel，题都没看</em></li>
</ul>
<h5 id="86">86、分割回文字符串<a class="headerlink" href="#86" title="Permanent link">&para;</a></h5>
<ul>
<li>“google”就有3种分割办法是回文（goog,l,e）（g,o,o,g,l,e）（g,oo,g,l,e）<ul>
<li><em>lionel，没看</em></li>
</ul>
</li>
</ul>
<h5 id="87ip">87、复原IP<a class="headerlink" href="#87ip" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p>字符串“10203040”，可以恢复3个（10.20.30.40）（102.0.30.40）（10.203.0.40）</p>
<ul>
<li>
<p>字符串长度为n，就分成n步，每步有2个选项</p>
<ul>
<li>1，将当前字符拼到当前分段数字的末尾，拼接后在0-255之间</li>
<li>2、将当前字符作为一个新的分段字符，但分段不能超过4，开始分段时前一个不能为空</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>```cpp
  //s是源串，i是字符串的下标，segI是当前分段数字的下标（取值0-3），seg当前已经恢复的一个分段数字，ip就是恢复的IP
  void helper(string s, int i, int segI, string seg, string ip, vector<string> result){
      if(i==s.size() &amp;&amp; sgeI==3 &amp;&amp; isValidSeg(seg)){
          result.add(ip+seg);
      }else if(i&lt;s.size() &amp;&amp; segI &lt;=3){
          char ch = s.at(i);
          if(isValidSeg(seg+ch)){
              helper(s,i+1,segI,seg+ch,ip,result);  //加入到原先的segI，同时下标加1
          }</p>
<pre class="highlight"><code>    //2个if，也就是2种选项，都在else if()中，也正常，表明不符合条件add的，有2种选择
    if(seg.length()&gt;0 &amp;&amp; setI&lt;3){
        helper(s,i+1,segI+1,""+ch,ip+seg+".",result);//index和segI都加1，但set和ip，都变了不同的值【后面的要想一下】
    }
}</code></pre>
<p>}</p>
<p>bool isValidSeg(string seg){
    return stoi(seg)&lt;=255 &amp;&amp; (seg.contains("0") || seg.at(0)!='0'); //lionel, seg.equals("0")是啥意思？
}
```</p>
</li>
</ul>
<ul>
<li></li>
</ul>
</li>
</ul>
<h4 id="134">13.4、本章小结<a class="headerlink" href="#134" title="Permanent link">&para;</a></h4>
<h3 id="chap1488-104">chap14、动态规划（88-104）<a class="headerlink" href="#chap1488-104" title="Permanent link">&para;</a></h3>
<h4 id="141">14.1、基础知识<a class="headerlink" href="#141" title="Permanent link">&para;</a></h4>
<ul>
<li>求一个问题的最优解（求最大值或最小值），比如列举出整数集合<code>[2,3,5]</code>，元素之和等于8的组合有几个</li>
<li>采用动态规划时总是用<strong>递归的思路</strong>分析问题，找出描述大问题的解和小问题的解之间递归关系的状态转移方程</li>
<li><strong>小问题之间存在重叠的部分</strong>，是可以运用动态规划求解问题的另一个显著特色</li>
<li>用代码实现动态规划算法时<ul>
<li>1、采用递归的代码按照从上往下的顺序求解，每求出一个小问题的解就缓存下来</li>
<li>2、从下往上的顺序，从解决最小的问题开始，并把已经解决的小问题的解存储下来（大部分存储在一维或二维数组中），再把小问题的解组合起来</li>
</ul>
</li>
</ul>
<h5 id="88">88、爬楼梯的最小成本<a class="headerlink" href="#88" title="Permanent link">&para;</a></h5>
<ul>
<li>有4种解法（<em>lionel，要搞会</em>）</li>
</ul>
<h4 id="142">14.2、单序列问题<a class="headerlink" href="#142" title="Permanent link">&para;</a></h4>
<ul>
<li>每一步在序列中增加一个元素，根据题目的特点找出该元素对应的最优解（或解的数目）和前面若干元素（通常是一个或两个）的最优解（或解的数目）的关系，并以此找出相应的状态转移方程</li>
</ul>
<h5 id="89">89、房屋被盗<a class="headerlink" href="#89" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p>在</p>
<ul>
<li>
<p>```cpp
  //维护一个dp，传入参数，这是一种做法
  void helper(vector<int> nums, int index, vector<int> dp){
      if(index == 0){
          dp[index] == nums[0];
      }
      else if (index == 1){
          dp[index]=max(nums[0],nums[1]);
      }else if(dp[index]&lt;0){
          helper(nums,index-2,dp);
          helper(nums,index-1,dp);
          dp[index]=max(dp[index-1],dp[index-2]+nums[index]);
      }
  }</p>
<p>//还有一种做法，不用helper()函数，直接用 for循环
//先算出dp[0]
dp[0]=nums[0];
//再求出dp[1]
if(nums.size()&gt;1){
    dp[1]=max(nums[0],nums[1]);
}</p>
<p>for(int i=2;i&lt;nums.size();i++){  //lionel，这个地方从2开始
    dp[i]=max(dp[i-1],dp[i-2]+nums[i]);
}</p>
<p>return dp[nums.length-1];
```</p>
</li>
</ul>
<ul>
<li></li>
</ul>
</li>
</ul>
<h5 id="90">90、环形房屋偷盗<a class="headerlink" href="#90" title="Permanent link">&para;</a></h5>
<p>91、粉刷房子</p>
<p>92、翻转字符</p>
<p>93、最长斐波那契数列</p>
<p>94、最少回文分割</p>
<h4 id="143">14.3、双序列问题<a class="headerlink" href="#143" title="Permanent link">&para;</a></h4>
<ul>
<li>输入是两个字符串或数组，那么状态转移方程通常有两个参数，<code>f(i,j)</code>，即第一个序列的（0,i）与第二个序列的（0,j）</li>
</ul>
<p>95、最长公共子序列</p>
<p>96、字符串交织</p>
<p>97、子序列的数目</p>
<h4 id="144">14.4、矩阵路径问题<a class="headerlink" href="#144" title="Permanent link">&para;</a></h4>
<ul>
<li>一定要将<code>f(i,j)</code>的计算结果用一个二维数组缓存，以避免不必要的重复计算。</li>
</ul>
<p>98、路径的数目</p>
<p>99、最小路径之和</p>
<p>100、三角形中最小路径之和</p>
<h4 id="145">14.5、背包问题<a class="headerlink" href="#145" title="Permanent link">&para;</a></h4>
<ul>
<li>有界背包，每种物品的数量有限</li>
<li>无界背包，每种物品的数量无限（完全背包）</li>
</ul>
<h5 id="101_1">101、分割等和子集<a class="headerlink" href="#101_1" title="Permanent link">&para;</a></h5>
<h5 id="102_1">102、加减的目标值<a class="headerlink" href="#102_1" title="Permanent link">&para;</a></h5>
<h5 id="103_1">103、最少的硬币数目<a class="headerlink" href="#103_1" title="Permanent link">&para;</a></h5>
<p>104、排列的数目</p>
<h4 id="146">14.6、小结<a class="headerlink" href="#146" title="Permanent link">&para;</a></h4>
<ul>
<li>找最优解</li>
<li>推导状态转移方程，是<strong>递归表达式</strong>，直接用递归呢，存在大量重复计算，<strong>将计算结果进行缓存</strong>。</li>
<li>递归的代码按照自上而下的顺序解决，迭代按照自下而上的顺序解决问题</li>
</ul>
<h3 id="chap15105-119">chap15、图（105-119）<a class="headerlink" href="#chap15105-119" title="Permanent link">&para;</a></h3>
<h4 id="151">15.1、基础知识<a class="headerlink" href="#151" title="Permanent link">&para;</a></h4>
<h4 id="152">15.2、图的搜索<a class="headerlink" href="#152" title="Permanent link">&para;</a></h4>
<h4 id="_6">拓扑排序<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h4>
<h4 id="_7">并查集<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h4>
<h4 id="155">15.5、小结<a class="headerlink" href="#155" title="Permanent link">&para;</a></h4>
<p>https://zxi.mytechroad.com/blog/leetcode-problem-categories/  题目列表</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../%E5%89%91%E6%8C%87offer2nd/" class="btn btn-neutral float-left" title="《剑指offer2nd》"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../../96output/OD%E5%9F%BA%E7%A1%80%E9%A2%98/" class="btn btn-neutral float-right" title="OD基础题">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../%E5%89%91%E6%8C%87offer2nd/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../../96output/OD%E5%9F%BA%E7%A1%80%E9%A2%98/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
