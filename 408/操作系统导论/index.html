<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>《操作系统导论》 - lionel的技术笔记</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u300a\u64cd\u4f5c\u7cfb\u7edf\u5bfc\u8bba\u300b";
        var mkdocs_page_input_path = "408\\\u64cd\u4f5c\u7cfb\u7edf\u5bfc\u8bba.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> lionel的技术笔记
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../01daily/">daily</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../02ds/">ds</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../03cpp/">cpp</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../21tool/">tool</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">C++</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/effectiveC%2B%2B/">《Effective C++》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../20C%2B%2B/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">《深度探索C++对象模型》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/EffectiveSTL/">《Effective STL》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/C%2B%2B%E6%B3%9B%E5%9E%8BSTL%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/">《C++泛型STL原理和应用》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../21STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">《STL源码剖析》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../22C%2B%2Bmodern/%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8C%2B%2B11/">《深入应用C++11》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">基础知识</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">《操作系统导论》</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#chap1">chap1、关于本书的对话</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap2">chap2、操作系统介绍</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#21cpu">2.1、虚拟化CPU</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#22">2.2、虚拟化内存</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#23">2.3、并发</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#24">2.4、持久性</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#25">2.5、设计目标</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#26">2.6、简单历史</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_2">早期操作系统：只是一些库</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_3">超越库：保护</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_4">多道程序时代</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_5">摩登时代</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#27">2.7、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap3">chap3、关于虚拟化的对话</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap4">chap4、抽象：进程</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#41">4.1、抽象：进程</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#42api">4.2、进程API</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#43">4.3、进程创建：更多细节</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#44">4.4、进程状态</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#45">4.5、数据结构</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#46">4.6、小结</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_6">作业</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_7">问题</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap5api">chap5、插叙：进程API</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#51fork">5.1、fork()系统调用</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#52wait">5.2、wait()系统调用</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#53exec">5.3、最后是exec()系统调用</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#54api">5.4、为什么这样设计API</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#55api">5.5、其他API</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#56">5.6、小结</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_8">作业（编码）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_9">问题</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap6">chap6、机制：受限直接执行</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#61">6.1、基本技巧：受限直接执行</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#621">6.2、问题1：受限制的操作</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#632">6.3、问题2：在进程之间切换</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#631">6.3.1、协作方式：等待系统调用</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#632_1">6.3.2、非协作方式：操作系统进行控制</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#633">6.3.3、保存和恢复上下文</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#64">6.4、担心并发吗</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#65">6.5、小结</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_10">作业（测量）</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap7">chap7、进程调度：介绍</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#71">7.1、工作负载假设</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#72">7.2、调度指标</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#73fifo">7.3、先进先出（FIFO）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#74sjf">7.4、最短任务优先（SJF）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#75stcf">7.5、最短完成时间优先（STCF）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#76">7.6、新度量指标：响应时间</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#77">7.7、轮转</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#78io">7.8、结合I/O</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#79">7.9、无法预知</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#710">7.10、小结</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_11">作业</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_12">问题</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap8">chap8、调度：多级反馈队列</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#81mlfq">8.1、MLFQ：基本规则</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#821">8.2、尝试1：如何改变优先级</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1">实例1：单个长工作</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2">实例2：来了一个短工作</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#3io">实例3：如果有I/O呢</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#mlfq">当前MLFQ的一些问题</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#832">8.3、尝试2：提升优先级</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#843">8.4、尝试3：更好的计时方式</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#85mlfq">8.5、MLFQ：调优及其他问题</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#86mlfq">8.6、MLFQ：小结</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_13">作业</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_14">问题</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap9">chap9、调度：比例份额</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#91">9.1、基本概念：彩票数表示份额</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#92">9.2、彩票机制</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#93">9.3、实现</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#94">9.4、一个例子</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#95">9.5、如何分配彩票</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#96">9.6、为什么不是确定的</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#97">9.7、小结</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_15">作业</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_16">问题</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap10">chap10、多处理器调度（高级）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#101">10.1、背景：多处理架构</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#102">10.2、别忘了同步</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#103">10.3、最后一个问题：缓存亲和度</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#104sqms">10.4、单队列调度（SQMS）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#105">10.5、多队列调度</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#106linux">10.6、Linux多处理器调度</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#107">10.7、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap11cpu">chap11、关于CPU虚拟化的总结对话</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap12">chap12、关于内存虚拟化的对话</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap13">chap13、抽象:地址空间</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#131">13.1、早期系统</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#132">13.2、多道程序和时分共享</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#133">13.3、地址空间</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#134">13.4、目标</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#135">13.5、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap14api">chap14、插叙：内存操作API</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#141">14.1、内存类型</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#142malloc">14.2、malloc()调用</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#143free">14.3、free()调用</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#144">14.4、常见错误</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#145">14.5、底层操作系统支持</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#146">14.6、其他调用</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#147">14.7、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap15">chap15、机制：地址转换</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#0">0、</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#151">15.1、假设</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#152">15.2、一个例子</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#153">15.3、动态（基于硬件）重定位</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#154">15.4、硬件支持：总结</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#155">15.5、操作系统的问题</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#156">15.6、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap16">chap16、分段</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#0_1">0、</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#161">16.1、分段：泛化的基址/界限</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#162">16.2、我们引用哪个段</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#163">16.3、栈怎么办</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#164">16.4、支持共享</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#165">16.5、细粒度与粗粒度的分段</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#166">16.6、操作系统支持</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#167">16.7、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap17">chap17、空闲空间管理</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#171">17.1、假设</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#172">17.2、底层机制</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#173">17.3、基本策略</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#174">17.4、其他方式</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#175">17.5、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap18">chap18、分页：介绍</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#181">18.1、一个简单的例子</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#182">18.2、页表存在哪里</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#183">18.3、列表中究竟有什么</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#184">18.4、分页：也很慢</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#185">18.5、内存追踪</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#186">18.6、小结</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_17">作业</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_18">问题</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap19tlb">chap19、分页：快速地址转换（TLB）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#191tlb">19.1、TLB的基本算法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#192">19.2、示例：访问数组</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#193tlb">19.3、谁来处理TLB未命中</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#194tlb">19.4、TLB的内容</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#195tlb">19.5、上下文切换时对TLB的处理</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#196tlb">19.6、TLB替换策略</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#197tlb">19.7、实际系统的TLB表项</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap20">chap20、分页：较小的表</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#201">20.1、简单的解决方案：更大的页</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#202">20.2、混合方法：分页和分段</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#203">20.3、多级页表</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_19">详细的多级示例</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_20">超过两级</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#tlb">地址转换过程：记住TLB</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#204">20.4、反向页表</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#205">20.5、将页表交换到磁盘</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#206">20.6、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap21">chap21、超越物理内存：机制</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#211">21.1、交换空间</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#212">21.2、存在位</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#213">21.3、页错误</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#214">21.4、内存满了怎么办</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#215">21.5、页错误处理流程</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#216">21.6、交换何时真正发生</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#217">21.7、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap22">chap22、超越物理内存：策略</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#221">22.1、缓存管理</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#222">22.2、最优替换策略</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#223fifo">22.3、简单策略：FIFO</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#224">22.4、另一简单策略：随机</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#225lru">22.5、利用历史数据：LRU</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#226">22.6、工作负载示例</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#227">22.7、实现基于历史信息的算法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#228lru">22.8、近似LRU</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#229">22.9、考虑脏页</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2210">22.10、其他虚拟内存策略</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2211">22.11、抖动</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2212">22.12、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap23vaxvms">chap23、VAX/VMS虚拟内存系统</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#231">23.1、背景</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#232">23.2、内存管理硬件</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#233">23.3、一个真实的地址空间</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#234">23.4、页替换</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#fifo">分段FIFO</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_21">页聚集</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#235">23.5、其他漂亮的虚拟内存技巧</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#236">23.6、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap24">chap24、内存虚拟化总结对话</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap25">chap25、并发的对话</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap26">chap26、并发：简介</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#263">26.3、问题的核心：自由安排</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#264">26.4、原子性</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap27api">chap27、插曲：线程API</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#271">27.1、线程创建</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#272">27.2、线程完成</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#273">27.3、锁</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#274">27.4、条件变量</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#275">27.5、编译和运行</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#276">27.6、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap28">chap28、锁</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#281">28.1、锁的基本思想</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#282pthread">28.2、pthread锁</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#283">28.3、实现一个锁</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#284">28.4、评价锁</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#285">28.5、控制中断</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#286">28.6、测试并设置指令（原子交换）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#287">28.7、实现可用的自旋锁</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#288">28.8、评价自旋锁</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#289">28.9、比较并交换</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2810">28.10、链接的加载和条件式存储指令</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2811">28.11、获取并增加</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2812">28.12、自旋过多：怎么办</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2813">28.13、简单方法：让出来吧，宝贝</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2814">28.14、使用队列：休眠替代自旋</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2815">28.15、不同操作系统，不同实现</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2816">28.16、两阶段锁</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2817">28.17、小结</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_22">作业</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_23">问题</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap29">chap29、基于锁的并发数据结构</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#291">29.1、并发计数器</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_24">简单但无法扩展</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_25">可扩展的计数</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#292">29.2、并发链表</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_26">扩展链表</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#293">29.3、并发队列</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#294">29.4、并发散列表</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#295">29.5、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap30">chap30、条件变量</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#301">30.1、定义和程序</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#302">30.2、生产者/消费者（有界缓冲区）问题</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_27">有问题的方案</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#while">较好但仍有问题的方案：使用while语句</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_28">单值缓冲区的生产者/消费者方案</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_29">最终的生产者/消费者方案</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#303">30.3、覆盖条件</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#304">30.4、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap31">chap31、信号量</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#311">31.1、信号量的含义</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#312">31.2、二值信号量（锁）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#313">31.3、信号量用作条件变量</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#314">31.4、生产者/消费者（有界缓冲区）问题</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_30">第一次尝试</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_31">解决方案：增加互斥</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_32">避免死锁</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_33">最后，可行的方案</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#315-">31.5、读者-写者锁</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#316">31.6、哲学家就餐问题</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_34">有问题的解决方案</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_35">一种方案：破除依赖</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#317">31.7、如何实现信号量</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#318">31.8、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap32">chap32、常见并发问题</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#321">32.1、有哪些类型的缺陷</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#322">32.2、非死锁缺陷</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_36">违反原子性缺陷</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_37">违反顺序缺陷</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_38">非死锁缺陷：小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#323">32.3、死锁缺陷</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_39">为什么发生死锁</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_40">产生死锁的条件</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_41">预防</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_42">通过调度避免死锁</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_43">检查和恢复</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#324">32.4、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap33">chap33、基于事件的并发（进阶）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#331">33.1、基本想法：事件循环</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#332apiselectpoll">33.2、重要API：select()（或poll()）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#333select">33.3、使用select()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#334">33.4、为何更简单？无须锁</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#335">33.5、一个问题：阻塞系统调用</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#336io">33.6、解决方案：异步I/O</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#337">33.7、另一个问题：状态管理</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#338">33.8、什么事情仍然很难</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap34">chap34、并发的总结对话</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap35">chap35、关于持久性的对话</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap36io">chap36、I/O设备</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#361">36.1、系统架构</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#362">36.2、标准设备</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#363">36.3、标准协议</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#364cpu">36.4、利用中断减少CPU开销</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#365dma">36.5、利用DMA进行更高效的数据传送</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#366">36.6、设备交互的方法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#367">36.7、纳入操作系统：设备驱动程序</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#368ide">36.8、案例研究：简单的IDE磁盘驱动程序</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#369">36.9、历史记录</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3610">36.10、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap37">chap37、磁盘驱动器</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#371">37.1、接口</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#372">37.2、基本几何形状</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#373">37.3、简单的磁盘驱动器</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#374io">37.4、I/O时间:用数学</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#375">37.5、磁盘调度</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#376">37.6、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap38raid">chap38、RAID</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#381raid">38.1、接口和RAID内部</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#382">38.2、故障模型</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#383raid">38.3、如何评估RAID</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#384raid0">38.4、RAID0级:条带化</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#385raid1">38.5、RAID1级:镜像</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#386raid4">38.6、RAID4级:通过奇偶校验节省空间</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#387raid5">38.7、RAID5级:旋转奇偶校验</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#388raid">38.8、RAID比较:总结</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#389raid">38.9、其他有趣的RAID问题</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3810">38.10、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap39">chap39、插叙:文件和目录</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap40">chap40、文件系统实现</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#401">40.1、思考方式</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#402">40.2、整体组织</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#403inode">40.3、文件组织:inode</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#404">40.4、目录组织</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#405">40.5、空闲空间管理</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#406">40.6、访问路径:读取和写入</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#4061">40.6.1、从磁盘读取文件</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#4062">40.6.2、写入磁盘</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#407">40.7、缓存和缓冲</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#408">40.8、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap41">chap41、局部性和快速文件系统</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#411">41.1、问题：性能不佳</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#412ffs">41.2、FFS：磁盘意识是解决方案</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#413">41.3、组织结构：柱面组</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#414">41.4、策略：如何分配文件和目录</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#415">41.5、测量文件的局部性</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#416">41.6、大文件例外</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#417ffs">41.7、关于FFS的其他几件事</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#418">41.8、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap42fsck">chap42、崩溃一致性:FSCK和日志</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#421">42.1、一个详细的例子</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4221">42.2、解决方案1:文件系统检查程序</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4232">42.3、解决方案2:日志（或预写日志）</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#4231">42.3.1、数据日志</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#4232_1">42.3.2、恢复</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4243">42.4、解决方案3:其它方法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#425">42.5、小结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap43">chap43、日志结构文件系统</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap44">chap44、数据完整性和保护</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap45">chap45、关于持久性的总结对话</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap46">chap46、关于分布式的对话</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap47">chap47、分布式系统</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap48sunnfs">chap48、Sun的网络文件系统（NFS）</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap49andrewafs">chap49、Andrew文件系统（AFS）</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#chap50">chap50、关于分布式的总结对话</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">《大话设计模式》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90_C%2B%2B4th/">《数据结构与算法分析_C++4th》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E7%AE%97%E6%B3%95%284th%29/">《算法4th》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%BC%A0%E5%86%9B/">《算法设计与分析-张军》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E5%A4%A9%E8%A1%8C-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《天行-算法设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B-%E6%9D%8E%E6%98%A5%E8%91%86/">《数据结构教程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E6%96%B0%E7%BC%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E4%B8%8E%E8%A7%A3%E6%9E%90/">《新编数据结构习题与解析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网络编程</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">《TCP/IP网络编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">《Linux高性能服务器编程》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71/">《TCPIP详解卷1》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90/">《Linux内核网络栈源代码情景分析》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../10network/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C/">《深入理解Linux网络》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">机器&深度学习</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../30machineLearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/">《机器学习线性代数基础》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../31deepLearning/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%9A%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《深度学习入门：基于Python的理论与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">文件系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/Linux%E5%86%85%E6%A0%B8%E6%8E%A2%E7%A7%98/">《Linux内核探秘》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《文件系统技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../11filesystem/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">《存储技术原理分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">存储</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../12storage/ceph%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《ceph设计原理与实现》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">视频</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/FFmpeg%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">《FFmpeg入门到精通》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">《WebRTC权威指南》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/WebRTC%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AE%9E%E6%97%B6%E4%BA%92%E5%8A%A8%E6%8A%80%E6%9C%AF/">《WebRTC音视频实时互动技术》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../14video/%E6%96%B0%E4%B8%80%E4%BB%A3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%A0%81%E6%A0%87%E5%87%86-H.264_AVC/">《新一代视频压缩码标准-H.264_AVC》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">内核</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《Linux内核设计与实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6/">《深入Linux设备驱动程序内核机制》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">《深入理解Linux虚拟内存管理》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">《深入理解Linux网络技术内幕》</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../13kernel/Linux内核源代码剖析-tcpip实现.md">《Linux内核源代码剖析-TCP/IP实现》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13kernel/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/">《深入理解Linux内核》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">工具</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/">《Wireshark网络分析实战》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%283rd%29/">《Linux命令行与shell脚本编程大全(3rd)》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%883rd%EF%BC%89/">《python程序设计（3rd）》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../15tool/python/Python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/">《Python编程从入门到实践》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">刷题</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../91leetcode/%E5%89%91%E6%8C%87offer2nd/">《剑指offer2nd》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../91leetcode/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/">《剑指offer专项突破》</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../96output/OD基础题.md">OD基础题</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../96output/OD进阶题.md">OD进阶题</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网课</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/01Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/">《Linux高并发网络编程开发》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/%E4%BE%AF%E6%8D%B7/%E4%BE%AF%E6%8D%B7C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8660%E8%AE%B2/">《侯捷C++内存管理60讲》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../90lecture/11NJU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">《NJU算法设计与分析》</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">英语专</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../60English/00794%E7%BB%BC%E5%90%88%E8%8B%B1%E8%AF%AD%E4%B8%80%E4%B8%8A/">《综合英语(一)上》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../95selfStudy/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/">《概率率与数理统计》</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">lionel的技术笔记</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>基础知识 &raquo;</li>
      <li>《操作系统导论》</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h2 id="_1">《操作系统导论》<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<ul>
<li>Part1、虚拟化<ul>
<li>虚拟化CPU（3-11）</li>
<li>虚拟化内存（12-24）</li>
</ul>
</li>
<li>PartII：Concurrency并发（25-34）</li>
<li>Part3、持久性（35-45）<ul>
<li>分布式系统（46-50）</li>
</ul>
</li>
</ul>
<h3 id="chap1">chap1、关于本书的对话<a class="headerlink" href="#chap1" title="Permanent link">&para;</a></h3>
<ul>
<li>OS是如何工作的<ul>
<li>它如何决定接下来哪个程序使用CPU</li>
<li>如何在虚拟内存系统中处理内存使用过载</li>
<li>虚拟机监控器如何工作</li>
<li>如果管理磁盘上的数据</li>
<li>如何构建在部分节点失败时仍能正常工作的分布式系统</li>
</ul>
</li>
<li>学习方法<ul>
<li>听课，做笔记，<strong>每个周末阅读笔记</strong>，过一段时间<strong>再复习笔记</strong>，<strong>做作业和项目</strong></li>
</ul>
</li>
</ul>
<h3 id="chap2">chap2、操作系统介绍<a class="headerlink" href="#chap2" title="Permanent link">&para;</a></h3>
<ul>
<li>执行指令（处理器从内存中取fetch一条指令，对其解码decode，然后执行execute），<strong>完成这条指令后</strong>，处理器继续执行下一条指令</li>
<li><strong>虚拟化</strong>：OS将物理资源转为更通用、更强大且易于使用的虚拟形式。</li>
</ul>
<h4 id="21cpu">2.1、虚拟化CPU<a class="headerlink" href="#21cpu" title="Permanent link">&para;</a></h4>
<h4 id="22">2.2、虚拟化内存<a class="headerlink" href="#22" title="Permanent link">&para;</a></h4>
<h4 id="23">2.3、并发<a class="headerlink" href="#23" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Key：如何构建正确的并发程序</strong></li>
</ul>
<h4 id="24">2.4、持久性<a class="headerlink" href="#24" title="Permanent link">&para;</a></h4>
<h4 id="25">2.5、设计目标<a class="headerlink" href="#25" title="Permanent link">&para;</a></h4>
<ul>
<li>1、建立抽象</li>
<li>2、提供高性能</li>
<li>3、在应用程序之间以及在OS和应用程序之间提供保护（protection）</li>
</ul>
<h4 id="26">2.6、简单历史<a class="headerlink" href="#26" title="Permanent link">&para;</a></h4>
<h5 id="_2">早期操作系统：只是一些库<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h5>
<h5 id="_3">超越库：保护<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h5>
<h5 id="_4">多道程序时代<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h5>
<h5 id="_5">摩登时代<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h5>
<h4 id="27">2.7、小结<a class="headerlink" href="#27" title="Permanent link">&para;</a></h4>
<h3 id="chap3">chap3、关于虚拟化的对话<a class="headerlink" href="#chap3" title="Permanent link">&para;</a></h3>
<ul>
<li>把一个CPU虚拟成多个虚拟CPU并分给每一个进程使用，<strong>每个应用都以为自己在独占CPU，但实际上只有一个CPU</strong></li>
</ul>
<h3 id="chap4">chap4、抽象：进程<a class="headerlink" href="#chap4" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>进程，就是运行中的程序</strong>，程序本身是没有生命周期的</li>
</ul>
<ul>
<li>关键问题：<strong>如何提供有许多CPU的假象？</strong><ul>
<li>时分共享（time sharing）CPU技术</li>
</ul>
</li>
<li>时分共享（资源在时间上由A用一段时间，B用一段时间）和空分共享（资源在空间上被划分给希望使用它的人）</li>
<li><strong>机制</strong>（mechanism）：低级机制，<strong>是一些低级方法或协议，实现了所需的功能</strong></li>
<li><strong>策略</strong>：智能，<strong>在操作系统内做出某种决定的算法</strong></li>
</ul>
<h4 id="41">4.1、抽象：进程<a class="headerlink" href="#41" title="Permanent link">&para;</a></h4>
<ul>
<li>操作系统为正在运行的程序提供的抽象，就是<strong>所谓的进程（process）</strong></li>
<li><strong>进程的机器状态</strong>（lionel，不太明白）<ul>
<li>一个明显组成部分，<strong>内存</strong></li>
<li>另一部分是，<strong>寄存器</strong></li>
</ul>
</li>
</ul>
<h4 id="42api">4.2、进程API<a class="headerlink" href="#42api" title="Permanent link">&para;</a></h4>
<ul>
<li>创建</li>
<li>销毁</li>
<li>等待</li>
<li>其他控制</li>
<li>状态</li>
</ul>
<h4 id="43">4.3、进程创建：更多细节<a class="headerlink" href="#43" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>程序如何转化为进程，也就是说，OS如何启动并运行一个程序？进程创建实际如何进行？</strong><ul>
<li>第一件事是将代码和所有静态数据加载到内在中，加载到进程的地址空间中</li>
<li>创建和初始化栈以及执行与I/O设置相关的其他工作</li>
<li>启动程序，即main()，跳转到main()例程，OS将CPU的控制权转移到新创建的进程中，从而程序开始执行</li>
</ul>
</li>
<li>要真正理解代码和数据的惰性加载是如何工作的，<strong>必须更多地了解分页和交换的机制</strong></li>
</ul>
<h4 id="44">4.4、进程状态<a class="headerlink" href="#44" title="Permanent link">&para;</a></h4>
<ul>
<li>运行</li>
<li>就绪</li>
<li>阻塞</li>
</ul>
<h4 id="45">4.5、数据结构<a class="headerlink" href="#45" title="Permanent link">&para;</a></h4>
<ul>
<li><code>struct context{};</code></li>
<li><code>struct proc{};</code></li>
<li>进程列表</li>
</ul>
<h4 id="46">4.6、小结<a class="headerlink" href="#46" title="Permanent link">&para;</a></h4>
<ul>
<li>实现进程所需的低级机制和以智能方式调度这些进程所需的高级策略</li>
</ul>
<h4 id="_6">作业<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h4>
<ul>
<li>process-run.py</li>
</ul>
<h4 id="_7">问题<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h4>
<ul>
<li>1、用以下标志运行程序：./process-run.py -l 5:100, 5:100.CPU利用率应该是多少？为什么你知道这一点？利用-c标记查看你的答案是否正确。</li>
</ul>
<h3 id="chap5api">chap5、插叙：进程API<a class="headerlink" href="#chap5api" title="Permanent link">&para;</a></h3>
<ul>
<li><code>fork()</code>和<code>exec()</code>一对系统调用，再通过<code>wait()</code>等待其创建的子进程执行完成。</li>
</ul>
<ul>
<li>Key：<strong>如何创建并控制进程</strong></li>
</ul>
<h4 id="51fork">5.1、fork()系统调用<a class="headerlink" href="#51fork" title="Permanent link">&para;</a></h4>
<ul>
<li><em>子进程和父进程执行顺序不确定</em>，参考一下p1.c</li>
</ul>
<h4 id="52wait">5.2、wait()系统调用<a class="headerlink" href="#52wait" title="Permanent link">&para;</a></h4>
<h4 id="53exec">5.3、最后是exec()系统调用<a class="headerlink" href="#53exec" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>exec()系统调用可以让子进程执行与父进程不同的程序</strong></li>
<li><em>Q，fork()与exec()的异同，lionel</em></li>
</ul>
<h4 id="54api">5.4、为什么这样设计API<a class="headerlink" href="#54api" title="Permanent link">&para;</a></h4>
<ul>
<li>分享fork()和exec()的做法，<strong>给了shell在fork之后exec之前运行代码的机会</strong></li>
</ul>
<h4 id="55api">5.5、其他API<a class="headerlink" href="#55api" title="Permanent link">&para;</a></h4>
<ul>
<li><code>kill()</code></li>
</ul>
<h4 id="56">5.6、小结<a class="headerlink" href="#56" title="Permanent link">&para;</a></h4>
<ul>
<li>读读APUE</li>
</ul>
<h4 id="_8">作业（编码）<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>熟悉一下API</strong></li>
</ul>
<h4 id="_9">问题<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h4>
<ul>
<li>3、使用fork()编写另一程序。子进程应打印"hello"，父进程应打印"goodbye"。你应该尝试确保子进程始终先打印。你能否不在父进程调用wait()而做到这一点呢？</li>
</ul>
<ul>
<li>5、编写一程序，在父进程中使用wait()，等待子进程完成。wait()返回什么? 如果你在子进程中使用wait()会发生什么？</li>
<li>6、编写一程序，创建两个子进程，并使用pipe()系统调用，将一个子进程的标准输出连接到另一个子进程的标准输入。</li>
</ul>
<h3 id="chap6">chap6、机制：受限直接执行<a class="headerlink" href="#chap6" title="Permanent link">&para;</a></h3>
<ul>
<li>时分共享（time sharing）CPU，实现虚拟化</li>
<li>挑战<ul>
<li>1、性能（如何在不增加系统开销的情况下实现虚拟化？）</li>
<li>2、控制权（如何有效地运行进程，同时保留对CPU的控制？）</li>
</ul>
</li>
<li>key：<strong>如何高效、可控地虚拟化CPU</strong></li>
</ul>
<h4 id="61">6.1、基本技巧：受限直接执行<a class="headerlink" href="#61" title="Permanent link">&para;</a></h4>
<ul>
<li>受限直接执行（limited direct execution），只需直接在CPU上运行程序即可</li>
</ul>
<h4 id="621">6.2、问题1：受限制的操作<a class="headerlink" href="#621" title="Permanent link">&para;</a></h4>
<ul>
<li>如果进程希望执行某种受限操作（如向磁盘发出I/O请求或获得更多系统资源），该怎么办？</li>
<li><strong>引入新的处理器模式，称为用户模式（user mode）</strong></li>
</ul>
<h4 id="632">6.3、问题2：在进程之间切换<a class="headerlink" href="#632" title="Permanent link">&para;</a></h4>
<ul>
<li>key：<strong>如何重获CPU的控制权</strong></li>
</ul>
<h5 id="631">6.3.1、协作方式：等待系统调用<a class="headerlink" href="#631" title="Permanent link">&para;</a></h5>
<h5 id="632_1">6.3.2、非协作方式：操作系统进行控制<a class="headerlink" href="#632_1" title="Permanent link">&para;</a></h5>
<ul>
<li>Key：<strong>如何在没有协作的情况下获得控制权</strong></li>
</ul>
<h5 id="633">6.3.3、保存和恢复上下文<a class="headerlink" href="#633" title="Permanent link">&para;</a></h5>
<h4 id="64">6.4、担心并发吗<a class="headerlink" href="#64" title="Permanent link">&para;</a></h4>
<ul>
<li>禁用中断时间过长可能导致丢失中断</li>
</ul>
<h4 id="65">6.5、小结<a class="headerlink" href="#65" title="Permanent link">&para;</a></h4>
<ul>
<li>实现CPU虚拟化的关键底层机制：<strong>受限直接执行</strong>，基本思想是：就让想运行的程序在CPU上运行，但首先确保设置好硬件，以便在没有操作系统帮助的情况下限制进程可以执行的操作</li>
<li><strong>虚拟CPU的基本机制</strong></li>
</ul>
<h4 id="_10">作业（测量）<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h4>
<h3 id="chap7">chap7、进程调度：介绍<a class="headerlink" href="#chap7" title="Permanent link">&para;</a></h3>
<ul>
<li>Key：<strong>如何开发调度策略</strong></li>
</ul>
<h4 id="71">7.1、工作负载假设<a class="headerlink" href="#71" title="Permanent link">&para;</a></h4>
<ul>
<li>对操作系统中运行的进程做出如下的假设：<ul>
<li>1、每一个工作运行相同的时间</li>
<li>2、所有的工作同时到达</li>
<li>3、一旦开始，每个工作保持运行直到完成</li>
<li>4、所有的工作只是用CPU（即它们不执行IO操作）</li>
<li>5、每个工作的运行时间是已知的</li>
</ul>
</li>
</ul>
<h4 id="72">7.2、调度指标<a class="headerlink" href="#72" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>周转时间</strong>：任务完成时间-任务到达时间</li>
<li>另一个指标是<strong>公平</strong></li>
</ul>
<h4 id="73fifo">7.3、先进先出（FIFO）<a class="headerlink" href="#73fifo" title="Permanent link">&para;</a></h4>
<h4 id="74sjf">7.4、最短任务优先（SJF）<a class="headerlink" href="#74sjf" title="Permanent link">&para;</a></h4>
<h4 id="75stcf">7.5、最短完成时间优先（STCF）<a class="headerlink" href="#75stcf" title="Permanent link">&para;</a></h4>
<h4 id="76">7.6、新度量指标：响应时间<a class="headerlink" href="#76" title="Permanent link">&para;</a></h4>
<h4 id="77">7.7、轮转<a class="headerlink" href="#77" title="Permanent link">&para;</a></h4>
<h4 id="78io">7.8、结合I/O<a class="headerlink" href="#78io" title="Permanent link">&para;</a></h4>
<h4 id="79">7.9、无法预知<a class="headerlink" href="#79" title="Permanent link">&para;</a></h4>
<ul>
<li>OS通常对每个作业的长度知之甚少</li>
</ul>
<h4 id="710">7.10、小结<a class="headerlink" href="#710" title="Permanent link">&para;</a></h4>
<ul>
<li>运行最短的工作，从而优化周转时间</li>
<li>交替运行所有工作，从而优化响应时间</li>
</ul>
<h4 id="_11">作业<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h4>
<ul>
<li>scheduler.py</li>
</ul>
<h4 id="_12">问题<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h4>
<ul>
<li>1、使用SJF和FIFO调度程序运行长度为200的3个作业时，计算响应时间和周转时间</li>
<li>2、</li>
</ul>
<h3 id="chap8">chap8、调度：多级反馈队列<a class="headerlink" href="#chap8" title="Permanent link">&para;</a></h3>
<ul>
<li>Multi-level Feedback Queue，MLFQ</li>
<li>多级反馈队列解决两方面的问题：<ul>
<li>首先，它要优化周转时间</li>
<li>其次，MLFQ希望给交互用户很好的交互体验</li>
</ul>
</li>
<li>Key：<strong>没有完备的知识如何调度？</strong><ul>
<li>从历史中学习</li>
</ul>
</li>
</ul>
<h4 id="81mlfq">8.1、MLFQ：基本规则<a class="headerlink" href="#81mlfq" title="Permanent link">&para;</a></h4>
<ul>
<li>规则1：如果A的优先级大于B，运行A（不运行B）</li>
<li>规则2：如果A的优先级等于B，轮转运行A和B</li>
</ul>
<h4 id="821">8.2、尝试1：如何改变优先级<a class="headerlink" href="#821" title="Permanent link">&para;</a></h4>
<ul>
<li>规则3：工作进入系统时，放在最高优先级（最上层队列）</li>
<li>规则4a：工作用完整个时间片后，降低其优先级（移入下一个队列）</li>
<li>规则4b：如果工作在其时间片以内主动释放CPU，则优先级不变</li>
</ul>
<h5 id="1">实例1：单个长工作<a class="headerlink" href="#1" title="Permanent link">&para;</a></h5>
<h5 id="2">实例2：来了一个短工作<a class="headerlink" href="#2" title="Permanent link">&para;</a></h5>
<h5 id="3io">实例3：如果有I/O呢<a class="headerlink" href="#3io" title="Permanent link">&para;</a></h5>
<h5 id="mlfq">当前MLFQ的一些问题<a class="headerlink" href="#mlfq" title="Permanent link">&para;</a></h5>
<h4 id="832">8.3、尝试2：提升优先级<a class="headerlink" href="#832" title="Permanent link">&para;</a></h4>
<ul>
<li>规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列</li>
</ul>
<h4 id="843">8.4、尝试3：更好的计时方式<a class="headerlink" href="#843" title="Permanent link">&para;</a></h4>
<ul>
<li>规则4：一旦工作用完了其在某一层中的时间配额，就降低其优先级（移入低一级队列）</li>
</ul>
<h4 id="85mlfq">8.5、MLFQ：调优及其他问题<a class="headerlink" href="#85mlfq" title="Permanent link">&para;</a></h4>
<ul>
<li>如何配置一个调度程序<ul>
<li>配置多少队列？每一层队列的时间片配置多大？为了避免饥饿问题以及进程行为改变，应该多久提升一次进程的优先级？</li>
</ul>
</li>
</ul>
<h4 id="86mlfq">8.6、MLFQ：小结<a class="headerlink" href="#86mlfq" title="Permanent link">&para;</a></h4>
<ul>
<li>规则1、</li>
<li>规则2、</li>
<li>规则3、</li>
<li>规则4、</li>
<li>规则5、</li>
</ul>
<h4 id="_13">作业<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h4>
<ul>
<li>mlfq.py</li>
</ul>
<h4 id="_14">问题<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h4>
<ul>
<li>1、</li>
<li>2、如何运行调度程序来重现本章中的每个实例？</li>
</ul>
<h3 id="chap9">chap9、调度：比例份额<a class="headerlink" href="#chap9" title="Permanent link">&para;</a></h3>
<ul>
<li>proportional-share，也称<strong>公平份额（fair-share）</strong></li>
<li>基于一个简单的想法：<strong>调度程序的最终目标，是确保每个工作获得一定比例的CPU时间，而不是优化周转时间和响应时间</strong></li>
<li>Key：<strong>如何按比例分配CPU</strong></li>
</ul>
<h4 id="91">9.1、基本概念：彩票数表示份额<a class="headerlink" href="#91" title="Permanent link">&para;</a></h4>
<h4 id="92">9.2、彩票机制<a class="headerlink" href="#92" title="Permanent link">&para;</a></h4>
<ul>
<li>一种方式，利用彩票货币（ticket currency）</li>
<li>另一个有用的机制，彩票转让（ticket transfer）</li>
<li>最后，彩票通胀（ticket inflation）</li>
</ul>
<h4 id="93">9.3、实现<a class="headerlink" href="#93" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>彩票调度</strong>，只需要一个不错的随机数生成器来选择中奖彩票和一个记录系统中所有进程的数据结构（一个列表），以及所有彩票的总数</li>
</ul>
<h4 id="94">9.4、一个例子<a class="headerlink" href="#94" title="Permanent link">&para;</a></h4>
<h4 id="95">9.5、如何分配彩票<a class="headerlink" href="#95" title="Permanent link">&para;</a></h4>
<h4 id="96">9.6、为什么不是确定的<a class="headerlink" href="#96" title="Permanent link">&para;</a></h4>
<ul>
<li>步长调度</li>
</ul>
<h4 id="97">9.7、小结<a class="headerlink" href="#97" title="Permanent link">&para;</a></h4>
<ul>
<li>彩票调度：<strong>通过随机值，聪明地做到了按比例分配</strong></li>
<li>步长调度：<strong>能够确定的获得需要的比例</strong></li>
</ul>
<h4 id="_15">作业<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h4>
<ul>
<li>lottery.py</li>
</ul>
<h4 id="_16">问题<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h4>
<ul>
<li>1、计算3个工作在随机种子为1、2和3时的模拟解</li>
</ul>
<h3 id="chap10">chap10、多处理器调度（高级）<a class="headerlink" href="#chap10" title="Permanent link">&para;</a></h3>
<ul>
<li>multiprocessor scheduling</li>
<li>Key：<strong>如何在多处理器上调度工作</strong></li>
</ul>
<h4 id="101">10.1、背景：多处理架构<a class="headerlink" href="#101" title="Permanent link">&para;</a></h4>
<ul>
<li>与单CPU之间的区别，<strong>核心在于对硬件缓存（cache）的使用，以及多处理器之间共享数据的方式</strong></li>
<li>单CPU系统中，存在多级的硬件缓存（hardware cache）</li>
<li><strong>缓存一致性</strong>（cache coherence）</li>
</ul>
<h4 id="102">10.2、别忘了同步<a class="headerlink" href="#102" title="Permanent link">&para;</a></h4>
<h4 id="103">10.3、最后一个问题：缓存亲和度<a class="headerlink" href="#103" title="Permanent link">&para;</a></h4>
<ul>
<li>cache affinity，<strong>一个进程在某个CPU上运行时，会在该CPU的缓存中维护许多状态</strong></li>
</ul>
<h4 id="104sqms">10.4、单队列调度（SQMS）<a class="headerlink" href="#104sqms" title="Permanent link">&para;</a></h4>
<ul>
<li>将所有需要调度的工作放入一个单独的队列中</li>
<li>SQMS的短板<ul>
<li>第一个是缺乏可扩展性</li>
<li>第二个主要问题是缓存亲和性</li>
</ul>
</li>
</ul>
<h4 id="105">10.5、多队列调度<a class="headerlink" href="#105" title="Permanent link">&para;</a></h4>
<ul>
<li>每个CPU一个队列</li>
</ul>
<h4 id="106linux">10.6、Linux多处理器调度<a class="headerlink" href="#106linux" title="Permanent link">&para;</a></h4>
<ul>
<li>3种调度<ul>
<li>O(1)调度程序，多队列</li>
<li>完全公平调度程序（CFS），多队列</li>
<li>BF调度程序（BFS），单队列</li>
</ul>
</li>
</ul>
<h4 id="107">10.7、小结<a class="headerlink" href="#107" title="Permanent link">&para;</a></h4>
<h3 id="chap11cpu">chap11、关于CPU虚拟化的总结对话<a class="headerlink" href="#chap11cpu" title="Permanent link">&para;</a></h3>
<h3 id="chap12">chap12、关于内存虚拟化的对话<a class="headerlink" href="#chap12" title="Permanent link">&para;</a></h3>
<h3 id="chap13">chap13、抽象:地址空间<a class="headerlink" href="#chap13" title="Permanent link">&para;</a></h3>
<h4 id="131">13.1、早期系统<a class="headerlink" href="#131" title="Permanent link">&para;</a></h4>
<ul>
<li>没有抽象</li>
</ul>
<h4 id="132">13.2、多道程序和时分共享<a class="headerlink" href="#132" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>分时共享的方法</strong>，让一个进程单独占用全部内存一小段时间，然后停止它，并将它所有状态信息保存在磁盘上</li>
</ul>
<h4 id="133">13.3、地址空间<a class="headerlink" href="#133" title="Permanent link">&para;</a></h4>
<ul>
<li>address space，<strong>运行的程序看到的系统中的内存</strong></li>
</ul>
<h4 id="134">13.4、目标<a class="headerlink" href="#134" title="Permanent link">&para;</a></h4>
<ul>
<li>一个目标是<strong>透明</strong>，运行的程序不感知</li>
<li>另一个目标是<strong>效率</strong>，尽可能高效，有时不得不依赖硬件</li>
<li>第三个目标是<strong>保护</strong>，不受其他进程影响，操作系统本身也不会受进程影响</li>
</ul>
<h4 id="135">13.5、小结<a class="headerlink" href="#135" title="Permanent link">&para;</a></h4>
<h3 id="chap14api">chap14、插叙：内存操作API<a class="headerlink" href="#chap14api" title="Permanent link">&para;</a></h3>
<h4 id="141">14.1、内存类型<a class="headerlink" href="#141" title="Permanent link">&para;</a></h4>
<ul>
<li>栈内存，由编译器隐式管理</li>
<li>堆内存，程序员显式调用</li>
</ul>
<h4 id="142malloc">14.2、malloc()调用<a class="headerlink" href="#142malloc" title="Permanent link">&para;</a></h4>
<h4 id="143free">14.3、free()调用<a class="headerlink" href="#143free" title="Permanent link">&para;</a></h4>
<h4 id="144">14.4、常见错误<a class="headerlink" href="#144" title="Permanent link">&para;</a></h4>
<ul>
<li>忘记分配内存</li>
<li>没有分配足够的内存</li>
<li>忘记释放内存</li>
<li>在用完之前释放内存</li>
<li>反复释放内存</li>
<li>错误地调用free()</li>
<li>忘记初始化分配的内存</li>
<li>小结<ul>
<li>利用<code>purify</code>和<code>valgrind</code>工具</li>
</ul>
</li>
</ul>
<h4 id="145">14.5、底层操作系统支持<a class="headerlink" href="#145" title="Permanent link">&para;</a></h4>
<ul>
<li>malloc和free是库调用，不是系统调用，<code>brk()</code>或<code>sbrk()</code>才是系统调用。</li>
<li><code>mmap()</code>调用从操作系统获取内存</li>
</ul>
<h4 id="146">14.6、其他调用<a class="headerlink" href="#146" title="Permanent link">&para;</a></h4>
<ul>
<li><code>calloc()</code>和<code>realloc()</code></li>
</ul>
<h4 id="147">14.7、小结<a class="headerlink" href="#147" title="Permanent link">&para;</a></h4>
<h3 id="chap15">chap15、机制：地址转换<a class="headerlink" href="#chap15" title="Permanent link">&para;</a></h3>
<h4 id="0">0、<a class="headerlink" href="#0" title="Permanent link">&para;</a></h4>
<h4 id="151">15.1、假设<a class="headerlink" href="#151" title="Permanent link">&para;</a></h4>
<ul>
<li>先假设用户的地址空间必须连续地放在物理内存中</li>
<li>假设每个地址空间大小完全一样</li>
</ul>
<h4 id="152">15.2、一个例子<a class="headerlink" href="#152" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>理解地址转换需要什么</strong></li>
</ul>
<h4 id="153">15.3、动态（基于硬件）重定位<a class="headerlink" href="#153" title="Permanent link">&para;</a></h4>
<ul>
<li>基址加虚拟地址（可以看作是地址空间的偏移量）的方式，很容易得到物理地址。<strong>虚拟地址“过大”或者为负数时，会导致异常</strong></li>
</ul>
<h4 id="154">15.4、硬件支持：总结<a class="headerlink" href="#154" title="Permanent link">&para;</a></h4>
<ul>
<li>特权模式（privileged mode）也叫<strong>内核模式</strong></li>
<li>用户模式</li>
</ul>
<h4 id="155">15.5、操作系统的问题<a class="headerlink" href="#155" title="Permanent link">&para;</a></h4>
<h4 id="156">15.6、小结<a class="headerlink" href="#156" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>地址转换（address translation），扩展了受限直接访问的概念</strong></li>
<li>利用地址转换，操作系统可以控制进程的所有内存访问，确保访问在地址空间的界限内</li>
<li><strong>避免内存碎片</strong>，得到了<strong>分段（segmentation）的概念</strong></li>
</ul>
<h3 id="chap16">chap16、分段<a class="headerlink" href="#chap16" title="Permanent link">&para;</a></h3>
<h4 id="0_1">0、<a class="headerlink" href="#0_1" title="Permanent link">&para;</a></h4>
<ul>
<li>之前，一直假设把所有进程的地址空间完整地加载到内存中。</li>
<li><strong>怎样支持大地址空间</strong></li>
</ul>
<h4 id="161">16.1、分段：泛化的基址/界限<a class="headerlink" href="#161" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>在典型的地址空间里有3个逻辑不同的段：代码、栈和堆</strong></li>
<li>分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中的未使用部分占用物理内存</li>
</ul>
<h4 id="162">16.2、我们引用哪个段<a class="headerlink" href="#162" title="Permanent link">&para;</a></h4>
<ul>
<li>硬件在地址转换时使用段寄存器。<strong>它如何知道段内的偏移量，以及地址引用了哪个段？</strong></li>
</ul>
<h4 id="163">16.3、栈怎么办<a class="headerlink" href="#163" title="Permanent link">&para;</a></h4>
<h4 id="164">16.4、支持共享<a class="headerlink" href="#164" title="Permanent link">&para;</a></h4>
<h4 id="165">16.5、细粒度与粗粒度的分段<a class="headerlink" href="#165" title="Permanent link">&para;</a></h4>
<h4 id="166">16.6、操作系统支持<a class="headerlink" href="#166" title="Permanent link">&para;</a></h4>
<ul>
<li>分段带来的问题:<ul>
<li>第一个是，<strong>操作系统在上下文切换时应该做什么？</strong>各个段寄存器中的内容必须保存和恢复</li>
<li>第二个是，<strong>管理物理内存的空闲空间</strong></li>
</ul>
</li>
</ul>
<h4 id="167">16.7、小结<a class="headerlink" href="#167" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>分段的好处是：代码共享</strong></li>
</ul>
<h3 id="chap17">chap17、空闲空间管理<a class="headerlink" href="#chap17" title="Permanent link">&para;</a></h3>
<h4 id="171">17.1、假设<a class="headerlink" href="#171" title="Permanent link">&para;</a></h4>
<ul>
<li>在堆上管理空闲空间的数据结构通常称为空闲列表（free list）。<strong>该结构包含了管理内存区域中所有空闲块的引用</strong>。</li>
</ul>
<h4 id="172">17.2、底层机制<a class="headerlink" href="#172" title="Permanent link">&para;</a></h4>
<h4 id="173">17.3、基本策略<a class="headerlink" href="#173" title="Permanent link">&para;</a></h4>
<ul>
<li>最优匹配（best fit）</li>
<li>最差匹配（worst fit）</li>
<li>首次匹配（first fit）</li>
<li>下次匹配（next fit）</li>
<li>例子</li>
</ul>
<h4 id="174">17.4、其他方式<a class="headerlink" href="#174" title="Permanent link">&para;</a></h4>
<ul>
<li>分离空闲列表（segregated list）<ul>
<li><strong>如果某个应用程序经常申请一种（或几种）大小的内存空间，那就用一个独立的列表，只管理这样大小的对象</strong>。</li>
</ul>
</li>
<li>伙伴系统<ul>
<li>2的整数次幂大小的空闲块</li>
</ul>
</li>
<li>其他想法</li>
</ul>
<h4 id="175">17.5、小结<a class="headerlink" href="#175" title="Permanent link">&para;</a></h4>
<ul>
<li>讨论了最基本的内存分配程序形式。</li>
</ul>
<h3 id="chap18">chap18、分页：介绍<a class="headerlink" href="#chap18" title="Permanent link">&para;</a></h3>
<ul>
<li>关键问题：<strong>如何通过页来实现虚拟内存</strong></li>
</ul>
<h4 id="181">18.1、一个简单的例子<a class="headerlink" href="#181" title="Permanent link">&para;</a></h4>
<ul>
<li>操作系统通常为每个进程保存一个数据结构，称为<strong>页表</strong>（page table），主要作用是：<strong>为地址空间的每个虚拟页面保存地址转换（address translation），从而让我们知道每个页在物理内存中的位置</strong>。</li>
</ul>
<h4 id="182">18.2、页表存在哪里<a class="headerlink" href="#182" title="Permanent link">&para;</a></h4>
<ul>
<li>20位，就需要2的20次方地址转换，<strong>将每个进程的页表存储在内存中</strong></li>
</ul>
<h4 id="183">18.3、列表中究竟有什么<a class="headerlink" href="#183" title="Permanent link">&para;</a></h4>
<ul>
<li>页表是一种数据结构，用于将虚拟地址映射到物理地址。<ul>
<li>可以是<strong>线性页表</strong></li>
<li><strong>PTE（页表项PageTableEntry）</strong>，有效位、保护位、存在位、参考位</li>
</ul>
</li>
</ul>
<h4 id="184">18.4、分页：也很慢<a class="headerlink" href="#184" title="Permanent link">&para;</a></h4>
<h4 id="185">18.5、内存追踪<a class="headerlink" href="#185" title="Permanent link">&para;</a></h4>
<h4 id="186">18.6、小结<a class="headerlink" href="#186" title="Permanent link">&para;</a></h4>
<ul>
<li>分页（paging）比起分段有优点，<strong>不会导致外部碎片、非常灵活</strong></li>
<li>缺点：机器变慢和内存浪费（内存被页表塞满而不是有用的应用程序数据）</li>
<li><strong>要想一个好的分页系统</strong></li>
</ul>
<h4 id="_17">作业<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h4>
<h4 id="_18">问题<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h4>
<h3 id="chap19tlb">chap19、分页：快速地址转换（TLB）<a class="headerlink" href="#chap19tlb" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Key：如何加速地址转换</strong></li>
<li>要使用分页，就要将内存地址空间分成大量固定大小的单元（页），<strong>并且需要记录这些单元的地址映射信息</strong>（一般存储在内存中），<strong>这样在转换虚拟地址时，分布逻辑上需要额外一次的内存访问</strong></li>
<li>增加硬件，<strong>地址转换旁路缓冲存储器（translation-lookaside buffer）TLB</strong>，它是频繁发生的虚拟到物理地址转换的硬件缓存（cache），因此，更好的名称应该是<strong>地址转换缓存（address-translation cache）</strong></li>
</ul>
<h4 id="191tlb">19.1、TLB的基本算法<a class="headerlink" href="#191tlb" title="Permanent link">&para;</a></h4>
<ul>
<li>从虚拟地址中提取页号（VPN），检查TLB是否有该VPN的转换映射，有就命中，从TLB中取出页帧号（PFN），与原来虚拟地址中的偏移量组合形成期望的物理地址（PA），并访问内存。</li>
</ul>
<h4 id="192">19.2、示例：访问数组<a class="headerlink" href="#192" title="Permanent link">&para;</a></h4>
<h4 id="193tlb">19.3、谁来处理TLB未命中<a class="headerlink" href="#193tlb" title="Permanent link">&para;</a></h4>
<ul>
<li>硬件或软件</li>
</ul>
<h4 id="194tlb">19.4、TLB的内容<a class="headerlink" href="#194tlb" title="Permanent link">&para;</a></h4>
<ul>
<li>硬件TLB中的内容，典型的TLB有32项、64项或128项，<strong>并且是全相联的（fully associative）</strong></li>
</ul>
<h4 id="195tlb">19.5、上下文切换时对TLB的处理<a class="headerlink" href="#195tlb" title="Permanent link">&para;</a></h4>
<h4 id="196tlb">19.6、TLB替换策略<a class="headerlink" href="#196tlb" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>缓存策略</strong>（cache replacement）</li>
<li>关键问题：<strong>如何设计TLB替换策略</strong></li>
</ul>
<h4 id="197tlb">19.7、实际系统的TLB表项<a class="headerlink" href="#197tlb" title="Permanent link">&para;</a></h4>
<h3 id="chap20">chap20、分页：较小的表<a class="headerlink" href="#chap20" title="Permanent link">&para;</a></h3>
<ul>
<li>解决分页引入的第二个问题：<strong>页表太大，因而消耗的内存太多</strong></li>
<li>关键问题：<strong>如何让页表更小？</strong></li>
</ul>
<h4 id="201">20.1、简单的解决方案：更大的页<a class="headerlink" href="#201" title="Permanent link">&para;</a></h4>
<h4 id="202">20.2、混合方法：分页和分段<a class="headerlink" href="#202" title="Permanent link">&para;</a></h4>
<h4 id="203">20.3、多级页表<a class="headerlink" href="#203" title="Permanent link">&para;</a></h4>
<h5 id="_19">详细的多级示例<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h5>
<h5 id="_20">超过两级<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h5>
<h5 id="tlb">地址转换过程：记住TLB<a class="headerlink" href="#tlb" title="Permanent link">&para;</a></h5>
<h4 id="204">20.4、反向页表<a class="headerlink" href="#204" title="Permanent link">&para;</a></h4>
<h4 id="205">20.5、将页表交换到磁盘<a class="headerlink" href="#205" title="Permanent link">&para;</a></h4>
<h4 id="206">20.6、小结<a class="headerlink" href="#206" title="Permanent link">&para;</a></h4>
<ul>
<li>构建真正的页表，不一定只是线性数组，<strong>而是更复杂的数据结构</strong>。</li>
</ul>
<h3 id="chap21">chap21、超越物理内存：机制<a class="headerlink" href="#chap21" title="Permanent link">&para;</a></h3>
<ul>
<li>关键问题：<strong>如何超越物理内存</strong></li>
</ul>
<h4 id="211">21.1、交换空间<a class="headerlink" href="#211" title="Permanent link">&para;</a></h4>
<h4 id="212">21.2、存在位<a class="headerlink" href="#212" title="Permanent link">&para;</a></h4>
<h4 id="213">21.3、页错误<a class="headerlink" href="#213" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>为什么硬件不能处理页错误</strong></li>
</ul>
<h4 id="214">21.4、内存满了怎么办<a class="headerlink" href="#214" title="Permanent link">&para;</a></h4>
<ul>
<li>页交换策略</li>
</ul>
<h4 id="215">21.5、页错误处理流程<a class="headerlink" href="#215" title="Permanent link">&para;</a></h4>
<h4 id="216">21.6、交换何时真正发生<a class="headerlink" href="#216" title="Permanent link">&para;</a></h4>
<ul>
<li>为了保证有少量的空闲内存，大多数操作系统会设置高水位线（High Watermark，HW）和低水位线（Low Watermark，LW），来帮助决定何时从内存中清除页。</li>
</ul>
<h4 id="217">21.7、小结<a class="headerlink" href="#217" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>存在位</strong>（present bit），告诉我们页是不是在内存中</li>
</ul>
<h3 id="chap22">chap22、超越物理内存：策略<a class="headerlink" href="#chap22" title="Permanent link">&para;</a></h3>
<h4 id="221">22.1、缓存管理<a class="headerlink" href="#221" title="Permanent link">&para;</a></h4>
<h4 id="222">22.2、最优替换策略<a class="headerlink" href="#222" title="Permanent link">&para;</a></h4>
<h4 id="223fifo">22.3、简单策略：FIFO<a class="headerlink" href="#223fifo" title="Permanent link">&para;</a></h4>
<h4 id="224">22.4、另一简单策略：随机<a class="headerlink" href="#224" title="Permanent link">&para;</a></h4>
<h4 id="225lru">22.5、利用历史数据：LRU<a class="headerlink" href="#225lru" title="Permanent link">&para;</a></h4>
<h4 id="226">22.6、工作负载示例<a class="headerlink" href="#226" title="Permanent link">&para;</a></h4>
<h4 id="227">22.7、实现基于历史信息的算法<a class="headerlink" href="#227" title="Permanent link">&para;</a></h4>
<ul>
<li>关键问题：<strong>如何实现LRU替换策略</strong></li>
</ul>
<h4 id="228lru">22.8、近似LRU<a class="headerlink" href="#228lru" title="Permanent link">&para;</a></h4>
<h4 id="229">22.9、考虑脏页<a class="headerlink" href="#229" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>硬件应该包括一个修改位（modified bit）</strong></li>
</ul>
<h4 id="2210">22.10、其他虚拟内存策略<a class="headerlink" href="#2210" title="Permanent link">&para;</a></h4>
<h4 id="2211">22.11、抖动<a class="headerlink" href="#2211" title="Permanent link">&para;</a></h4>
<h4 id="2212">22.12、小结<a class="headerlink" href="#2212" title="Permanent link">&para;</a></h4>
<h3 id="chap23vaxvms">chap23、VAX/VMS虚拟内存系统<a class="headerlink" href="#chap23vaxvms" title="Permanent link">&para;</a></h3>
<h4 id="231">23.1、背景<a class="headerlink" href="#231" title="Permanent link">&para;</a></h4>
<h4 id="232">23.2、内存管理硬件<a class="headerlink" href="#232" title="Permanent link">&para;</a></h4>
<h4 id="233">23.3、一个真实的地址空间<a class="headerlink" href="#233" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>为什么空指针访问会导致段错误</strong>，硬件试图在TLB中查找VPN（这里是0），遇到TLB未命中。查询页表，并且发现VPN 0的条目被标记为无效。把控制权交给OS</li>
</ul>
<h4 id="234">23.4、页替换<a class="headerlink" href="#234" title="Permanent link">&para;</a></h4>
<h5 id="fifo">分段FIFO<a class="headerlink" href="#fifo" title="Permanent link">&para;</a></h5>
<h5 id="_21">页聚集<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h5>
<h4 id="235">23.5、其他漂亮的虚拟内存技巧<a class="headerlink" href="#235" title="Permanent link">&para;</a></h4>
<ul>
<li>VMS有另外两个现在成为标准和技巧：<strong>按需置零和写入时复制</strong></li>
</ul>
<h4 id="236">23.6、小结<a class="headerlink" href="#236" title="Permanent link">&para;</a></h4>
<h3 id="chap24">chap24、内存虚拟化总结对话<a class="headerlink" href="#chap24" title="Permanent link">&para;</a></h3>
<h3 id="chap25">chap25、并发的对话<a class="headerlink" href="#chap25" title="Permanent link">&para;</a></h3>
<ul>
<li>吃一个桃子？</li>
</ul>
<h3 id="chap26">chap26、并发：简介<a class="headerlink" href="#chap26" title="Permanent link">&para;</a></h3>
<h4 id="263">26.3、问题的核心：自由安排<a class="headerlink" href="#263" title="Permanent link">&para;</a></h4>
<h4 id="264">26.4、原子性<a class="headerlink" href="#264" title="Permanent link">&para;</a></h4>
<h3 id="chap27api">chap27、插曲：线程API<a class="headerlink" href="#chap27api" title="Permanent link">&para;</a></h3>
<h4 id="271">27.1、线程创建<a class="headerlink" href="#271" title="Permanent link">&para;</a></h4>
<h4 id="272">27.2、线程完成<a class="headerlink" href="#272" title="Permanent link">&para;</a></h4>
<ul>
<li>如果你想等待线程完成，会发生什么情况？你需要做一些特别的事情来等待完成。</li>
</ul>
<ul>
<li><code>pthread_join(pthread_t, )</code><ul>
<li>第1个参数，用于指定要等待的线程</li>
<li>第2个参数，指向你希望得到的返回值</li>
</ul>
</li>
</ul>
<h4 id="273">27.3、锁<a class="headerlink" href="#273" title="Permanent link">&para;</a></h4>
<ul>
<li>通过<strong>锁来互斥进入临界区</strong>的那些函数</li>
</ul>
<h4 id="274">27.4、条件变量<a class="headerlink" href="#274" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>当线程之间必须发生某种信号时，如果一个线程在等待另一个线程继续执行某些操作</strong>，条件变量就很有用。</li>
<li><strong>要使用条件变量，必须另外有一个与此条件相关的锁</strong>。</li>
<li><code>int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);</code><strong>使调用线程进入休眠状态</strong>，因此等待其它线程发出信号，通常当程序中的某些内容发生变化时，现在正在休眠的线程可能会关心它。</li>
</ul>
<h4 id="275">27.5、编译和运行<a class="headerlink" href="#275" title="Permanent link">&para;</a></h4>
<ul>
<li>增加<code>-pthread</code>标记，例：<code>gcc -o main main.c -Wall -pthread</code></li>
</ul>
<h4 id="276">27.6、小结<a class="headerlink" href="#276" title="Permanent link">&para;</a></h4>
<ul>
<li><code>man -k pthread</code></li>
<li><strong>线程难的部分不是API，而是如何构建并发程序的棘手逻辑</strong>。</li>
</ul>
<h3 id="chap28">chap28、锁<a class="headerlink" href="#chap28" title="Permanent link">&para;</a></h3>
<h4 id="281">28.1、锁的基本思想<a class="headerlink" href="#281" title="Permanent link">&para;</a></h4>
<ul>
<li>锁为程序员提供了最小程度的调度控制。通过给临界区加锁，可以保证临界区内只有一个线程活跃。<strong>锁将原本由操作系统调度的混乱状态变得更为可控</strong>。</li>
</ul>
<pre class="highlight"><code class="language-c++">lock_t mutex;//some globally-allocated lock 'mutex'
...
lock(&amp;mutex);
balance = balance + 1;
unlock(&amp;mutex);</code></pre>
<h4 id="282pthread">28.2、pthread锁<a class="headerlink" href="#282pthread" title="Permanent link">&para;</a></h4>
<ul>
<li>POSIX库将锁称为<strong>互斥量（mutex）</strong>，因为它被用来提供线程之间的互斥。即当一个线程在临界区，它能够阻止其他线程进入直到本线程离开临界区。</li>
</ul>
<h4 id="283">28.3、实现一个锁<a class="headerlink" href="#283" title="Permanent link">&para;</a></h4>
<ul>
<li>怎样实现一个锁？</li>
<li><strong>我们需要硬件和操作系统的帮助来实现一个可用的锁</strong>。</li>
</ul>
<h4 id="284">28.4、评价锁<a class="headerlink" href="#284" title="Permanent link">&para;</a></h4>
<ul>
<li>评价锁是否能工作，应设立一些标准：<ul>
<li>1、锁是否能完成它的基本任务，即<strong>提供互斥（mutual exclusion）</strong>，锁是否有效，能够阻止多个线程进入临界区</li>
<li>2、公平性（fairness）：当锁可用时，是否每一个竞争线程有公平的机会抢到锁？</li>
<li>3、性能（performance）：使用锁之后增加的时间开销</li>
</ul>
</li>
</ul>
<h4 id="285">28.5、控制中断<a class="headerlink" href="#285" title="Permanent link">&para;</a></h4>
<ul>
<li>临界区关闭中断，为单处理器系统开发，<strong>优点是简单、缺点很多</strong><ul>
<li>1、一个贪婪的程序可能在它开始时就调用lock()，从而独占处理器</li>
<li>2、不支持多处理器</li>
<li>3、关闭中断导致中断丢失，可能会导致严重的系统问题</li>
<li>4、系统低</li>
</ul>
</li>
</ul>
<h4 id="286">28.6、测试并设置指令（原子交换）<a class="headerlink" href="#286" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>test and set</strong><ul>
<li>首先实现一个不依赖它的锁，用一个变量标记锁是否被持有</li>
</ul>
</li>
</ul>
<h4 id="287">28.7、实现可用的自旋锁<a class="headerlink" href="#287" title="Permanent link">&para;</a></h4>
<h4 id="288">28.8、评价自旋锁<a class="headerlink" href="#288" title="Permanent link">&para;</a></h4>
<ul>
<li>1、正确性（correctness）</li>
<li>2、公平性</li>
<li>3、性能</li>
</ul>
<h4 id="289">28.9、比较并交换<a class="headerlink" href="#289" title="Permanent link">&para;</a></h4>
<ul>
<li>比较并交换的思路是：<strong>检测ptr指向的值是否和expected相等</strong></li>
</ul>
<h4 id="2810">28.10、链接的加载和条件式存储指令<a class="headerlink" href="#2810" title="Permanent link">&para;</a></h4>
<ul>
<li>链接的加载指令</li>
<li><strong>条件式存储（store-conditional）指令</strong></li>
</ul>
<h4 id="2811">28.11、获取并增加<a class="headerlink" href="#2811" title="Permanent link">&para;</a></h4>
<ul>
<li>硬件原语：<strong>获取并增加（fetch-and-add）指令</strong></li>
</ul>
<h4 id="2812">28.12、自旋过多：怎么办<a class="headerlink" href="#2812" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Key：怎样避免自旋</strong></li>
</ul>
<h4 id="2813">28.13、简单方法：让出来吧，宝贝<a class="headerlink" href="#2813" title="Permanent link">&para;</a></h4>
<ul>
<li>要自旋的时候，放弃CPU，<strong>调用<code>yield()</code></strong></li>
</ul>
<h4 id="2814">28.14、使用队列：休眠替代自旋<a class="headerlink" href="#2814" title="Permanent link">&para;</a></h4>
<ul>
<li>park()能够让调用线程休眠，unpark(threadID)则会唤醒threadID标识的线程</li>
</ul>
<h4 id="2815">28.15、不同操作系统，不同实现<a class="headerlink" href="#2815" title="Permanent link">&para;</a></h4>
<h4 id="2816">28.16、两阶段锁<a class="headerlink" href="#2816" title="Permanent link">&para;</a></h4>
<ul>
<li>第一阶段会先自旋一段时间，希望它可以获取锁</li>
<li>如果第一个自旋阶段没有获得锁，第二阶段调用者会睡眠，直到锁可用</li>
</ul>
<h4 id="2817">28.17、小结<a class="headerlink" href="#2817" title="Permanent link">&para;</a></h4>
<h4 id="_22">作业<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h4>
<h4 id="_23">问题<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h4>
<ul>
<li>1、</li>
<li>9、现在用不同的-i值运行代码。你看到了什么样的不同行为？</li>
</ul>
<h3 id="chap29">chap29、基于锁的并发数据结构<a class="headerlink" href="#chap29" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Key：如何给数据结构加锁？</strong></li>
</ul>
<h4 id="291">29.1、并发计数器<a class="headerlink" href="#291" title="Permanent link">&para;</a></h4>
<h5 id="_24">简单但无法扩展<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h5>
<h5 id="_25">可扩展的计数<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h5>
<h4 id="292">29.2、并发链表<a class="headerlink" href="#292" title="Permanent link">&para;</a></h4>
<h5 id="_26">扩展链表<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h5>
<h4 id="293">29.3、并发队列<a class="headerlink" href="#293" title="Permanent link">&para;</a></h4>
<h4 id="294">29.4、并发散列表<a class="headerlink" href="#294" title="Permanent link">&para;</a></h4>
<ul>
<li>code</li>
</ul>
<pre class="highlight"><code class="language-c">#define BUCKETS(101)
typedef struct _hash_t {
    list_t lists[BUCKETS];
}hash_t;

void Hash_Init(hash_t *H) {
    int i;
    for(i=0;i&lt;BUCKETS;i++){
        List_Init(&amp;H-&gt;list[i]);
    }
}

int Hash_Insert(hash_t *H, int key) {
    int bucket = key % BUCKETS;
    retun list_Insert(&amp;H-&gt;lists[bucket],key);
}

int Hash_Lookup(hash_t *H, int key) {
    int bucket = key % BUCKETS;
    retun list_Lookup(&amp;H-&gt;lists[bucket],key);
}</code></pre>
<h4 id="295">29.5、小结<a class="headerlink" href="#295" title="Permanent link">&para;</a></h4>
<h3 id="chap30">chap30、条件变量<a class="headerlink" href="#chap30" title="Permanent link">&para;</a></h3>
<ul>
<li>在很多情况下，线程需要检查某一条件（condition）满足之后，才会继续运行。</li>
<li><strong>父线程需要检查子线程是否执行完毕【这通常称为join()】</strong></li>
<li><strong>Key：如何等待一个条件？</strong></li>
<li>Code</li>
</ul>
<pre class="highlight"><code class="language-c">volatile int done = 0;
void *child(void *arg) {
    printf("child\n");
    done = 1;
    return NULL;
}

int main(int argc, char *argv[]) {
    printf("parent:begin\n");
    pthread_t c;
    Pthread_create(&amp;c, NULL, child, NULL);// create child
    while(done == 0)
        ;//spin
    printf("parent:end\n");
    return 0;
}</code></pre>
<h4 id="301">30.1、定义和程序<a class="headerlink" href="#301" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>条件变量</strong>是个显式队列，当某些执行状态（即条件，condition）不满足时，线程可以把自己加入队列，等待该条件。</li>
<li><strong>条件变量有两种相关操作</strong><ul>
<li>wait()，<strong>线程要睡眠的时候</strong></li>
<li>signal()，<strong>线程想唤醒等待在某个条件变量上的睡眠线程时</strong></li>
</ul>
</li>
</ul>
<h4 id="302">30.2、生产者/消费者（有界缓冲区）问题<a class="headerlink" href="#302" title="Permanent link">&para;</a></h4>
<h5 id="_27">有问题的方案<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h5>
<h5 id="while">较好但仍有问题的方案：使用while语句<a class="headerlink" href="#while" title="Permanent link">&para;</a></h5>
<h5 id="_28">单值缓冲区的生产者/消费者方案<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h5>
<h5 id="_29">最终的生产者/消费者方案<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h5>
<h4 id="303">30.3、覆盖条件<a class="headerlink" href="#303" title="Permanent link">&para;</a></h4>
<h4 id="304">30.4、小结<a class="headerlink" href="#304" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>当某些程序状态不符合要求时，通过允许线程进入休眠状态</strong>，条件变量使我们能够漂亮地解决许多重要的同步问题</li>
</ul>
<h3 id="chap31">chap31、信号量<a class="headerlink" href="#chap31" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Key：如何使用信号量</strong></li>
</ul>
<h4 id="311">31.1、信号量的含义<a class="headerlink" href="#311" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>信号量是有一个整数值的对象，可以用2个函数来操作它</strong>，<code>sem_wait()</code>和<code>sem_post()</code></li>
</ul>
<h4 id="312">31.2、二值信号量（锁）<a class="headerlink" href="#312" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>用信号量作为锁</strong></li>
</ul>
<h4 id="313">31.3、信号量用作条件变量<a class="headerlink" href="#313" title="Permanent link">&para;</a></h4>
<h4 id="314">31.4、生产者/消费者（有界缓冲区）问题<a class="headerlink" href="#314" title="Permanent link">&para;</a></h4>
<h5 id="_30">第一次尝试<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h5>
<h5 id="_31">解决方案：增加互斥<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h5>
<h5 id="_32">避免死锁<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h5>
<h5 id="_33">最后，可行的方案<a class="headerlink" href="#_33" title="Permanent link">&para;</a></h5>
<h4 id="315-">31.5、读者-写者锁<a class="headerlink" href="#315-" title="Permanent link">&para;</a></h4>
<h4 id="316">31.6、哲学家就餐问题<a class="headerlink" href="#316" title="Permanent link">&para;</a></h4>
<h5 id="_34">有问题的解决方案<a class="headerlink" href="#_34" title="Permanent link">&para;</a></h5>
<h5 id="_35">一种方案：破除依赖<a class="headerlink" href="#_35" title="Permanent link">&para;</a></h5>
<h4 id="317">31.7、如何实现信号量<a class="headerlink" href="#317" title="Permanent link">&para;</a></h4>
<h4 id="318">31.8、小结<a class="headerlink" href="#318" title="Permanent link">&para;</a></h4>
<h3 id="chap32">chap32、常见并发问题<a class="headerlink" href="#chap32" title="Permanent link">&para;</a></h3>
<h4 id="321">32.1、有哪些类型的缺陷<a class="headerlink" href="#321" title="Permanent link">&para;</a></h4>
<ul>
<li>死锁</li>
<li>非死锁</li>
</ul>
<h4 id="322">32.2、非死锁缺陷<a class="headerlink" href="#322" title="Permanent link">&para;</a></h4>
<h5 id="_36">违反原子性缺陷<a class="headerlink" href="#_36" title="Permanent link">&para;</a></h5>
<h5 id="_37">违反顺序缺陷<a class="headerlink" href="#_37" title="Permanent link">&para;</a></h5>
<h5 id="_38">非死锁缺陷：小结<a class="headerlink" href="#_38" title="Permanent link">&para;</a></h5>
<h4 id="323">32.3、死锁缺陷<a class="headerlink" href="#323" title="Permanent link">&para;</a></h4>
<h5 id="_39">为什么发生死锁<a class="headerlink" href="#_39" title="Permanent link">&para;</a></h5>
<h5 id="_40">产生死锁的条件<a class="headerlink" href="#_40" title="Permanent link">&para;</a></h5>
<h5 id="_41">预防<a class="headerlink" href="#_41" title="Permanent link">&para;</a></h5>
<h5 id="_42">通过调度避免死锁<a class="headerlink" href="#_42" title="Permanent link">&para;</a></h5>
<h5 id="_43">检查和恢复<a class="headerlink" href="#_43" title="Permanent link">&para;</a></h5>
<h4 id="324">32.4、小结<a class="headerlink" href="#324" title="Permanent link">&para;</a></h4>
<h3 id="chap33">chap33、基于事件的并发（进阶）<a class="headerlink" href="#chap33" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Key：不用线程，如何构建并发服务器</strong></li>
</ul>
<h4 id="331">33.1、基本想法：事件循环<a class="headerlink" href="#331" title="Permanent link">&para;</a></h4>
<ul>
<li>Code</li>
</ul>
<pre class="highlight"><code class="language-c">while(1) {
    events = getEvents();
    for (e in events) 
        processEvent(e);
}</code></pre>
<h4 id="332apiselectpoll">33.2、重要API：select()（或poll()）<a class="headerlink" href="#332apiselectpoll" title="Permanent link">&para;</a></h4>
<h4 id="333select">33.3、使用select()<a class="headerlink" href="#333select" title="Permanent link">&para;</a></h4>
<h4 id="334">33.4、为何更简单？无须锁<a class="headerlink" href="#334" title="Permanent link">&para;</a></h4>
<h4 id="335">33.5、一个问题：阻塞系统调用<a class="headerlink" href="#335" title="Permanent link">&para;</a></h4>
<h4 id="336io">33.6、解决方案：异步I/O<a class="headerlink" href="#336io" title="Permanent link">&para;</a></h4>
<h4 id="337">33.7、另一个问题：状态管理<a class="headerlink" href="#337" title="Permanent link">&para;</a></h4>
<h4 id="338">33.8、什么事情仍然很难<a class="headerlink" href="#338" title="Permanent link">&para;</a></h4>
<h3 id="chap34">chap34、并发的总结对话<a class="headerlink" href="#chap34" title="Permanent link">&para;</a></h3>
<ul>
<li>尽可能简单。<strong>避免复杂的线程交互，使用已被证实的线程交互方式</strong></li>
</ul>
<h3 id="chap35">chap35、关于持久性的对话<a class="headerlink" href="#chap35" title="Permanent link">&para;</a></h3>
<h3 id="chap36io">chap36、I/O设备<a class="headerlink" href="#chap36io" title="Permanent link">&para;</a></h3>
<ul>
<li>Key：<strong>如何将I/O集成进计算机系统中</strong></li>
</ul>
<h4 id="361">36.1、系统架构<a class="headerlink" href="#361" title="Permanent link">&para;</a></h4>
<ul>
<li>物理布局及造价成本，<strong>让要求高性能的设备（比如显卡）离CPU更近一些，低性能的设备离CPU远一些</strong></li>
</ul>
<h4 id="362">36.2、标准设备<a class="headerlink" href="#362" title="Permanent link">&para;</a></h4>
<ul>
<li>第一部分是<strong>向系统其他部分展现的硬件接口</strong></li>
<li>第二部分是<strong>它的内部结构</strong>，这部分包含设备相关的特定实现，负责具体实现设备展示给系统的抽象接口</li>
</ul>
<h4 id="363">36.3、标准协议<a class="headerlink" href="#363" title="Permanent link">&para;</a></h4>
<ul>
<li>一个（简化的）设备接口包含3个寄存器<ul>
<li>状态寄存器：可以读取并查看设备的当前状态</li>
<li>命令寄存器：用于通知设备执行某个具体任务</li>
<li>数据寄存器：将数据传给设备或从设备接收数据</li>
</ul>
</li>
<li>协议包含4步<ul>
<li>第1步</li>
<li>第2步</li>
<li>第3步</li>
<li>第4步</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-c++">while(STATUS == BUSY)
    ; //wait until device is not busy
write data to DATA register
write command to COMMAND regiser
    (Doing so starts the device and executes the command)
while(STATUS == BUSY)
    ;//wait until device is done with your request</code></pre>
<ul>
<li>Key，<strong>如何减少轮询开销</strong><ul>
<li>利用中断</li>
</ul>
</li>
</ul>
<h4 id="364cpu">36.4、利用中断减少CPU开销<a class="headerlink" href="#364cpu" title="Permanent link">&para;</a></h4>
<ul>
<li>高性能场景，不要用中断</li>
<li>最好不要使用中断的场景是<strong>网络</strong></li>
</ul>
<h4 id="365dma">36.5、利用DMA进行更高效的数据传送<a class="headerlink" href="#365dma" title="Permanent link">&para;</a></h4>
<ul>
<li>Key，<strong>如何减少PIO的开销</strong></li>
<li>DMA引擎是系统中的一个特殊设备，它可以协调完成内存和设备间的数据传递，不需要CPU介入。</li>
<li><strong>DMA工作过程</strong>：<ul>
<li>为了能够将数据传送给设备，OS会能过编程告诉DMA引擎数据在内存的位置，要拷贝的大小以及要拷贝到哪个设备。</li>
</ul>
</li>
<li><strong>数据的拷贝工作都是由DMA控制器来完成的</strong>。</li>
</ul>
<h4 id="366">36.6、设备交互的方法<a class="headerlink" href="#366" title="Permanent link">&para;</a></h4>
<ul>
<li>Key，<strong>如何与设备通信</strong><ul>
<li>第1种：<strong>用明确的I/O指令</strong></li>
<li>第2种：内存映射I/O，<strong>好处是，不需要引入新指令来实现设备交互</strong></li>
</ul>
</li>
</ul>
<h4 id="367">36.7、纳入操作系统：设备驱动程序<a class="headerlink" href="#367" title="Permanent link">&para;</a></h4>
<ul>
<li>Key，<strong>如何实现一个设备无关的操作系统</strong><ul>
<li>抽象（abstraction）技术</li>
</ul>
</li>
</ul>
<h4 id="368ide">36.8、案例研究：简单的IDE磁盘驱动程序<a class="headerlink" href="#368ide" title="Permanent link">&para;</a></h4>
<h4 id="369">36.9、历史记录<a class="headerlink" href="#369" title="Permanent link">&para;</a></h4>
<ul>
<li>在20世纪50年代中期，就有系统的I/O设备可以直接和内存交互，并在完成后中断CPU。</li>
</ul>
<h4 id="3610">36.10、小结<a class="headerlink" href="#3610" title="Permanent link">&para;</a></h4>
<ul>
<li>中断和DMA</li>
<li>I/O指令和内存映射I/O</li>
</ul>
<h3 id="chap37">chap37、磁盘驱动器<a class="headerlink" href="#chap37" title="Permanent link">&para;</a></h3>
<h4 id="371">37.1、接口<a class="headerlink" href="#371" title="Permanent link">&para;</a></h4>
<ul>
<li>扇区</li>
<li>地址空间，address space</li>
</ul>
<h4 id="372">37.2、基本几何形状<a class="headerlink" href="#372" title="Permanent link">&para;</a></h4>
<h4 id="373">37.3、简单的磁盘驱动器<a class="headerlink" href="#373" title="Permanent link">&para;</a></h4>
<ul>
<li>单磁道延迟:旋转延迟</li>
<li>多磁道:寻道时间</li>
<li>一些其他细节</li>
</ul>
<h4 id="374io">37.4、I/O时间:用数学<a class="headerlink" href="#374io" title="Permanent link">&para;</a></h4>
<h4 id="375">37.5、磁盘调度<a class="headerlink" href="#375" title="Permanent link">&para;</a></h4>
<ul>
<li>SSTF:最短寻道时间优先</li>
<li>电梯（SCAN或C-SCAN）</li>
<li>SPTF:最短定位时间优先</li>
<li>其他调度问题</li>
</ul>
<h4 id="376">37.6、小结<a class="headerlink" href="#376" title="Permanent link">&para;</a></h4>
<h3 id="chap38raid">chap38、RAID<a class="headerlink" href="#chap38raid" title="Permanent link">&para;</a></h3>
<h4 id="381raid">38.1、接口和RAID内部<a class="headerlink" href="#381raid" title="Permanent link">&para;</a></h4>
<h4 id="382">38.2、故障模型<a class="headerlink" href="#382" title="Permanent link">&para;</a></h4>
<h4 id="383raid">38.3、如何评估RAID<a class="headerlink" href="#383raid" title="Permanent link">&para;</a></h4>
<h4 id="384raid0">38.4、RAID0级:条带化<a class="headerlink" href="#384raid0" title="Permanent link">&para;</a></h4>
<h4 id="385raid1">38.5、RAID1级:镜像<a class="headerlink" href="#385raid1" title="Permanent link">&para;</a></h4>
<h4 id="386raid4">38.6、RAID4级:通过奇偶校验节省空间<a class="headerlink" href="#386raid4" title="Permanent link">&para;</a></h4>
<h4 id="387raid5">38.7、RAID5级:旋转奇偶校验<a class="headerlink" href="#387raid5" title="Permanent link">&para;</a></h4>
<h4 id="388raid">38.8、RAID比较:总结<a class="headerlink" href="#388raid" title="Permanent link">&para;</a></h4>
<h4 id="389raid">38.9、其他有趣的RAID问题<a class="headerlink" href="#389raid" title="Permanent link">&para;</a></h4>
<h4 id="3810">38.10、小结<a class="headerlink" href="#3810" title="Permanent link">&para;</a></h4>
<ul>
<li>RAID将大量独立磁盘扩充成更大、更可靠的单一实体。并且是透明的。</li>
</ul>
<h3 id="chap39">chap39、插叙:文件和目录<a class="headerlink" href="#chap39" title="Permanent link">&para;</a></h3>
<h3 id="chap40">chap40、文件系统实现<a class="headerlink" href="#chap40" title="Permanent link">&para;</a></h3>
<h4 id="401">40.1、思考方式<a class="headerlink" href="#401" title="Permanent link">&para;</a></h4>
<ul>
<li>第一个方面是，文件系统的数据结构，<strong>哪些类型的结构来组织来数据和元数据</strong></li>
<li>第二个方面是，访问方法 <strong>如何将进程发出的调用映射到结构上的？在系统调用期间读取哪些数据结构？改写哪些结构？这些步骤的执行效率如何？</strong></li>
</ul>
<h4 id="402">40.2、整体组织<a class="headerlink" href="#402" title="Permanent link">&para;</a></h4>
<h4 id="403inode">40.3、文件组织:inode<a class="headerlink" href="#403inode" title="Permanent link">&para;</a></h4>
<ul>
<li>多级索引</li>
</ul>
<h4 id="404">40.4、目录组织<a class="headerlink" href="#404" title="Permanent link">&para;</a></h4>
<ul>
<li><em>书中是简单的线性目录列表，看下真实的文件系统如何的？</em></li>
</ul>
<h4 id="405">40.5、空闲空间管理<a class="headerlink" href="#405" title="Permanent link">&para;</a></h4>
<ul>
<li>位图</li>
</ul>
<h4 id="406">40.6、访问路径:读取和写入<a class="headerlink" href="#406" title="Permanent link">&para;</a></h4>
<h5 id="4061">40.6.1、从磁盘读取文件<a class="headerlink" href="#4061" title="Permanent link">&para;</a></h5>
<ul>
<li><code>open("/foo/bar")</code>，先根目录，再遍历foo目录，最后找到bar的inode号，再读入内存，权限检查后，返回文件描述符。</li>
<li>打开后，再read系统调用，查找块的位置，更新inode的最后访问时间</li>
</ul>
<h5 id="4062">40.6.2、写入磁盘<a class="headerlink" href="#4062" title="Permanent link">&para;</a></h5>
<ul>
<li>5次I/O<ul>
<li>读取位图</li>
<li>写入位图</li>
<li>两次读取，写入inode</li>
<li>写入真正的数据块本身</li>
</ul>
</li>
</ul>
<h4 id="407">40.7、缓存和缓冲<a class="headerlink" href="#407" title="Permanent link">&para;</a></h4>
<h4 id="408">40.8、小结<a class="headerlink" href="#408" title="Permanent link">&para;</a></h4>
<h3 id="chap41">chap41、局部性和快速文件系统<a class="headerlink" href="#chap41" title="Permanent link">&para;</a></h3>
<h4 id="411">41.1、问题：性能不佳<a class="headerlink" href="#411" title="Permanent link">&para;</a></h4>
<h4 id="412ffs">41.2、FFS：磁盘意识是解决方案<a class="headerlink" href="#412ffs" title="Permanent link">&para;</a></h4>
<h4 id="413">41.3、组织结构：柱面组<a class="headerlink" href="#413" title="Permanent link">&para;</a></h4>
<h4 id="414">41.4、策略：如何分配文件和目录<a class="headerlink" href="#414" title="Permanent link">&para;</a></h4>
<ul>
<li>首先，目录的放置</li>
<li>对于文件，FFS做两件事：<ul>
<li>首先，它确保将文件的数据块分配到与其inode相同的组中，从而防止inode和数据之间的长时间寻道</li>
<li>其次，它将位于同一目录中的所有文件，放在它们所在目录的柱面组中</li>
</ul>
</li>
</ul>
<h4 id="415">41.5、测量文件的局部性<a class="headerlink" href="#415" title="Permanent link">&para;</a></h4>
<h4 id="416">41.6、大文件例外<a class="headerlink" href="#416" title="Permanent link">&para;</a></h4>
<h4 id="417ffs">41.7、关于FFS的其他几件事<a class="headerlink" href="#417ffs" title="Permanent link">&para;</a></h4>
<h4 id="418">41.8、小结<a class="headerlink" href="#418" title="Permanent link">&para;</a></h4>
<h3 id="chap42fsck">chap42、崩溃一致性:FSCK和日志<a class="headerlink" href="#chap42fsck" title="Permanent link">&para;</a></h3>
<ul>
<li>crash-consistency problem</li>
</ul>
<h4 id="421">42.1、一个详细的例子<a class="headerlink" href="#421" title="Permanent link">&para;</a></h4>
<h4 id="4221">42.2、解决方案1:文件系统检查程序<a class="headerlink" href="#4221" title="Permanent link">&para;</a></h4>
<h4 id="4232">42.3、解决方案2:日志（或预写日志）<a class="headerlink" href="#4232" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>基本思路</strong>：更新磁盘时，在覆写结构之前，首先写下一点小注记，描述你将要做的事情。写下这个注记就是“预写”部分，我们把它写入一个结构，并组织成“日志”。<strong>有了预写日志</strong></li>
<li>ext3比ext2就是多了<strong>Journal</strong>（形象图上），P385</li>
</ul>
<h5 id="4231">42.3.1、数据日志<a class="headerlink" href="#4231" title="Permanent link">&para;</a></h5>
<h5 id="4232_1">42.3.2、恢复<a class="headerlink" href="#4232_1" title="Permanent link">&para;</a></h5>
<p>42.3.3、批处理日志更新</p>
<p>42.3.4、使日志有限</p>
<p>42.3.5、元数据日志</p>
<p>42.3.6、棘手的情况：块复用</p>
<p>42.3.7、总结日志：时间线</p>
<h4 id="4243">42.4、解决方案3:其它方法<a class="headerlink" href="#4243" title="Permanent link">&para;</a></h4>
<h4 id="425">42.5、小结<a class="headerlink" href="#425" title="Permanent link">&para;</a></h4>
<h3 id="chap43">chap43、日志结构文件系统<a class="headerlink" href="#chap43" title="Permanent link">&para;</a></h3>
<h3 id="chap44">chap44、数据完整性和保护<a class="headerlink" href="#chap44" title="Permanent link">&para;</a></h3>
<h3 id="chap45">chap45、关于持久性的总结对话<a class="headerlink" href="#chap45" title="Permanent link">&para;</a></h3>
<h3 id="chap46">chap46、关于分布式的对话<a class="headerlink" href="#chap46" title="Permanent link">&para;</a></h3>
<h3 id="chap47">chap47、分布式系统<a class="headerlink" href="#chap47" title="Permanent link">&para;</a></h3>
<h3 id="chap48sunnfs">chap48、Sun的网络文件系统（NFS）<a class="headerlink" href="#chap48sunnfs" title="Permanent link">&para;</a></h3>
<h3 id="chap49andrewafs">chap49、Andrew文件系统（AFS）<a class="headerlink" href="#chap49andrewafs" title="Permanent link">&para;</a></h3>
<h3 id="chap50">chap50、关于分布式的总结对话<a class="headerlink" href="#chap50" title="Permanent link">&para;</a></h3>
<h2 id="_44">履历<a class="headerlink" href="#_44" title="Permanent link">&para;</a></h2>
<ul>
<li>2022年27W（7.5-7.）看Part2并发的chap26，但习题没做和练习，只是有个概念</li>
</ul>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../22C%2B%2Bmodern/%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8C%2B%2B11/" class="btn btn-neutral float-left" title="《深入应用C++11》"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="btn btn-neutral float-right" title="《大话设计模式》">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../../22C%2B%2Bmodern/%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8C%2B%2B11/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
