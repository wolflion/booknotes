## Linux命令行与shell脚本编程大全

+ Part1：Linux命令行（1-10）
+ Part2: shell脚本编程基础（11-16）
  + *我的问题，可能在于，如何用这些（结构化命令）去实现功能*，还是要多练习，多看项目中的shell代码
    + 变量过程中的，**特殊变量**，`$0,$?`，这种的记忆
  + chap15呈现数据
  + chap16控制脚本（`trap, &, jobs, nice, at, cron`）
+ Part3:高级shell脚本编程（17-23）

### chap1、初识Linux shell

chap2、走进shell

chap3、基本的bash shell命令

### chap4、更多的bash shell

#### 4.1、监测程序

##### 4.1.1、探查进程

+ ps

##### 4.1.2、实时监测进程

+ top

##### 4.1.3、结束进程

#### 4.2、监测磁盘空间

##### 4.2.1、挂载存储媒体

4.2.2、使用df命令

4.2.3、使用du命令

#### 4.3、处理数据文件

##### 4.3.1、排序数据

+ sort

##### 4.3.2、搜索数据

+ `grep [option] pattern [file]`
+ **反向搜索，-v**
+ **显示行号，-n**
+ **有多少行含匹配的模式，-c**
+ **有多个匹配模式，用-e**，`grep -e t -e f file1`

4.3.3、压缩数据

4.3.4、归档数据

#### 4.4、小结

chap5、理解shell

chap6、使用Linux环境变量

chap7、理解Linux文件权限

### chap8、管理文件系统

#### 8.3、逻辑卷管理

### chap9、安装软件程序

+ PMS（package management system）

#### 9.1、包管理基础

#### 9.2、基于Debian的系统

+ dpkg是基于Debian系PMS工具的核心
  + apt-get
  + apt-cache
  + aptitude
+ **aptitude**是apt工具和dpkg的前端
  + dpkg是软件包管理系统工具
  + aptitude则是完整的软件包管理系统

##### 9.2.1、用aptitude管理软件包

+ *但我感觉没人用这啊，都用apt-get啊*

##### 9.2.2、用aptitude安装软件包

#### 9.3、基于Red Hat的系统

+ 常见的命令
  + yum，在Red Hat和Fedora中使用
  + urpm，在Mandriva中使用
  + zypper，在openSUSE中使用

##### 9.3.1、列出已安装包

+ `yum list installed`

##### 9.3.6、yum软件仓库

#### 9.4、从源码安装

#### 9.5、小结

### chap10、编辑器

+ *暂时就只看vim这种，其它先不看，lionel*

#### 10.1、vim

##### 10.1.1、检查vim软件包

##### 10.1.2、vim基础

+ 没有指令文件名，**会开辟一段缓冲区**，如果有文件名，就把内容读进缓冲区
+ 两种操作模式
  + 普通模式
  + 插入模式
+ 移动光标
  + h
  + j
  + k
  + l
  + PageDown（Ctrl+F），下翻一屏
  + PageUp
  + G：移到缓冲区的最后一行
  + num G：移到缓冲区的第num行
  + gg：移到缓冲区的第一行
+ 保存
  + q
  + q!
  + w filename
  + wq

##### 10.1.3、编辑数据

+ 命令
  + x
  + dd
  + dw
  + d$
  + J
  + u
  + a
  + A
  + r char
  + R text

##### 10.1.4、复制和粘贴

+ 命令
  + y
  + p

##### 10.1.5、查找和替换

+ 命令
  + `:s/old/new/`
  + `:s/old/new/g`，一行命令替换所有old
  + `:n,ms/old/new/g`，替换行号n和m之间所有old
  + 

### chap11、构建基本脚本

#### 11.1、使用多个命令

+ 用`;`分隔，`date;who`
+ 最大命令行字符数不能超过255

#### 11.2、创建shell脚本文件

+ shell的第一行要指定使用的shell。`#!/bin/bash`  **虽然#是注释符，但第一行是例外**
+ 要找到自己写的shell脚本
  + 将shell脚本的目录添加到PATH环境变量中
  + 在提示符中用绝对或相对路径执行
+ shell脚本的执行权限
  + umask的值
  + umask值决定了源文件的默认权限设置，*022是啥意思？lionel*

#### 11.3、显示消息

+ `echo`中的单引号或双引号的问题
+ `echo -n`参数，*文本串+输出在同一行？lionel*

#### 11.4、使用变量

##### 11.4.1、环境变量

+ `set`命令
+ 环境变量前面加美元符号`$`
  + `echo "The cost of the item is \$15"`会认为是要输入$，没有`\`，会被认为是`$1`+5这样的，可以通过`${15}`的方式来表达
  + `\$`才显示$本身

##### 11.4.2、用户变量

+ **区分大小写，不能出现空格**，长度不超过20
+ `=`两边不能有空格
+ 引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符

##### 11.4.3、命令替换

+ 将命令输出给变量
  + 反引号字符  `
  + `$()`格式

#### 11.5、重定向输入和输出

##### 11.5.1、输出重定向

##### 11.5.2、输入重定向

#### 11.6、管道

##### 11.6.1、expr命令

#### 11.7、执行数学运算

##### 11.7.1、expr命令

+ `expr 1+5`，`expr 5 \*2 `（*要用反斜杠）

##### 11.7.2、使用方括号`$[]`

+ `var1=$[1+5]`

##### 11.7.3、浮点解决方案

+ `bc`的基本用法 

#### 11.8、退出脚本

##### 11.8.1、查出退出状态码

+ `$?`

##### 11.8.2、exit命令

+ `exit 5`，表示`$?`就是5

#### 11.9、小结

+ lionel，都是其它地方总结的
  + `#/## 变量名`：第一个字符/最后一个字符左侧
  + `%/%% 变量名`：第一个字符/最后一个字符右侧
  + `bash .sh文件`执行

### chap12、使用结构化命令

+ **有一类命令会根据条件使脚本跳过某些命令**，这样的命令通常称为**结构化命令**
  + 结构化命令，**允许你改变程序执行的顺序**

#### 12.1、使用if-then语句

```shell
#!/bin/bash
#testing the if statement
if pwd
then
	echo "It worked"
#else
	#echo "else"
fi
```



#### 12.2、if-then-else语句

##### 12.3、嵌套if

+ `elif`组合

#### 12.4、test命令

+ 判断三类条件
+ 方括号定义测试条件，空格

##### 12.4.1、数组比较

+ eq
+ gt

##### 12.4.2、字符串比较

+ 长度非0  `-n str1`
+ 长度为0  `-z str1`

##### 12.4.3、文件比较

#### 12.5、复合条件测试

+ `[ cond1 ] && [ cond2 ]`，还有`||`，**两个空格不能忘**

#### 12.6、if-then的高级特征

##### 12.6.1、使用双括号

+ 使用高级的数学表达式 `(( expression ))`

##### 12.6.2、使用双方括号

+ 字符串比较的高级特性，模式匹配 `[[ ]]`

#### 12.7、case命令

```shell
case var in
par1 | par2) cmd;;
par3 | par4)  cmd;;
*) default cmd;;
esac
```



#### 12.8、小结

### chap13、更多的结构化命令

#### 13.1、for命令

```shell
for var in list
do 
    cmd
done
```



#### 13.2、C语言风格的for命令

#### 13.3、while命令

```shell
while test cmd
do
	cmd
done
```



#### 13.4、until命令

+ 与while相反

13.5、嵌套循环

13.6、循环处理文件数据

#### 13.7、控制循环

##### 13.7.1、break

##### 13.7.2、continue

#### 13.8、处理循环的输出

#### 13.9、实例

##### 13.9.1、查找可执行文件

##### 13.9.2、创建多个用户账户

13.10、小结

### chap14、处理用户输入

#### 14.1、命令行参数

##### 14.1.1、读取参数

+ 位置参数，**属于特殊变量**
  + $0，程序名
  + $1，第1个参数
  + 以此类推

14.1.2、读取脚本名

+ `$0`

14.1.3、测试参数

+ `if[ -n "$1"]`

#### 14.2、特殊参数变量

##### 14.2.1、参数统计

+ `$#`
+ `$[#]`不能在花括号内使用美元符
+ `${!#}`无参数时，返回脚本名

##### 14.2.2、抓取所有的数据

+ `$*`，所有参数当作一个单词保存
+ `$@`，单独处理每一个参数

#### 14.3、移动变量

+ shift命令，`shift 2`一次移动2个位置

14.4、处理选项

14.4.1、查找选项

+ `--`双破折线，表明选项列表结束

14.5、将选项标准化

#### 14.6、获得用户输入

14.6.1、基本的读取

+ read，`read -p`指定提示符

14.6.2、超时

+ `read -t`

14.6.3、隐藏方式读取

+ `read -s`，隐藏密码

##### 14.6.4、从文件中读取

+ `cat test | while read line`

### chap15、呈现数据

#### 15.1、理解输入和输出

##### 15.1.1、标准文件描述符

##### 15.1.2、重定向错误

#### 15.2、在脚本中重定向输出

##### 15.2.1、临时重定向

##### 15.2.2、永久重定向

#### 15.3、在脚本中重定向输入

+ `exec 0< testfile`

#### 15.4、创建自己的重定向

##### 15.4.1、创建输出文件描述符

##### 15.4.2、重定向文件描述符

##### 15.4.3、创建输入文件描述符

##### 15.4.4、创建读写文件描述符

##### 15.4.5、关闭文件描述符

#### 15.5、列出打开的文件描述符

#### 15.6、阻止命令输出

#### 15.7、创建临时文件

##### 15.7.1、创建本地临时文件

##### 15.7.2、在/tmp目录创建临时文件

+ `mktemp -t`选项

##### 15.7.3、创建临时目录

+ `-d`选项

#### 15.8、记录消息

15.9、实例

15.10、小结

### chap16、控制脚本

+ 也就是运行，除了**实时模式**，还有其它方式
  + 向脚本发送信号
  + 修改脚本的优先级
  + 在脚本运行时切换到运行模式

#### 16.1、处理信号

##### 16.1.1、重温Linux信号

+ shell会**忽视SIGQUIT，SIGTERM**，**处理SIGHUP，SIGINT**

##### 16.1.2、生成信号

+ 中断进程
  + ctrl+c，会生成SIGINT信号，停止shell中当前运行的进程
+ 暂停进程
  + ctrl+z，会生成SIGTSTP信号，停止shell中当前运行的进程
+ **停止（stopping）与终止（terminating）不同**
  + 停止，会让程序继续保留在内存中，并能从上次停止的位置继续运行
+ `ps -l`中 S列的值，如果是**T**，说明命令要么被跟踪，要么被停止了

##### 16.1.3、捕获信号

+ `trap`命令
  + `trap "echo 'Sorry! I have trapped Ctrl-C'"  SIGINT`，**用一组空格分开的待捕获的信号**

##### 16.1.4、捕获脚本退出

+ 在trap后面加上`EXIT`信号

##### 16.1.5、修改或移除捕获

#### 16.2、以后台模式运行脚本

+ 在后台模式中，进程运行时不会和终端会话上的STDIN，STDOUT以及STDERR关联

##### 16.2.1、后台运行脚本（`&`）

##### 16.2.2、运行多个后台脚本

+ 只能逐个运行
+ **ps的输出中，每一个后台进程都和终端会话（pts/0）终端联系在一起。如果终端会话退出，那么后台进程也会随之退出**

#### 16.3、在非控制台下运行脚本

+ **nohup命令运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号**
+ `nohup ./test1.sh &`

#### 16.4、作业控制

+ 启动、停止、终止以及恢复作业这些功能统称为**作业控制**

##### 16.4.1、查看作业

+ jobs命令，
  + `jobs -l`查看进程号
  + `$$`分配给脚本的PID

##### 16.4.2、重启停止的作业

+ `bg 作业号`，如果只有1个作业，**直接`bg`命令即可**

#### 16.5、调整谦让度

+ 从-20（最高优先级）到+19（最低优先级）

##### 16.5.1、nice命令

+ `nice -n 10 ./test4.sh > test4.out &`，**只能降低，不能提高**

##### 16.5.2、renice命令

+ renice命令的限制
  + `renice -n 10 -p 5055`，改变系统上已经运行的

#### 16.6、定时运行作业

##### 16.6.1、用at命令来计划执行作业

+ 4、删除作业
  + `atrm`是删除，`atq`查看哪些作业在作业队列中等待

##### 16.6.2、安排需要定期执行的脚本

+ 1、cron时间表
+ 2、构建cron时间表
  + `crontab -l`
  + **添加条目**用`-e`选项，即`crontab -e`
+ 3、浏览cron目录
  + `ls /etc/cron.*ly`

##### 16.6.3、使用新shell启动脚本

#### 16.7、小结

### chap17、创建函数

#### 17.1、基本的脚本函数

##### 17.1.1、创建函数，2种形式

+ 一种是函数名前面加`function`
+ 另一种是函数名后面加`()`

```shell
function name {commands}   #关键字function
name() {commands}    #关键的()
```



##### 17.1.2、使用函数

#### 17.2、返回值

##### 17.2.1、默认退出状态码

+ 函数中最后一条命令返回的退出状态码，可以用`$?`来确定

##### 17.2.2、使用return命令

+ 退出状态码，必须是0-255

##### 17.2.3、使用函数输出

+ `result = $(dbl)	 #dbl是函数`

#### 17.3、在函数中使用变量

##### 17.3.1、向函数传递参数

+ `$#` 判断传给函数的参数数目

##### 17.3.2、在函数中处理变量

+ 全局变量
+ 局部变量
  + `local`关键字，**保证了变量只局限在该函数中**
  + *问题，如果有2个同名的怎么办？*

#### 17.4、数组变量和函数

##### 17.4.1、向函数传数组参数

##### 17.4.2、从函数返回数组

+ test12.sh

#### 17.5、函数递归

+ test13.sh

#### 17.6、创建库

#### 17.7、在命令行上使用函数

##### 17.7.1、在命令行上创建函数

##### 17.7.2、在`.bashrc`文件中定义函数

#### 17.8、实例

+ shtool库

#### 17.9、小结

### chap19、初始sed和gawk

#### 19.1、文本处理

##### 19.1.1、sed编辑器

+ stream editor，**用预先提供的一组规则**
+ sed命令选项
  + -e，将指定的命令添加到已有命令中
  + -f file，
  + -n，不产生命令输出
+ 1、在命令行定义编辑器命令
  + `echo "This is a test" | sed '/s/test/big test/'`，把test换成big test
  + **sed编辑器并不会修改文本文件的数据。它只会将修改后的数据发送到STDOUT**
+ 2、在命令行使用多个编辑器命令
  + 用`-e`选项
  + `sed -e 's/brown/green/; s/dog/cat/' data1.txt`
+ 3、从文件中读取编辑器命令
  + `sed -f script.sed data1.txt`，其中`script.sed`中的内容是`s/dog/cat/`这样

##### 19.1.2、gawk编辑器

+ 0、
+ 1、gawk命令格式
  + -F fs
  + -f file
  + -v var=value
  + -mf N
  + -mr N
  + -W keyword
+ 2、从命令行读取程序脚本
  + **脚本用`{}`来定义**
  + `gawk '{print "Hello World!"}'`，**定义了一个print命令**
+ 3、使用数据字段变量
+ 4、在程序脚本中使用多个命令
  + `echo "My name is Rich" | gawk '{$4="Christine"; print $0}'`
+ 5、从文件中读取程序
  + `gawk -F: -f script2.gawk /etc/passwd`
+ 6、在处理数据前运行脚本
+ 7、在处理数据后运行脚本

#### 19.2、sed编辑器基础

##### 19.2.1、更多的替换选项

+ **s命令（substitute）替换，代替**
+ 1、替换命令
  + **4种替换标记**（数字、g全局，所有，p打印，w file写到文件）
  + `sed 's/test/trial/2' data4.txt`，只出现每行中第2次出现的匹配模式
  + `sed 's/test/trial/g' data4.txt`
  + `sed -n 's/test/trial/p' data4.txt`
  + `sed 's/test/trial/w test.txt' data4.txt`
+ 2、替换字符
  + **反斜线来转义**
  + `sed 's!/bin/bash!/bin/csh!' /etc/passwd`

##### 19.2.2、使用地址

+ **行寻址（line addressing）**
  + 数字形式
  + 文本模式
+ 1、数字方式的行寻址
  + `sed '2s/dog/cat/' data1.txt`，只修改第2行
  + `sed '2,3s/dog/cat/' data1.txt`
  + `sed '2,$s/dog/cat/' data1.txt`
+ 2、使用文本模式过滤器
  + `sed '/Samantha/s/bash/csh/' /etc/passwd`，*lionel，相当于去匹配Samantha的这个文本*
+ 3、命令组合
  + *lionel，未看*

##### 19.2.3、删除行

+ **d命令**
+ `sed '/number 1/d' data6.txt`，删除匹配 number 1的行
+ `sed '2,3d' data6.txt`，删除特定区间

##### 19.2.4、插入和附加文本

+ **i（insert）**，**行前**增加一个新行

  + `$ echo "Test Line 2" | sed 'i\Test Line 1'`，在Test Line 2前面一个Test Line 1

  + ```shell
    $ sed '3i\
    > This is an inserted line.' data6.txt
    #将一个新行插入到数据流第三行前
    ```

  + 

+ **a（append）**，**行后**增加一个新行

##### 19.2.5、修改行

+ **c（change）**

+ ```shell
  $ sed '3c\
  > This is a changed line of text.' data6.txt
  # 修改第三行中的文本
  
  $ sed '/number 3/c\
  > This is a changed line of text.' data6.txt
  #匹配到 number 3的那一行
  ```

##### 19.2.6、转换命令

+ **y（transform）**
+ `[address]y/inchars/outchars/`转换命令会对inchars和outchars值进行一对一的映射。
+ `$ sed 'y/123/789/' data8.txt`是把文本中的1，换成了7，2换成8，3换成9

##### 19.2.7、回顾打印

+ 3个命令（p，=，l（小写l））
+ 1、打印行
  + `sed -n '/number 3/p' data6.txt`
+ 2、打印行号
  + `sed '=' data1.txt`
+ 3、列出行
  + `sed -n 'l' data9.txt`

##### 19.2.8、使用sed处理文件

+ 1、写入文件
  + `sed '1,2w test.txt' data6.txt`，把前两行打印到一个文本文件中
+ 2、从文件读取数据
  + `sed '3r data12.txt' data6.txt` ，*把data12.txt里的文件放到data6.txt的第3行？*

#### 19.3、小结

### chap20、正则表达式

20.1、什么是正则表达式

#### 20.2、定义BRE模式

20.2.1、纯文本

##### 20.2.2、特殊字符

+ `.*[]^${}\+?|()`，*其中的`|`确实不清楚，但知道是见过的*

##### 20.2.3、锚字符

+ 1、
+ 2、锁定在行尾
+ 3、组合锚点
  + `^$`，中间啥也不加，**过滤了数据流中的空白行**
  + `sed '/^$d'`，*过滤空白行，是这么写的吗？lionel，不确定*

20.2.4、点号字符

20.2.5、字符组

20.2.6、排除型字符组

20.2.7、区间

##### 20.2.8、特殊的字符组

+ POSIX的规范，*先不记它*

20.2.9、星号

#### 20.3、扩展正则表达式

20.3.1、问号

20.3.2、加号

20.3.3、使用花括号

##### 20.3.4、管道符号

+ **用逻辑OR的方式**指定表式引擎
  + `echo "The cat is a sleep" | gawk '/cat|dog/{print $0}'`，*先管一下`|`，不看gawk的语法，lionel*

20.3.5、表达式分组

20.4、正则表达式实战

20.5、小结

### chap21、sed进阶

#### 21.1、多行命令

+ 3个特殊命令
  + N，将数据流中的下一行加进来创建一个多行组（multiline group）来处理
  + D，删除多行组中的一行
  + P，打印多行组中的一行

##### 21.1.1、next命令

+ 1、

##### 21.1.2、多行删除命令

+ 19章中的**单行删除命令（d）**

##### 21.1.3、多行打印命令

#### 21.2、保持空间

#### 21.3、排除命令

+ **`!`用来排序（negate）**
+ `sed -n '/header/!p' data2.txt`，除了单词header的那行，都打印

#### 21.4、改变流

##### 21.4.1、分支

+ `b`命令（branch）

##### 21.4.2、测试

+ `t`命令（test）

#### 21.5、模式替代

##### 21.5.1、&符号

+ &用来代表替换命令中的**匹配的模式**
+ `echo "The cat sleeps in his hat." | sed 's/.at/"&"/g'`，先匹配到了cat，"cat"就会出现在替换后的单词里。*这个要理解一下*

##### 21.5.2、替代单独的单词

#### 21.6、在脚本中使用sed

21.6.1、使用包装脚本

21.6.2、重定向sed的输出

21.7、创建sed实用工具

##### 21.7.1、加倍行间距

+ `sed 'G' data2.txt`，插入空白行
+ ` sed '$!G' data2.txt`

21.7.2、对可能含有空白行的文件加倍行间距

21.7.3、给文件中的行编号

21.7.4、打印末尾行

##### 21.7.5、删除行

+ 1、删除连续的空白行
  + `sed '/./,/^$/!d' data8.txt`
+ 2、删除开头的空白行
  + `sed '/./,$!d' data9.txt`
+ 3、删除结尾的空白行
  + 

21.7.6、删除HTML标签

21.8、小结

### chap22、gawk进阶

+ chap19的gawk，从原始数据文件生成格式化报表的基本方法

#### 22.1、使用变量

##### 22.1.1、内建变量

+ 1、字段和记录分隔符变量
  + **数据字量变量，`$1`**
+ 2、数据变量

##### 22.1.2、自定义变量

+ 1、在脚本中给变量赋值
+ 2、在命令行上给变量赋值

#### 22.2、处理数组

##### 22.2.1、定义数组变量

+ `capital["Illinois"] = "Springfield"`
  + capital是变量名
  + Illinois是关联数组的索引值
  + Springfield是数据元素值

##### 22.2.2、遍历数组变量

##### 22.2.3、删除数组变量

22.3、使用模式

22.4、结构化命令

22.5、格式化打印

22.6、内建函数

22.7、自定义函数

22.8、实例

22.9、小结

### chap23、使用其它shell

### 最后

#### 履历

+ 20220319写了点纸上的笔记，2021年1月底和2月初也看了点Part2和Part3方面的知识
+ 2023-11-21突然用了`sed`替换了一个文本，感觉像是开窍一样，于是想通过这本书，学下chap19和chap21来系统整一下（主要学了一下chap19，21没来及看呢）